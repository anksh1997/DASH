//-------- js/CWAEnv.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CWAEnv, navigator;
navigator = this.navigator;
CWAEnv = (function() {
function CWAEnv() {
throw "CWAEnv is not instantiatable.";
}
CWAEnv._mod = {};
CWAEnv.add = function(cls, cname) {
return this._mod[cname] = cls;
};
CWAEnv.get = function(cname) {
return this._mod[cname];
};
CWAEnv.fixRef = function(aname, bname) {
return this._mod[aname]["set" + bname](this._mod[bname]);
};
CWAEnv.platTag = null;
CWAEnv.browTag = null;
CWAEnv.hasJava = false;
CWAEnv._setEnvTags = function() {
var avlc, ref, uaHas, ualc;
avlc = navigator.appVersion.toLowerCase();
ualc = navigator.userAgent.toLowerCase();
uaHas = function(str) {
return (ualc.indexOf(str + "/")) !== -1;
};
this.platTag = navigator.platform;
this.browTag = uaHas("opr") ? "Opera" : (uaHas("edge")) || (uaHas("edgios")) ? "Edge" : (uaHas("firefox")) || (uaHas("fxios")) ? "Firefox" : (uaHas("chrome")) || (uaHas("crios")) ? "Chrome" : uaHas("safari") ? "Safari" : uaHas("trident") ? "IE" : uaHas("mobile") ? "Opera" : "Unknown browser \"" + ualc + "\"";
if (this.browTag === "IE") {
return this.hasJava = navigator != null ? navigator.javaEnabled() : void 0;
} else {
return this.hasJava = ((ref = navigator.mimeTypes) != null ? ref['application/x-java-applet'] : void 0) != null;
}
};
CWAEnv._setEnvTags();
return CWAEnv;
})();
this.getCWAEnv = function() {
return CWAEnv;
};
CWAEnv.add(CWAEnv, "CWAEnv");
}).call(this);
//-------- js/pretty-data-fix.js --------
/**
* pretty-data - nodejs plugin to pretty-print or minify data in XML, JSON and CSS formats.
*  
* Version - 0.40.0
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/pretty-data/
* 
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
*	pd.xml(data ) - pretty print XML;
*	pd.json(data) - pretty print JSON;
*	pd.css(data ) - pretty print CSS;
*	pd.sql(data)  - pretty print SQL;
*
*	pd.xmlmin(data [, preserveComments] ) - minify XML; 
*	pd.jsonmin(data)                      - minify JSON; 
*	pd.cssmin(data [, preserveComments] ) - minify CSS; 
*	pd.sqlmin(data)                       - minify SQL; 
*
* PARAMETERS:
*
*	@data  			- String; XML, JSON, CSS or SQL text to beautify;
* 	@preserveComments	- Bool (optional, used in minxml and mincss only); 
*				  Set this flag to true to prevent removing comments from @text; 
*	@Return 		- String;
*	
* USAGE:
*	
*	var pd  = require('pretty-data').pd;
*
*	var xml_pp   = pd.xml(xml_text);
*	var xml_min  = pd.xmlmin(xml_text [,true]);
*	var json_pp  = pd.json(json_text);
*	var json_min = pd.jsonmin(json_text);
*	var css_pp   = pd.css(css_text);
*	var css_min  = pd.cssmin(css_text [, true]);
*	var sql_pp   = pd.sql(sql_text);
*	var sql_min  = pd.sqlmin(sql_text);
*
* TEST:
*	comp-name:pretty-data$ node ./test/test_xml
*	comp-name:pretty-data$ node ./test/test_json
*	comp-name:pretty-data$ node ./test/test_css
*	comp-name:pretty-data$ node ./test/test_sql
*/
function pp() {
this.shift = ['\n']; // array of shifts
this.step = '  '; // 2 spaces
var maxdeep = 100, // nesting level
ix = 0;
// initialize array with shifts //
for(ix=0;ix<maxdeep;ix++){
this.shift.push(this.shift[ix]+this.step); 
}
};	
// ----------------------- XML section ----------------------------------------------------
pp.prototype.xml = function(text, preserveComments) {
var strg = preserveComments ? text
: text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"");
var ar = strg.replace(/>\s{0,}</g,"><")
.replace(/</g,"~::~<")
.replace(/xmlns\:/g,"~::~xmlns:")
.replace(/xmlns\=/g,"~::~xmlns=")
.split('~::~'),
len = ar.length,
inComment = false,
deep = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
// start comment or <![CDATA[...]]> or <!DOCTYPE //
if(ar[ix].search(/<!/) > -1) { 
str += this.shift[deep]+ar[ix];
inComment = true; 
// end comment  or <![CDATA[...]]> //
if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) { 
inComment = false; 
}
} else 
// end comment  or <![CDATA[...]]> //    find --> or ]>
if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) { 
str += ar[ix];
inComment = false; 
} else 
// <elm></elm> //    find prev <tag and this <\tag    but now not prev \>
if( ar[ix-1] != null && ar[ix-1].search(/\/>/) == -1 && /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
/^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) { 
// Omits indentation
// str += ar[ix];
// No longer omits indentation: For compatibility with Java PP routine
str = !inComment ? str += this.shift[--deep]+ar[ix] : str += ar[ix];
// if(!inComment) deep--;
} else
// <elm> //
//    find <tag but not </ or />
if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
str = !inComment ? str += this.shift[deep++]+ar[ix] : str += ar[ix];
} else 
// <elm>...</elm> //    find <tag and </    not sure how both can be on one line
if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
str = !inComment ? str += this.shift[deep]+ar[ix] : str += ar[ix];
} else 
// </elm> //    find </
if(ar[ix].search(/<\//) > -1) { 
str = !inComment ? str += this.shift[--deep]+ar[ix] : str += ar[ix];
} else 
// <elm/> //    find />
if(ar[ix].search(/\/>/) > -1 ) { 
str = !inComment ? str += this.shift[deep]+ar[ix] : str += ar[ix];
} else 
// <? xml ... ?> //
if(ar[ix].search(/<\?/) > -1) { 
str += this.shift[deep]+ar[ix];
} else 
// xmlns //
if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) { 
str += this.shift[deep]+ar[ix];
} 
else {
str += ar[ix];
}
}
return  (str[0] == '\n') ? str.slice(1) : str;
}
// ----------------------- JSON section ----------------------------------------------------
pp.prototype.json = function(text) {
if ( typeof text === "string" ) {
return JSON.stringify(JSON.parse(text), null, this.step);
}
if ( typeof text === "object" ) {
return JSON.stringify(text, null, this.step);
}
return null;
}
// ----------------------- CSS section ----------------------------------------------------
pp.prototype.css = function(text) {
var ar = text.replace(/\s{1,}/g,' ')
.replace(/\{/g,"{~::~")
.replace(/\}/g,"~::~}~::~")
.replace(/\;/g,";~::~")
.replace(/\/\*/g,"~::~/*")
.replace(/\*\//g,"*/~::~")
.replace(/~::~\s{0,}~::~/g,"~::~")
.split('~::~'),
len = ar.length,
deep = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
if( /\{/.exec(ar[ix]))  { 
str += this.shift[deep++]+ar[ix];
} else 
if( /\}/.exec(ar[ix]))  { 
str += this.shift[--deep]+ar[ix];
} else
if( /\*\\/.exec(ar[ix]))  { 
str += this.shift[deep]+ar[ix];
}
else {
str += this.shift[deep]+ar[ix];
}
}
return str.replace(/^\n{1,}/,'');
}
// ----------------------- SQL section ----------------------------------------------------
function isSubquery(str, parenthesisLevel) {
return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
}
function split_sql(str, tab) {
return str.replace(/\s{1,}/g," ")
.replace(/ AND /ig,"~::~"+tab+tab+"AND ")
.replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
.replace(/ CASE /ig,"~::~"+tab+"CASE ")
.replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
.replace(/ END /ig,"~::~"+tab+"END ")
.replace(/ FROM /ig,"~::~FROM ")
.replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
.replace(/ HAVING /ig,"~::~HAVING ")
//.replace(/ IN /ig,"~::~"+tab+"IN ")
.replace(/ IN /ig," IN ")
.replace(/ JOIN /ig,"~::~JOIN ")
.replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
.replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
.replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
.replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")
.replace(/ ON /ig,"~::~"+tab+"ON ")
.replace(/ OR /ig,"~::~"+tab+tab+"OR ")
.replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
.replace(/ OVER /ig,"~::~"+tab+"OVER ")
.replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
.replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")
.replace(/ THEN /ig," THEN~::~"+tab+"")
.replace(/ UNION /ig,"~::~UNION~::~")
.replace(/ USING /ig,"~::~USING ")
.replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
.replace(/ WHERE /ig,"~::~WHERE ")
.replace(/ WITH /ig,"~::~WITH ")
//.replace(/\,\s{0,}\(/ig,",~::~( ")
//.replace(/\,/ig,",~::~"+tab+tab+"")
.replace(/ ALL /ig," ALL ")
.replace(/ AS /ig," AS ")
.replace(/ ASC /ig," ASC ") 
.replace(/ DESC /ig," DESC ") 
.replace(/ DISTINCT /ig," DISTINCT ")
.replace(/ EXISTS /ig," EXISTS ")
.replace(/ NOT /ig," NOT ")
.replace(/ NULL /ig," NULL ")
.replace(/ LIKE /ig," LIKE ")
.replace(/\s{0,}SELECT /ig,"SELECT ")
.replace(/~::~{1,}/g,"~::~")
.split('~::~');
}
pp.prototype.sql = function(text) {
var ar_by_quote = text.replace(/\s{1,}/g," ")
.replace(/\'/ig,"~::~\'")
.split('~::~'),
len = ar_by_quote.length,
ar = [],
deep = 0,
tab = this.step,//+this.step,
inComment = true,
inQuote = false,
parenthesisLevel = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
if(ix%2) {
ar = ar.concat(ar_by_quote[ix]);
} else {
ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
}
}
len = ar.length;
for(ix=0;ix<len;ix++) {
parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);
if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
} 
if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
deep++;
str += this.shift[deep]+ar[ix];
} else 
if( /\'/.exec(ar[ix]) )  { 
if(parenthesisLevel<1 && deep) {
deep--;
}
str += ar[ix];
}
else  { 
str += this.shift[deep]+ar[ix];
if(parenthesisLevel<1 && deep) {
deep--;
}
} 
}
str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
return str;
}
// ----------------------- min section ----------------------------------------------------
pp.prototype.xmlmin = function(text, preserveComments) {
var str = preserveComments ? text
: text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"");
return  str.replace(/>\s{0,}</g,"><"); 
}
pp.prototype.jsonmin = function(text) {
return  text.replace(/\s{0,}\{\s{0,}/g,"{")
.replace(/\s{0,}\[$/g,"[")
.replace(/\[\s{0,}/g,"[")
.replace(/:\s{0,}\[/g,':[')
.replace(/\s{0,}\}\s{0,}/g,"}")
.replace(/\s{0,}\]\s{0,}/g,"]")
.replace(/\"\s{0,}\,/g,'",')
.replace(/\,\s{0,}\"/g,',"')
.replace(/\"\s{0,}:/g,'":')
.replace(/:\s{0,}\"/g,':"')
.replace(/:\s{0,}\[/g,':[')
.replace(/\,\s{0,}\[/g,',[')
.replace(/\,\s{2,}/g,', ')
.replace(/\]\s{0,},\s{0,}\[/g,'],[');   
}
pp.prototype.cssmin = function(text, preserveComments) {
var str = preserveComments ? text
: text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;
return str.replace(/\s{1,}/g,' ')
.replace(/\{\s{1,}/g,"{")
.replace(/\}\s{1,}/g,"}")
.replace(/\;\s{1,}/g,";")
.replace(/\/\*\s{1,}/g,"/*")
.replace(/\*\/\s{1,}/g,"*/");
}	
pp.prototype.sqlmin = function(text) {
return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
}
// --------------------------------------------------------------------------------------------
// this.Pretty = new pp;	
this.getCWAEnv().add(new pp, "Pretty");
//-------- js/Access.Node.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Access, FS, Node, XMLSerialize, cwaenv, logLev, xmlDOM;
cwaenv = this.getCWAEnv();
FS = require("fs");
xmlDOM = require("xmldom");
XMLSerialize = new xmlDOM.XMLSerializer;
Node = {
ELEMENT_NODE: 1,
TEXT_NODE: 3,
PROCESSING_INSTRUCTION_NODE: 7,
COMMENT_NODE: 8,
DOCUMENT_NODE: 9,
DOCUMENT_TYPE_NODE: 10
};
logLev = 0;
Access = (function() {
function Access() {}
Access.setLogLevel = function(lev) {
return logLev = lev;
};
Access.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
Access._DOMerr = function(level, msg) {
if (Access._DOMerrCB) {
return Access._DOMerrCB(level, msg);
} else {
return console.warn("(" + level + ") " + msg);
}
};
Access._DOMParse = new xmlDOM.DOMParser({
locator: {},
errorHandler: Access._DOMerr
});
Access.toDOM = function(theXML, errCB) {
if (errCB == null) {
errCB = null;
}
Access._DOMerrCB = errCB;
return Access._DOMParse.parseFromString(theXML, "text/xml");
};
Access.fetchURI = function(theURI, theCB) {
var doData;
Access.trace("fetchURI URI fetching: " + theURI);
doData = (function(_this) {
return function(err, data) {
var errMsg;
if (err) {
if (err.code === "ENOENT") {
errMsg = "fetchURI: " + theURI + " does not exist";
} else {
errMsg = "fetchURI: Error " + err.code + " for " + theURI;
}
Access.trace(errMsg);
return theCB(null, 1, errMsg, data);
} else {
data = (data.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
Access.trace("fetchURI URI fetched:  " + theURI);
return theCB(data, 0, null, data);
}
};
})(this);
return FS.readFile(theURI, "utf-8", doData);
};
return Access;
})();
cwaenv.add(Access, "Access");
cwaenv.add(XMLSerialize, "XMLSerialize");
cwaenv.add(Node, "Node");
this.console = console;
}).call(this);
//-------- js/Data.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Access, Data, Pretty, Sync, XMLSerialize, cwaenv, log;
cwaenv = this.getCWAEnv();
Access = cwaenv.get("Access");
Pretty = cwaenv.get("Pretty");
XMLSerialize = cwaenv.get("XMLSerialize");
log = console.log;
Data = (function() {
function Data() {}
Data.toDOM = Access.toDOM;
Data.result = function(val, errCount, errText, partVal) {
return {
value: val,
errCount: errCount,
errText: errText,
partVal: partVal
};
};
Data.parseJSON = function(jstr) {
if ((jstr != null) && jstr.length > 0) {
return JSON.parse(jstr);
} else {
console.log("JSON.parse failed for \"" + jstr + "\"");
return null;
}
};
Data.tee = function(cbA, cbB) {
return (function(_this) {
return function() {
cbA();
return cbB();
};
})(this);
};
Data.ppJSON = function(theJSON) {
return Pretty.json(theJSON);
};
Data.mnJSON = function(theJSON) {
if (typeof theJSON === "object") {
theJSON = JSON.stringify(theJSON);
}
return Pretty.jsonmin(theJSON);
};
Data.ppXML = function(theXML, pres) {
if (pres == null) {
pres = true;
}
return Pretty.xml(theXML, pres);
};
Data.mnXML = function(theXML, pres) {
if (pres == null) {
pres = false;
}
return Pretty.xmlmin(theXML, pres);
};
Data.ppDOM = function(theDOM, pres) {
if (pres == null) {
pres = true;
}
return Pretty.xml(XMLSerialize.serializeToString(theDOM), pres);
};
Data.mnDOM = function(theDOM, pres) {
if (pres == null) {
pres = false;
}
return Pretty.xmlmin(XMLSerialize.serializeToString(theDOM), pres);
};
Data.splitURI = function(uri) {
var matches, pattern;
pattern = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
matches = uri.match(pattern);
return {
scheme: matches[2],
authority: matches[4],
path: matches[5],
query: matches[7],
fragment: matches[9]
};
};
Data.stringURI = function(uriobj) {
var res;
res = uriobj.path;
if (uriobj != null ? uriobj.authority : void 0) {
res = "//" + uriobj.authority + res;
}
if (uriobj != null ? uriobj.scheme : void 0) {
res = uriobj.scheme + ":" + res;
}
if (uriobj.query != null) {
res += "?" + uriobj.query;
}
return res;
};
Data.stringURIPath = function(uriobj) {
var res;
res = uriobj.path;
if (uriobj.query != null) {
res += "?" + uriobj.query;
}
return res;
};
Data.absoluteSplitURI = function(uri, base) {
var basedir, baseobj, ref, uriobj;
uriobj = Data.splitURI(uri);
baseobj = Data.splitURI(base);
basedir = baseobj.path.substr(0, (baseobj.path.lastIndexOf("/")) + 1);
return {
scheme: uriobj.scheme || baseobj.scheme,
authority: uriobj.authority || baseobj.authority,
path: ((ref = uriobj.path) != null ? ref.charAt(0) : void 0) === "/" ? uriobj.path : basedir + uriobj.path,
query: uriobj.query || baseobj.query,
fragment: uriobj.fragment || baseobj.fragment
};
};
Data.absoluteURI = function(uri, base) {
return Data.stringURI(Data.absoluteSplitURI(uri, base));
};
Data.asDir = function(uri) {
if (uri.endsWith("/")) {
return uri;
} else {
return uri + "/";
}
};
Data.isDataURL = function(url) {
return (url.substring(0, 5)) === "data:";
};
Data.fetchURI = Access.fetchURI;
Data.fetchText = function(theURI, theCB, form) {
var textCB;
textCB = (function(_this) {
return function(val, errC, errT, part) {
if (errC === 0) {
val = (val.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
}
return theCB(val, errC, errT, part);
};
})(this);
return Data.fetchURI(theURI, textCB, form);
};
Data.fetchJSON = function(theURI, theCB, form) {
var JSONCB;
JSONCB = (function(_this) {
return function(val, errC, errT, part) {
var err, newJSON;
if (errC > 0 || val.length === 0) {
return theCB(val, errC, errT, part);
} else if (val.length === 0) {
return theCB(null, 1, "No JSON data found", val);
} else {
try {
newJSON = Data.parseJSON(val);
return theCB(newJSON, 0, null, newJSON);
} catch (error) {
err = error;
return theCB(null, 1, err, val);
}
}
};
})(this);
return Data.fetchURI(theURI, JSONCB, form);
};
Data.promiseURI = function(theURI, form) {
return new Promise((function(_this) {
return function(resolve, reject) {
var theCB;
theCB = function(val, errC, errT, part) {
if (errC > 0) {
return reject(new Error(JSON.stringify([errC, errT, part])));
} else {
return resolve(val);
}
};
return Data.fetchURI(theURI, theCB, form);
};
})(this));
};
Data.promiseURIText = function(theURI, form) {
return (Data.promiseURI(theURI, form)).then(function(res) {
return (res.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
});
};
Data.id = function(arg) {
return arg;
};
return Data;
})();
Sync = (function() {
function Sync() {
this.value = null;
this.state = 0;
this.CBs = [];
}
Sync.prototype.sync = function(CB, state) {
if (state == null) {
state = 1;
}
return this.check({
proc: CB,
state: state
});
};
Sync.syncAll = function(CB, syncs, vals) {
var theCB, theSync;
if (vals == null) {
vals = [];
}
if (syncs.length === 0) {
CB(vals);
} else {
theSync = syncs.shift();
theCB = (function(_this) {
return function(val) {
vals.push(val);
return Sync.syncAll(CB, syncs, vals);
};
})(this);
theSync.sync(theCB);
}
return null;
};
Sync.prototype.check = function(CB) {
if (CB.state === this.state) {
CB.proc(this.value);
} else {
this.CBs.push(CB);
}
return null;
};
Sync.prototype.set = function(value, state1) {
var CB, i, len, results, theCBs;
this.value = value;
this.state = state1 != null ? state1 : 1;
theCBs = this.CBs;
this.CBs = [];
results = [];
for (i = 0, len = theCBs.length; i < len; i++) {
CB = theCBs[i];
results.push(this.check(CB));
}
return results;
};
return Sync;
})();
cwaenv.add(Data, "Data");
}).call(this);
//-------- js/HNSDefs.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var HNSDefs, cwaenv;
cwaenv = this.getCWAEnv();
HNSDefs = (function() {
function HNSDefs() {}
HNSDefs.tokenNameMap = ["", "", "", "", "", "", "", "", "", "hamtab", "hamlinefeed", "", "hampagebreak", "hamreturn", "", "", "", "", "", "", "hamversion40", "", "", "", "", "", "", "", "", "", "", "", "hamspace", "hamexclaim", "hamquery", "hamfullstop", "hamcomma", "hamplus", "hammetaalt", "hamclocku", "hamclockul", "hamclockl", "hamclockdl", "hamclockd", "hamclockdr", "hamclockr", "hamclockur", "hamclockfull", "hamsymmpar", "hamsymmlr", "hamfist", "hamflathand", "hamfinger2", "hamfinger23", "hamfinger23spread", "hamfinger2345", "hamthumboutmod", "hamthumbacrossmod", "hampinch12", "hampinchall", "hampinch12open", "hamcee12", "hamceeall", "hamcee12open hamceeopen", "hamthumbopenmod", "hamfingerstraightmod", "hamfingerbendmod", "hamfingerhookedmod hamfingerhookmod", "hamnondominant", "hamdoublebent", "hamdoublehooked", "", "hamextfingeru", "hamextfingerur", "hamextfingerr", "hamextfingerdr", "hamextfingerd", "hamextfingerdl", "hamextfingerl", "hamextfingerul", "hamextfingerol", "hamextfingero", "hamextfingeror", "hamextfingeril", "hamextfingeri", "hamextfingerir", "hamextfingerui", "hamextfingerdi", "hamextfingerdo", "hamextfingeruo", "", "", "", "hamearlobe", "hamnostrils", "hamshouldertop", "hampalmu", "hampalmur", "hampalmr", "hampalmdr", "hampalmd", "hampalmdl", "hampalml", "hampalmul", "hamreplace", "hamarmextended", "hambehind", "hametc", "hamorirelative", "hamtongue", "hamteeth", "hamstomach", "hamneutralspace", "hamhead", "hamheadtop", "hamforehead", "hameyebrows", "hameyes", "hamnose", "hamear", "hamcheek", "hamlips", "hamchin", "hamunderchin", "hamneck", "hamshoulders", "hamchest", "hamstomach", "hambelowstomach", "hamlrbeside", "hamlrat", "hamUpperarm", "hamelbow", "hamelbowinside", "hamlowerarm", "hamwristback", "hamwristpulse", "hamthumbball", "hampalm", "hamhandback", "hamthumb", "hamindexfinger", "hammiddlefinger", "hamringfinger", "hampinky", "hamthumbside", "hampinkyside", "hambetween", "hamfingertip", "hamfingernail", "hamfingerpad", "hamfingermidjoint", "hamfingerbase", "hamfingerside", "hamwristtopulse", "hamwristtoback", "hamwristtothumb", "hamwristtopinky", "hamcoreftag", "hamcorefref", "hamnomotion", "hammoveu", "hammoveur", "hammover", "hammovedr", "hammoved", "hammovedl", "hammovel", "hammoveul", "hammoveol", "hammoveo", "hammoveor", "hammoveil", "hammovei", "hammoveir", "hammoveui", "hammovedi", "hammovedo", "hammoveuo", "hammovecross", "hammovex", "hamsmallmod", "hamlargemod", "hamarcl", "hamarcu", "hamarcr", "hamarcd", "hamwavy", "hamzigzag", "hamfingerplay", "hamparbegin", "hamparend", "hamcircleo", "hamcirclei", "hamcircled", "hamcircleu", "hamcirclel", "hamcircler", "hamincreasing", "hamdecreasing", "hamclose", "hamtouch", "haminterlock", "hamcross", "hamfast", "hamslow", "hamtense", "hamrest", "hamhalt", "hamrepeatfromstart", "hamrepeatfromstartseveral", "hamrepeatcontinue", "hamrepeatcontinueseveral", "hamseqbegin", "hamseqend", "hamalternatingmotion", "hamrepeatreverse", "hambrushing", "hamnonipsi", "", "hamellipseh", "hamellipseur", "hamellipsev", "hamellipseul", "hammime", "hamaltbegin", "hamaltend", "hamnodding", "hamswinging", "hamtwisting", "hamstircw", "hamstirccw", "", "", "", "", "hamfusionbegin", "hamfusionend", "", "", "hamcircleul", "hamcircledr", "hamcircleur", "hamcircledl", "hamcircleol", "hamcircleir", "hamcircleor", "hamcircleil", "hamcircledo", "hamcircleui", "hamcircledi", "hamcircleuo", "", "", "hamnbs", ""];
HNSDefs.hamMap = (function() {
var i, ix, j, len, len1, ref, ref1, str, strs, theMap;
theMap = {};
ref = HNSDefs.tokenNameMap;
for (ix = i = 0, len = ref.length; i < len; ix = ++i) {
strs = ref[ix];
ref1 = strs.split(" ");
for (j = 0, len1 = ref1.length; j < len1; j++) {
str = ref1[j];
theMap[str] = String.fromCharCode(ix);
}
}
return theMap;
})();
HNSDefs.MOUTH_PICTURE_LETTER = "m";
HNSDefs.EYES_LETTER = "e";
HNSDefs.MOUTH_GESTURE_LETTERS = "djlct";
HNSDefs.NON_MOUTH_RELATED_LETTERS = "sbh" + HNSDefs.EYES_LETTER + "n";
HNSDefs.EYES_TAG_LISTS = ["AD FR HD HI HC UP DN LE RI NO RO LU LD RU RD", "RB RR RL FU", "WB WR WL SB SR SL CB CR CL TB TR TL BB"];
HNSDefs.HNS_SHOULDER_TAG = "hnm_shoulder";
HNSDefs.HNS_BODY_TAG = "hnm_body";
HNSDefs.HNS_HEAD_TAG = "hnm_head";
HNSDefs.HNS_NOSE_TAG = "hnm_nose";
HNSDefs.NON_MOUTH_RELATED_HML_TAGS = [HNSDefs.HNS_SHOULDER_TAG, HNSDefs.HNS_BODY_TAG, HNSDefs.HNS_HEAD_TAG, null, HNSDefs.HNS_NOSE_TAG];
HNSDefs.HNS_EYEGAZE_TAG = "hnm_eyegaze";
HNSDefs.HNS_EYEBROWS_TAG = "hnm_eyebrows";
HNSDefs.HNS_EYELIDS_TAG = "hnm_eyelids";
HNSDefs.EYE_RELATED_HML_TAGS = [HNSDefs.HNS_EYEGAZE_TAG, HNSDefs.HNS_EYEBROWS_TAG, HNSDefs.HNS_EYELIDS_TAG];
HNSDefs.HNS_MOUTHGESTURE_TAG = "hnm_mouthgesture";
HNSDefs.HNS_MOUTHPICTURE_TAG = "hnm_mouthpicture";
HNSDefs.HNS_EXTRA_TAG = "hnm_extra";
HNSDefs.HNS_NONMAN_TAG = "hamnosys_nonmanual";
HNSDefs.PICTURE_ATTR = "picture";
HNSDefs.TAG_ATTR = "tag";
HNSDefs.xmlSpecials = "<>&\'\"";
HNSDefs.xmlEscapes = ["&lt;", "&gt;", "&amp;", "&apos;", "&quot;"];
return HNSDefs;
})();
cwaenv.add(HNSDefs, "HNSDefs");
}).call(this);
//-------- js/antlr3-all-fix.js --------
/*
Copyright (c) 2003-2008 Terence Parr. All rights reserved.
Code licensed under the BSD License:
http://www.antlr.org/license.html
Some parts of the ANTLR class:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
*/
/*
Some portions:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.1
*/
// create org.antlr module
if (typeof org == "undefined" || !org) {
var org = {};
}
if (typeof org.antlr == "undefined" || !org.antlr) {
/**
* The org.antlr global namespace object.  If antlr is already defined, the
* existing antlr object will not be overwritten so that defined
* namespaces are preserved.
* @namespace org.antlr
*/
org.antlr = {};
}
// JRWG: Also org.antlr.runtime seems needed
if (typeof org.antlr.runtime == "undefined" || !org.antlr.runtime) {
org.antlr.runtime = {};
}
// JRWG: Also org.antlr.runtime.tree seems needed
if (typeof org.antlr.runtime.tree == "undefined" || !org.antlr.runtime.tree) {
org.antlr.runtime.tree = {};
}
// JRWG: End
/**
* The global JavaScript object.
*/
org.antlr.global = (function() {
return this;
}).call(null);
/**
* Returns the namespace specified and creates it if it doesn't exist.
*
* Be careful when naming packages. Reserved words may work in some browsers
* and not others. For instance, the following will fail in Safari:
* <pre>
* org.antlr.namespace("really.long.nested.namespace");
* </pre>
* This fails because "long" is a future reserved word in ECMAScript
*
* @static
* @param  {String*} arguments 1-n namespaces to create 
* @return {Object}  A reference to the last namespace object created
* @example
* org.antlr.namespace("org.antlr.property.package");
*/
org.antlr.namespace = function() {
var a=arguments, o=null, i, j, d;
for (i=0; i<a.length; i=i+1) {
d=a[i].split(".");
o=org.antlr.global;
// ANTLR is implied, so it is ignored if it is included
for (j=0; j<d.length; j=j+1) {
o[d[j]]=o[d[j]] || {};
o=o[d[j]];
}
}
return o;
};
/**
* org.antlr.env is used to keep track of what is known about the library and
* the browsing environment
* @namespace org.antlr.env
*/
org.antlr.env = org.antlr.env || {};
/**
* Do not fork for a browser if it can be avoided.  Use feature detection when
* you can.  Use the user agent as a last resort.  org.antlr.env.ua stores a
* version number for the browser engine, 0 otherwise.  This value may or may
* not map to the version number of the browser using the engine.  The value is 
* presented as a float so that it can easily be used for boolean evaluation 
* as well as for looking for a particular range of versions.  Because of this, 
* some of the granularity of the version info may be lost (e.g., Gecko 1.8.0.9 
* reports 1.8).
* @namespace org.antlr.env.ua
*/
org.antlr.env.ua = function() {
var o= /** @lends org.antlr.env.ua */ {
/**
* Internet Explorer version number or 0.  Example: 6
* @property ie
* @type float
*/
ie:0,
/**
* Opera version number or 0.  Example: 9.2
* @property opera
* @type float
*/
opera:0,
/**
* Gecko engine revision number.  Will evaluate to 1 if Gecko 
* is detected but the revision could not be found. Other browsers
* will be 0.  Example: 1.8
* <pre>
* Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
* Firefox 1.5.0.9: 1.8.0.9 <-- Reports 1.8
* Firefox 2.0.0.3: 1.8.1.3 <-- Reports 1.8
* Firefox 3 alpha: 1.9a4   <-- Reports 1.9
* </pre>
* @property gecko
* @type float
*/
gecko:0,
/**
* AppleWebKit version.  KHTML browsers that are not WebKit browsers 
* will evaluate to 1, other browsers 0.  Example: 418.9.1
* <pre>
* Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the 
*                                   latest available for Mac OSX 10.3.
* Safari 2.0.2:         416     <-- hasOwnProperty introduced
* Safari 2.0.4:         418     <-- preventDefault fixed
* Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
*                                   different versions of webkit
* Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
*                                   updated, but not updated
*                                   to the latest patch.
* Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native SVG
*                                   and many major issues fixed).  
* 3.x yahoo.com, flickr:422     <-- Safari 3.x hacks the user agent
*                                   string when hitting yahoo.com and 
*                                   flickr.com.
* Safari 3.0.4 (523.12):523.12  <-- First Tiger release - automatic update
*                                   from 2.x via the 10.4.11 OS patch
* Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
*                                   yahoo.com user agent hack removed.
*                                   
* </pre>
* http://developer.apple.com/internet/safari/uamatrix.html
* @property webkit
* @type float
*/
webkit: 0,
/**
* The mobile property will be set to a string containing any relevant
* user agent information when a modern mobile browser is detected.
* Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
* devices with the WebKit-based browser, and Opera Mini.  
* @property mobile 
* @type string
*/
mobile: null,
/**
* Adobe AIR version number or 0.  Only populated if webkit is detected.
* Example: 1.0
* @property air
* @type float
*/
air: 0,
/**
* Is this the Rhino interpreter?
* @property rhino
* @type Boolean
*/
rhino: false
};
var ua, m;
try {
ua = navigator.userAgent;
// Modern KHTML browsers should qualify as Safari X-Grade
if ((/KHTML/).test(ua)) {
o.webkit=1;
}
// Modern WebKit browsers are at least X-Grade
m=ua.match(/AppleWebKit\/([^\s]*)/);
if (m&&m[1]) {
o.webkit=parseFloat(m[1]);
// Mobile browser check
if (/ Mobile\//.test(ua)) {
o.mobile = "Apple"; // iPhone or iPod Touch
} else {
m=ua.match(/NokiaN[^\/]*/);
if (m) {
o.mobile = m[0]; // Nokia N-series, ex: NokiaN95
}
}
m=ua.match(/AdobeAIR\/([^\s]*)/);
if (m) {
o.air = m[0]; // Adobe AIR 1.0 or better
}
}
if (!o.webkit) { // not webkit
// @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
m=ua.match(/Opera[\s\/]([^\s]*)/);
if (m&&m[1]) {
o.opera=parseFloat(m[1]);
m=ua.match(/Opera Mini[^;]*/);
if (m) {
o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
}
} else { // not opera or webkit
m=ua.match(/MSIE\s([^;]*)/);
if (m&&m[1]) {
o.ie=parseFloat(m[1]);
} else { // not opera, webkit, or ie
m=ua.match(/Gecko\/([^\s]*)/);
if (m) {
o.gecko=1; // Gecko detected, look for revision
m=ua.match(/rv:([^\s\)]*)/);
if (m&&m[1]) {
o.gecko=parseFloat(m[1]);
}
}
}
}
}
} catch(e) {
// ignore this if we're not in a browser
}
try {
if (typeof window=="undefined" && loadClass) {
o.rhino = true;
}
} catch(e) {}
return o;
}();
/**
* JavaScript runtime library code.
* @name org.antlr.runtime
* @namespace
*/
/**
* JavaScript runtime library tree parser code.
* @name org.antlr.runtime.tree
* @namespace
*/
org.antlr.namespace("org.antlr.runtime.tree");
/**
* Provides the language utilites and extensions used by the library
* @namespace org.antlr.lang
*/
org.antlr.lang = org.antlr.lang || /** @lends org.antlr.lang */ {
/**
* Determines whether or not the provided object is an array.
* Testing typeof/instanceof/constructor of arrays across frame 
* boundaries isn't possible in Safari unless you have a reference
* to the other frame to test against its Array prototype.  To
* handle this case, we test well-known array properties instead.
* properties.
* @param {any} o The object being testing
* @return {boolean} the result
*/
isArray: function(o) { 
if (o) {
var l = org.antlr.lang;
return l.isNumber(o.length) && l.isFunction(o.splice);
}
return false;
},
/**
* Determines whether or not the provided object is a boolean
* @param {any} o The object being testing
* @return {boolean} the result
*/
isBoolean: function(o) {
return typeof o === 'boolean';
},
/**
* Determines whether or not the provided object is a function
* @param {any} o The object being testing
* @return {boolean} the result
*/
isFunction: function(o) {
return typeof o === 'function';
},
/**
* Determines whether or not the provided object is null
* @param {any} o The object being testing
* @return {boolean} the result
*/
isNull: function(o) {
return o === null;
},
/**
* Determines whether or not the provided object is a legal number
* @param {any} o The object being testing
* @return {boolean} the result
*/
isNumber: function(o) {
return typeof o === 'number' && isFinite(o);
},
/**
* Determines whether or not the provided object is of type object
* or function
* @param {any} o The object being testing
* @return {boolean} the result
*/  
isObject: function(o) {
return (o && (typeof o === 'object' || org.antlr.lang.isFunction(o))) || false;
},
/**
* Determines whether or not the provided object is a string
* @param {any} o The object being testing
* @return {boolean} the result
*/
isString: function(o) {
return typeof o === 'string';
},
/**
* Determines whether or not the provided object is undefined
* @param {any} o The object being testing
* @return {boolean} the result
*/
isUndefined: function(o) {
return typeof o === 'undefined';
},
/**
* IE will not enumerate native functions in a derived object even if the
* function was overridden.  This is a workaround for specific functions 
* we care about on the Object prototype. 
* @param {Function} r  the object to receive the augmentation
* @param {Function} s  the object that supplies the properties to augment
* @private
*/
_IEEnumFix: function(r, s) {
if (org.antlr.env.ua.ie) {
var add=["toString", "valueOf"], i;
for (i=0;i<add.length;i=i+1) {
var fname=add[i],f=s[fname];
if (org.antlr.lang.isFunction(f) && f!=Object.prototype[fname]) {
r[fname]=f;
}
}
}
},
/**
* Utility to set up the prototype, constructor and superclass properties to
* support an inheritance strategy that can chain constructors and methods.
* Static members will not be inherited.
*
* @method extend
* @static
* @param {Function} subc   the object to modify
* @param {Function} superc the object to inherit
* @param {Object} [overrides]  additional properties/methods to add to the
*                              subclass prototype.  These will override the
*                              matching items obtained from the superclass 
*                              if present.
*/
extend: function(subc, superc, overrides) {
if (!superc||!subc) {
throw new Error("org.antlr.lang.extend failed, please check that " +
"all dependencies are included.");
}
var F = function() {};
F.prototype=superc.prototype;
subc.prototype=new F();
subc.prototype.constructor=subc;
subc.superclass=superc.prototype;
if (superc.prototype.constructor == Object.prototype.constructor) {
superc.prototype.constructor=superc;
}
if (overrides) {
for (var i in overrides) {
subc.prototype[i]=overrides[i];
}
org.antlr.lang._IEEnumFix(subc.prototype, overrides);
}
},
/**
* Applies all properties in the supplier to the receiver if the
* receiver does not have these properties yet.  Optionally, one or 
* more methods/properties can be specified (as additional 
* parameters).  This option will overwrite the property if receiver 
* has it already.  If true is passed as the third parameter, all 
* properties will be applied and _will_ overwrite properties in 
* the receiver.
*
* @param {Function} r  the object to receive the augmentation
* @param {Function} s  the object that supplies the properties to augment
* @param {String*|boolean}  [arguments] zero or more properties methods 
*        to augment the receiver with.  If none specified, everything
*        in the supplier will be used unless it would
*        overwrite an existing property in the receiver. If true
*        is specified as the third parameter, all properties will
*        be applied and will overwrite an existing property in
*        the receiver
*/
augmentObject: function(r, s) {
if (!s||!r) {
throw new Error("Absorb failed, verify dependencies.");
}
var a=arguments, i, p, override=a[2];
if (override && override!==true) { // only absorb the specified properties
for (i=2; i<a.length; i=i+1) {
r[a[i]] = s[a[i]];
}
} else { // take everything, overwriting only if the third parameter is true
for (p in s) { 
if (override || !r[p]) {
r[p] = s[p];
}
}
org.antlr.lang._IEEnumFix(r, s);
}
},
/**
* Same as org.antlr.lang.augmentObject, except it only applies prototype properties
* @see org.antlr.lang.augmentObject
* @param {Function} r  the object to receive the augmentation
* @param {Function} s  the object that supplies the properties to augment
* @param {String*|boolean}  [arguments] zero or more properties methods 
*        to augment the receiver with.  If none specified, everything 
*        in the supplier will be used unless it would overwrite an existing 
*        property in the receiver.  if true is specified as the third 
*        parameter, all properties will be applied and will overwrite an 
*        existing property in the receiver
*/
augmentProto: function(r, s) {
if (!s||!r) {
throw new Error("Augment failed, verify dependencies.");
}
//var a=[].concat(arguments);
var a=[r.prototype,s.prototype];
for (var i=2;i<arguments.length;i=i+1) {
a.push(arguments[i]);
}
org.antlr.lang.augmentObject.apply(this, a);
},
/**
* Returns a new object containing all of the properties of
* all the supplied objects.  The properties from later objects
* will overwrite those in earlier objects.
* @param arguments {Object*} the objects to merge
* @return the new merged object
*/
merge: function() {
var o={}, a=arguments;
for (var i=0, l=a.length; i<l; i=i+1) {
org.antlr.lang.augmentObject(o, a[i], true);
}
return o;
},
/**
* A convenience method for detecting a legitimate non-null value.
* Returns false for null/undefined/NaN, true for other values, 
* including 0/false/''
* @param o {any} the item to test
* @return {boolean} true if it is not null/undefined/NaN || false
*/
isValue: function(o) {
var l = org.antlr.lang;
return (l.isObject(o) || l.isString(o) || l.isNumber(o) || l.isBoolean(o));
},
/** @namespace org.antlr.lang.array Array convenience methods. */
array: /** @lends org.antlr.lang.array */ {
/**
* Retrieve the last element of an array. Throws an error if a is not
* an array or empty.
* @param a {Array} the array stack to peek in
* @return the last element of the array
*/
peek: function(a) {
if (!org.antlr.lang.isArray(a)) {
throw new Error("org.antlr.lang.array.peek: a is not an array.");
}
var l = a.length;
if (l<=0) {
throw new Error("org.antlr.lang.array.peek: a is empty.");
}
return a[l-1];
}
}
};
/** The set of fields needed by an abstract recognizer to recognize input
*  and recover from errors etc...  As a separate state object, it can be
*  shared among multiple grammars; e.g., when one grammar imports another.
*
*  These fields are publically visible but the actual state pointer per
*  parser is protected.
*/
org.antlr.runtime.RecognizerSharedState = function() {
/** Track the set of token types that can follow any rule invocation.
*  Stack grows upwards.  When it hits the max, it grows 2x in size
*  and keeps going.
*/
this.following = [];
this._fsp = -1;
/** This is true when we see an error and before having successfully
*  matched a token.  Prevents generation of more than one error message
*  per error.
*/
this.errorRecovery = false;
/** The index into the input stream where the last error occurred.
*  This is used to prevent infinite loops where an error is found
*  but no token is consumed during recovery...another error is found,
*  ad naseum.  This is a failsafe mechanism to guarantee that at least
*  one token/tree node is consumed for two errors.
*/
this.lastErrorIndex = -1;
/** In lieu of a return value, this indicates that a rule or token
*  has failed to match.  Reset to false upon valid token match.
*/
this.failed = false;
/** Did the recognizer encounter a syntax error?  Track how many. */
this.syntaxErrors = 0;
/** If 0, no backtracking is going on.  Safe to exec actions etc...
*  If >0 then it's the level of backtracking.
*/
this.backtracking = 0;
/** An array[size num rules] of Map<Integer,Integer> that tracks
*  the stop token index for each rule.  ruleMemo[ruleIndex] is
*  the memoization table for ruleIndex.  For key ruleStartIndex, you
*  get back the stop token for associated rule or MEMO_RULE_FAILED.
*
*  This is only used if rule memoization is on (which it is by default).
*/
this.ruleMemo = null;
// LEXER FIELDS (must be in same state object to avoid casting
//               constantly in generated code and Lexer object) :(
/** The goal of all lexer rules/methods is to create a token object.
*  This is an instance variable as multiple rules may collaborate to
*  create a single token.  nextToken will return this object after
*  matching lexer rule(s).  If you subclass to allow multiple token
*  emissions, then set this to the last token to be matched or
*  something nonnull so that the auto token emit mechanism will not
*  emit another token.
*/
this.token = null;
/** What character index in the stream did the current token start at?
*  Needed, for example, to get the text for current token.  Set at
*  the start of nextToken.
*/
this.tokenStartCharIndex = -1;
/** The line on which the first character of the token resides */
// this.tokenStartLine;
/** The character position of first character within the line */
// this.tokenStartCharPositionInLine;
/** The channel number for the current token */
// this.channel;
/** The token type for the current token */
// this.type;
/** You can set the text for the current token to override what is in
*  the input char buffer.  Use setText() or can set this instance var.
*/
this.text = null;
};
org.antlr.runtime.IndexOutOfBoundsException = function(m) {
org.antlr.runtime.IndexOutOfBoundsException.superclass.constructor.call(this, m);
};
org.antlr.lang.extend(org.antlr.runtime.IndexOutOfBoundsException, Error, {
name: "org.antlr.runtime.IndexOutOfBoundsException"
});
/** The root of the ANTLR exception hierarchy.
*
*  <p>To avoid English-only error messages and to generally make things
*  as flexible as possible, these exceptions are not created with strings,
*  but rather the information necessary to generate an error.  Then
*  the various reporting methods in Parser and Lexer can be overridden
*  to generate a localized error message.  For example, MismatchedToken
*  exceptions are built with the expected token type.
*  So, don't expect getMessage() to return anything.</p>
*
*  <p>ANTLR generates code that throws exceptions upon recognition error and
*  also generates code to catch these exceptions in each rule.  If you
*  want to quit upon first error, you can turn off the automatic error
*  handling mechanism using rulecatch action, but you still need to
*  override methods mismatch and recoverFromMismatchSet.</p>
*
*  <p>In general, the recognition exceptions can track where in a grammar a
*  problem occurred and/or what was the expected input.  While the parser
*  knows its state (such as current input symbol and line info) that
*  state can change before the exception is reported so current token index
*  is computed and stored at exception time.  From this info, you can
*  perhaps print an entire line of input not just a single token, for example.
*  Better to just say the recognizer had a problem and then let the parser
*  figure out a fancy report.</p>
*
*  @class
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*  @extends Error
*
*/
org.antlr.runtime.RecognitionException = function(input) {
org.antlr.runtime.RecognitionException.superclass.constructor.call(this);
this.input = input;
this.index = input.index();
if ( input instanceof org.antlr.runtime.CommonTokenStream ) {
this.token = input.LT(1);
this.line = this.token.getLine();
this.charPositionInLine = this.token.getCharPositionInLine();
}
if ( input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
this.extractInformationFromTreeNodeStream(input);
}
else if ( input instanceof org.antlr.runtime.ANTLRStringStream ) {
// Note: removed CharStream from hierarchy in JS port so checking for
// StringStream instead
this.c = input.LA(1);
this.line = input.getLine();
this.charPositionInLine = input.getCharPositionInLine();
}
else {
this.c = input.LA(1);
}
this.message = this.toString();
};
org.antlr.lang.extend(org.antlr.runtime.RecognitionException, Error,
/** @lends org.antlr.runtime.RecognitionException.prototype */
{
/**
* What input stream did the error occur in?
*/
input: null,
/** What is index of token/char were we looking at when the error occurred?
*  @type Number
*/
index: null,
/** The current Token when an error occurred.  Since not all streams
*  can retrieve the ith Token, we have to track the Token object.
*  For parsers.  Even when it's a tree parser, token might be set.
*  @type org.antlr.runtime.CommonToken
*/
token: null,
/** If this is a tree parser exception, node is set to the node with
*  the problem.
*  @type Object
*/
node: null,
/** The current char when an error occurred. For lexers.
*  @type Number
*/
c: null,
/** Track the line at which the error occurred in case this is
*  generated from a lexer.  We need to track this since the
*  unexpected char doesn't carry the line info.
*  @type Number
*/
line: null,
/** The exception's class name.
*  @type String
*/
name: "org.antlr.runtime.RecognitionException",
/** Position in the line where exception occurred.
*  @type Number
*/
charPositionInLine: null,
/** If you are parsing a tree node stream, you will encounter som
*  imaginary nodes w/o line/col info.  We now search backwards looking
*  for most recent token with line/col info, but notify getErrorHeader()
*  that info is approximate.
*  @type Boolean
*/
approximateLineInfo: null,
/** Gather exception information from input stream.
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*/
extractInformationFromTreeNodeStream: function(input) {
var nodes = input,
priorNode,
priorPayLoad,
type,
text,
i;
this.node = nodes.LT(1);
var adaptor = nodes.getTreeAdaptor(),
payload = adaptor.getToken(this.node);
if ( payload ) {
this.token = payload;
if ( payload.getLine()<= 0 ) {
// imaginary node; no line/pos info; scan backwards
i = -1;
priorNode = nodes.LT(i);
while ( priorNode ) {
priorPayload = adaptor.getToken(priorNode);
if ( priorPayload && priorPayload.getLine()>0 ) {
// we found the most recent real line / pos info
this.line = priorPayload.getLine();
this.charPositionInLine = priorPayload.getCharPositionInLine();
this.approximateLineInfo = true;
break;
}
--i;
priorNode = nodes.LT(i);
}
}
else { // node created from real token
this.line = payload.getLine();
this.charPositionInLine = payload.getCharPositionInLine();
}
}
else if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
this.line = this.node.getLine();
this.charPositionInLine = this.node.getCharPositionInLine();
if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
this.token = this.node.token;
}
}
else {
type = adaptor.getType(this.node);
text = adaptor.getText(this.node);
this.token = new org.antlr.runtime.CommonToken(type, text);
}
},
/** Return the token type or char of the unexpected input element
*  @return {Number} type of the unexpected input element.
*/
getUnexpectedType: function() {
if ( this.input instanceof org.antlr.runtime.CommonTokenStream ) {
return this.token.getType();
}
else if ( this.input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
var nodes = this.input;
var adaptor = nodes.getTreeAdaptor();
return adaptor.getType(this.node);
}
else {
return this.c;
}
}
});
org.antlr.runtime.MismatchedTokenException = function(expecting, input) {
if (arguments.length===0) {
this.expecting = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
} else {
org.antlr.runtime.MismatchedTokenException.superclass.constructor.call(
this, input);
this.expecting = expecting;
}
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedTokenException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedTokenException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedTokenException"
});
/** An extra token while parsing a TokenStream */
org.antlr.runtime.UnwantedTokenException = function(expecting, input) {
if (arguments.length>0) {
org.antlr.runtime.UnwantedTokenException.superclass.constructor.call(
this, expecting, input);
}
};
org.antlr.lang.extend(
org.antlr.runtime.UnwantedTokenException,
org.antlr.runtime.MismatchedTokenException, {
getUnexpectedToken: function() {
return this.token;
},
toString: function() {
var exp = ", expected "+this.expecting;
if ( this.expecting===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
exp = "";
}
if ( !org.antlr.lang.isValue(this.token) ) {
return "UnwantedTokenException(found="+exp+")";
}
return "UnwantedTokenException(found="+this.token.getText()+exp+")";
},
name: "org.antlr.runtime.UnwantedTokenException"
});
org.antlr.runtime.MissingTokenException = function(expecting, input, inserted) {
if (arguments.length>0) {
org.antlr.runtime.MissingTokenException.superclass.constructor.call(
this, expecting, input);
this.inserted = inserted;
}
};
org.antlr.lang.extend(
org.antlr.runtime.MissingTokenException,
org.antlr.runtime.MismatchedTokenException, {
getMissingType: function() {
return this.expecting;
},
toString: function() {
if (org.antlr.lang.isValue(this.inserted) &&
org.antlr.lang.isValue(this.token))
{
return "MissingTokenException(inserted "+this.inserted+" at "+this.token.getText()+")";
}
if ( org.antlr.lang.isValue(this.token) ) {
return "MissingTokenException(at "+this.token.getText()+")";
}
return "MissingTokenException";
},
name: "org.antlr.runtime.MissingTokenException"
});
org.antlr.runtime.NoViableAltException = function(grammarDecisionDescription,
decisionNumber,
stateNumber,
input)
{
org.antlr.runtime.NoViableAltException.superclass.constructor.call(this, input);
this.grammarDecisionDescription = grammarDecisionDescription;
this.decisionNumber = decisionNumber;
this.stateNumber = stateNumber;
};
org.antlr.lang.extend(
org.antlr.runtime.NoViableAltException,
org.antlr.runtime.RecognitionException, {
toString: function() {
if ( this.input instanceof org.antlr.runtime.ANTLRStringStream ) {
return "NoViableAltException('"+this.getUnexpectedType()+"'@["+this.grammarDecisionDescription+"])";
}
else {
return "NoViableAltException("+this.getUnexpectedType()+"@["+this.grammarDecisionDescription+"])";
}
},
name: "org.antlr.runtime.NoViableAltException"
});
/** The recognizer did not match anything for a ()+ loop.
*
*  @class
*  @param {Number} decisionNumber
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*  @extends org.antlr.runtime.RecognitionException
*/
org.antlr.runtime.EarlyExitException = function(decisionNumber, input) {
org.antlr.runtime.EarlyExitException.superclass.constructor.call(
this, input);
this.decisionNumber = decisionNumber;
};
org.antlr.lang.extend(
org.antlr.runtime.EarlyExitException,
org.antlr.runtime.RecognitionException,
/** @lends org.antlr.runtime.EarlyExitException.prototype */
{
/** Name of this class.
*  @type String
*/
name: "org.antlr.runtime.EarlyExitException"
});
org.antlr.runtime.MismatchedSetException = function(expecting, input) {
org.antlr.runtime.MismatchedSetException.superclass.constructor.call(
this, input);
this.expecting = expecting;
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedSetException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedSetException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedSetException"
});
org.antlr.runtime.MismatchedNotSetException = function(expecting, input) {
org.antlr.runtime.MismatchedNotSetException.superclass.constructor.call(this, expecting, input);
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedNotSetException,
org.antlr.runtime.MismatchedSetException, {
toString: function() {
return "MismatchedNotSetException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedNotSetException"
});
org.antlr.runtime.MismatchedRangeException = function(a, b, input) {
if (arguments.length===0) {
return this;
}
org.antlr.runtime.MismatchedRangeException.superclass.constructor.call(
this, input);
this.a = a;
this.b = b;
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedRangeException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedRangeException(" +
this.getUnexpectedType()+" not in ["+this.a+","+this.b+"])";
},
name: "org.antlr.runtime.MismatchedRangeException"
});
/** A semantic predicate failed during validation.  Validation of predicates
*  occurs when normally parsing the alternative just like matching a token.
*  Disambiguating predicate evaluation occurs when we hoist a predicate into
*  a prediction decision.
*
*  @class
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*  @param {String} ruleName name of the rule in which the exception occurred.
*  @param {String} predicateText the predicate that failed.
*  @extends org.antlr.runtime.RecognitionException
*/
org.antlr.runtime.FailedPredicateException = function(input, ruleName, predicateText){
org.antlr.runtime.FailedPredicateException.superclass.constructor.call(this, input);
this.ruleName = ruleName;
this.predicateText = predicateText;
};
org.antlr.lang.extend(
org.antlr.runtime.FailedPredicateException,
org.antlr.runtime.RecognitionException,
/** @lends org.antlr.runtime.FailedPredicateException.prototype */
{
/** Create a string representation of this exception.
*  @returns {String}
*/ 
toString: function() {
return "FailedPredicateException("+this.ruleName+",{"+this.predicateText+"}?)";
},
/** Name of this class.
*  @type String
*/
name: "org.antlr.runtime.FailedPredicateException"
});
/**
* A BitSet similar to java.util.BitSet.
*
* <p>JavaScript Note: There is no good way to implement something like this in 
* JavaScript.  JS has no true int type, arrays are usually implemented as
* hashes, etc.  This class should probably be nixed for something that is
* similarly (in)efficient, but more clear.</p>
*
* @class
* @param {Number|Array} [bits] a 32 bit number or array of 32 bit numbers
*                              representing the bitset.  These are typically
*                              generated by the ANTLR Tool.
*/
org.antlr.runtime.BitSet = function(bits) {
if (!bits) {
bits = org.antlr.runtime.BitSet.BITS;
}
if (org.antlr.lang.isArray(bits)) {
/**
* An array of Numbers representing the BitSet.
* @type Array
*/
this.bits = bits;
} else if(org.antlr.lang.isNumber(bits)) {
this.bits = [];
}
};
org.antlr.lang.augmentObject(org.antlr.runtime.BitSet, {
/**
* Number of bits in each number.
* @constant
* @memberOf org.antlr.runtime.BitSet
*/
BITS: 32,
/**
* Log (base 2) of the number of bits in each number.
* @constant
* @memberOf org.antlr.runtime.BitSet
*/
LOG_BITS: 5,  // 2^5 == 32 
/**
* We will often need to do a mod operator (i mod nbits).  Its
* turns out that, for powers of two, this mod operation is
* same as (i & (nbits-1)).  Since mod is slow, we use a
* precomputed mod mask to do the mod instead.
* @constant
* @memberOf org.antlr.runtime.BitSet
*/
MOD_MASK: 31, // BITS - 1
/**
* Create mask for bit modded to fit in a single word.
* @example
* bitmask(35) => 00000000000000000000000000000100
* bitmask(3)  => 00000000000000000000000000000100
* @param {Number} bitNumber the bit to create a mask for.
* @returns {Number} the bitmask.
* @memberOf org.antlr.runtime.BitSet
* @private
*/
bitMask: function(bitNumber) {
var bitPosition = bitNumber & org.antlr.runtime.BitSet.MOD_MASK;
return 1 << bitPosition;
},
/**
* Calculate the minimum number of bits needed to represent el.
* @param {Number} el a number to be included in the BitSet.
* @returns {Number} the number of bits need to create a BitSet with member
*                   el.
* @memberOf org.antlr.runtime.BitSet
* @private
*/
numWordsToHold: function(el) {
return (el >> org.antlr.runtime.BitSet.LOG_BITS) + 1;
},
/**
* @param {Number} bit a number to be included in the BitSet
* @returns {Number} the index of the word in the field bits that would
*                   hold bit.
* @memberOf org.antlr.runtime.BitSet
* @private
*/
wordNumber: function(bit) {
return bit >> org.antlr.runtime.BitSet.LOG_BITS; // bit / BITS
},
/**
* BitSet factory method.
* 
* <p>Operates in a number of modes:
* <ul>
* <li>If el is a number create the BitSet containing that number.</li>
* <li>If el is an array create the BitSet containing each number in the
* array.</li>
* <li>If el is a BitSet return el.</li>
* <li>If el is an Object create the BitSet containing each numeric value
* in el.</li>
* <li>If el is a number and el2 is a number return a BitSet containing
* the numbers between el and el2 (inclusive).</li>
* </ul>
* </p>
* @param {Number|Array|org.antlr.runtime.BitSet|Object} el
* @param {Number} el2
* @returns {org.antlr.runtime.BitSet}
* @memberOf org.antlr.runtime.BitSet
*/
of: function(el, el2) {
var i, n, s, keys;
if (org.antlr.lang.isNumber(el)) {
if (org.antlr.lang.isNumber(el2)) {
s = new org.antlr.runtime.BitSet(el2 + 1);
for (i = el; i <= el2; i++) {
n = org.antlr.runtime.BitSet.wordNumber(i);
s.bits[n] |= org.antlr.runtime.BitSet.bitMask(i);
}
return s;
} else {
s = new org.antlr.runtime.BitSet(el + 1);
s.add(el);
return s;
}
} else if(org.antlr.lang.isArray(el)) {
s = new org.antlr.runtime.BitSet();
for (i=el.length-1; i>=0; i--) {
s.add(el[i]);
}
return s;
} else if (el instanceof org.antlr.runtime.BitSet) {
if (!el) {
return null;
}
return el;
} else if (el instanceof org.antlr.runtime.IntervalSet) {
if (!el) {
return null;
}
s = new org.antlr.runtime.BitSet();
s.addAll(el);
return s;
} else if (org.antlr.lang.isObject(el)) {
keys = [];
for (i in el) {
if (org.antlr.lang.isNumber(i)) {
keys.push(i);
}
}
return org.antlr.runtime.BitSet.of(keys);
}
}
});
org.antlr.runtime.BitSet.prototype = {
/**
* Add el into this set.
* @param {Number} el the number to add to the set.
*/
add: function(el) {
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) {
this.growToInclude(el);
}
this.bits[n] |= org.antlr.runtime.BitSet.bitMask(el);
},
/**
* Add multiple elements into this set.
* @param {Array|org.antlr.runtime.BitSet} elements the elements to be added to
*                                           this set.
*/
addAll: function(elements) {
var other,
i,
e;
if ( elements instanceof org.antlr.runtime.BitSet ) {
this.orInPlace(elements);
}
else if ( elements instanceof org.antlr.runtime.IntervalSet ) {
other = elements;
// walk set and add each interval
/* @todo after implementing intervalset
for (Iterator iter = other.intervals.iterator(); iter.hasNext();) {
Interval I = (Interval) iter.next();
this.orInPlace(BitSet.range(I.a,I.b));
}*/
} else if (org.antlr.lang.isArray(elements)) {
for (i = 0; i < elements.length; i++) {
e = elements[i];
this.add(e);
}
} else {
return;
}
},
/**
* Clone this BitSet and then {@link #andInPlace} with a.
* @param {org.antlr.runtime.BitSet} a a bit set.
* @returns {org.antlr.runtime.BitSet}
*/
and: function(a) {
var s = this.clone();
s.andInPlace(a);
return s;
},
/**
* Perform a logical AND of this target BitSet with the argument BitSet.
*
* This bit set is modified so that each bit in it has the value true if 
* and only if it both initially had the value true and the corresponding 
* bit in the bit set argument also had the value true. 
* @param {org.antlr.runtime.BitSet} a a bit set.
* @returns {org.antlr.runtime.BitSet}
*/
andInPlace: function(a) {
var min = Math.min(this.bits.length, a.bits.length),
i;
for (i = min - 1; i >= 0; i--) {
this.bits[i] &= a.bits[i];
}
// clear all bits in this not present in a (if this bigger than a).
for (i = min; i < this.bits.length; i++) {
this.bits[i] = 0;
}
},
/**
* Clear all bits or a specific bit.
*
* If no arguments given, sets all of the bits in this BitSet to false.
* If one argument given, sets the bit specified by the index to false.
* @param {Number} [el] the index of the bit to be cleared.
*/
clear: function(el) {
if (arguments.length===0) {
var i;
for (i = this.bits.length - 1; i >= 0; i--) {
this.bits[i] = 0;
}
return;
}
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) {	// grow as necessary to accommodate
this.growToInclude(el);
}
this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
},
/**
* Cloning this BitSet produces a new BitSet  that is equal to it. 
*
* The clone of the bit set is another bit set that has exactly the same
* bit set to true as this bit set. 
* @returns {org.antlr.runtime.BitSet} a clone of this BitSet.
*/
clone: function() {
var i, len, b=[];
for (i=0, len=this.bits.length; i<len; i++) {
b[i] = this.bits[i];
}
return new org.antlr.runtime.BitSet(b);
},
/**
* Returns the number of bits of space actually in use by this BitSet to 
* represent bit values.
*
* The maximum element in the set is the size - 1st element. 
* @returns {Number} the number of bits currently in this bit set.
*/
size: function() {
var deg = 0, i, word, bit;
for (i = this.bits.length - 1; i >= 0; i--) {
word = this.bits[i];
if (word !== 0) {
for (bit = org.antlr.runtime.BitSet.BITS - 1; bit >= 0; bit--) {
if ((word & (1 << bit)) !== 0) {
deg++;
}
}
}
}
return deg;
},
/**
* Compares this object against the specified object.
*
* The result is true if and only if the argument is not null and is a
* BitSet object that has exactly the same set of bits set to true as
* this bit set. That is, for every nonnegative int index k,
* <pre><code>
* ((BitSet)obj).get(k) == this.get(k)
* </code></pre>
* must be true. The current sizes of the two bit sets are not compared.
* @param {Object} other the object to compare with.
* @returns {Boolean} if the objects are the same; false otherwise.
*/
equals: function(other) {
if ( !other || !(other instanceof org.antlr.runtime.BitSet) ) {
return false;
}
var otherSet = other,
i,
n = Math.min(this.bits.length, otherSet.bits.length);
// for any bits in common, compare
for (i=0; i<n; i++) {
if (this.bits[i] != otherSet.bits[i]) {
return false;
}
}
// make sure any extra bits are off
if (this.bits.length > n) {
for (i = n+1; i<this.bits.length; i++) {
if (this.bits[i] !== 0) {
return false;
}
}
}
else if (otherSet.bits.length > n) {
for (i = n+1; i<otherSet.bits.length; i++) {
if (otherSet.bits[i] !== 0) {
return false;
}
}
}
return true;
},
/**
* Grows the set to a larger number of bits.
* @param {Number} bit element that must fit in set
* @private
*/
growToInclude: function(bit) {
var newSize = Math.max(this.bits.length << 1, org.antlr.runtime.BitSet.numWordsToHold(bit)),
newbits = [], //new Array(newSize),
i;
for (i=0, len=this.bits.length; i<len; i++) {
newbits[i] = this.bits[i];
}
this.bits = newbits;
},
/**
* Returns the value of the bit with the specified index.
*
* The value is true if the bit with the index el is currently set 
* in this BitSet; otherwise, the result is false.
* @param {Number} el the bit index.
* @returns {Boolean} the value of the bit with the specified index.
*/
member: function(el) {
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) { return false; }
return (this.bits[n] & org.antlr.runtime.BitSet.bitMask(el)) !== 0;
},
/**
* Returns the index of the first bit that is set to true.
* If no such bit exists then -1 is returned.
* @returns {Number} the index of the next set bit.
*/
getSingleElement: function() {
var i;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
return i;
}
}
return -1; //Label.INVALID;
},
/**
* Returns true if this BitSet contains no bits that are set to true.
* @returns {Boolean} boolean indicating whether this BitSet is empty.
*/
isNil: function() {
var i;
for (i = this.bits.length - 1; i >= 0; i--) {
if (this.bits[i] !== 0) {
return false;
}
}
return true;
},
/**
* If a bit set argument is passed performs a {@link #subtract} of this bit
* set with the argument bit set.  If no argument is passed, clone this bit
* set and {@link #notInPlace}.
* @param {org.antlr.runtime.BitSet} [set]
* @returns {org.antlr.runtime.BitSet}
*/
complement: function(set) {
if (set) {
return set.subtract(this);
} else {
var s = this.clone();
s.notInPlace();
return s;
}
},
/**
* If no arguments are passed sets all bits to the complement of their
* current values.  If one argument is passed sets each bit from the
* beginning of the bit set to index1 (inclusive) to the complement of its
* current value.  If two arguments are passed sets each bit from the
* specified index1 (inclusive) to the sepcified index2 (inclusive) to the
* complement of its current value.
* @param {Number} index1
* @param {Number} index2
*/
notInPlace: function() {
var minBit, maxBit, i, n;
if (arguments.length===0) {
for (i = this.bits.length - 1; i >= 0; i--) {
this.bits[i] = ~this.bits[i];
}
} else {
if (arguments.length===1) {
minBit = 0;
maxBit = arguments[0];
} else {
minBit = arguments[0];
maxBit = arguments[1];
}
// make sure that we have room for maxBit
this.growToInclude(maxBit);
for (i = minBit; i <= maxBit; i++) {
n = org.antlr.runtime.BitSet.wordNumber(i);
this.bits[n] ^= org.antlr.runtime.BitSet.bitMask(i);
}
}
},
/**
* Performs a logical OR of this bit set with the bit set argument.
* If no argument is passed, return this bit set.  Otherwise a clone of
* this bit set is modified so that a bit in it has the value true if and
* only if it either already had the value true or the corresponding bit
* in the bit set argument has the value true.
* @param {org.antlr.runtime.BitSet} [a] a bit set.
* @returns {org.antlr.runtime.BitSet}
*/
or: function(a) {
if ( !a ) {
return this;
}
var s = this.clone();
s.orInPlace(a);
return s;
},
/**
* Performs a logical {@link #or} in place.
* @param {org.antlr.runtime.BitSet} [a]
* @returns {org.antlr.runtime.BitSet}
*/
orInPlace: function(a) {
if ( !a ) {
return;
}
// If this is smaller than a, grow this first
if (a.bits.length > this.bits.length) {
this.setSize(a.bits.length);
}
var min = Math.min(this.bits.length, a.bits.length),
i;
for (i = min - 1; i >= 0; i--) {
this.bits[i] |= a.bits[i];
}
},
/**
* Sets the bit specified by the index to false.
* @param {Number} bitIndex the index of the bit to be cleared.
*/
remove: function(el) {
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) {
this.growToInclude(el);
}
this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
},
/**
* Grows the internal bits array to include at least nwords numbers.
* @private
* @param {Number} nwords how many words the new set should be
* @private
*/
setSize: function(nwords) {
var n = nwords - this.bits.length;
while (n>=0) {
this.bits.push(0);
n--;
}
},
/**
* Returns the number of bits capable of being represented by this bit set
* given its current size.
* @returns {Number} the maximum number of bits that can be represented at
*                   the moment.
* @private
*/
numBits: function() {
return this.bits.length << org.antlr.runtime.BitSet.LOG_BITS; // num words * bits per word
},
/**
* Return how much space is being used by the bits array not
* how many actually have member bits on.
* @returns {Number} the length of the internal bits array.
* @private
*/
lengthInLongWords: function() {
return this.bits.length;
},
/**
* Is this bit set contained within a?
* @param {org.antlr.runtime.BitSet} a bit set
* @returns {Boolean} true if and only if a is a subset of this bit set.
*/
subset: function(a) {
if (!a) { return false; }
return this.and(a).equals(this);
},
/**
* Subtract the elements of the argument bit set from this bit set in place.
* That is, for each set bit in the argument bit set, set the corresponding
* bit in this bit set to false.
* @param {org.antlr.runtime.BitSet} a bit set.
*/
subtractInPlace: function(a) {
if (!a) { return; }
// for all words of 'a', turn off corresponding bits of 'this'
var i;
for (i = 0; i < this.bits.length && i < a.bits.length; i++) {
this.bits[i] &= ~a.bits[i];
}
},
/**
* Perform a {@link #subtractInPlace} on a clone of this bit set.
* @param {org.antlr.runtime.BitSet} a bit set.
* @returns {org.antlr.runtime.BitSet} the new bit set.
*/
subtract: function(a) {
if (!a || !(a instanceof org.antlr.runtime.BitSet)) { return null; }
var s = this.clone();
s.subtractInPlace(a);
return s;
},
/* antlr-java needs this to make its class hierarchy happy . . .
toList: function() {
throw new Error("BitSet.toList() unimplemented");
},
*/
/**
* Creates an array of the indexes of each bit set in this bit set.
* @returns {Array}
*/
toArray: function() {
var elems = [], //new Array(this.size()),
i,
en = 0;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
elems[en++] = i;
}
}
return elems;
},
/**
* Returns the internal representation of this bit set.
* This representation is an array of numbers, each representing 32 bits.
* @returns {Array}
*/
toPackedArray: function() {
return this.bits;
},
/**
* Returns a string representation of this bit set.
* <p>For every index for which this BitSet contains a bit in the set state,
* the decimal representation of that index is included in the result.
* Such indices are listed in order from lowest to highest, separated by
* ", " (a comma and a space) and surrounded by braces, resulting in the
* usual mathematical notation for a set of integers.</p>
* 
* <p>If a grammar g is passed, print g.getTokenDisplayName(i) for each set
* index instead of the numerical index.</p>
*
* <>If two arguments are passed, the first will be used as a custom
* separator string.  The second argument is an array whose i-th element
* will be added if the corresponding bit is set.</p>
*
* @param {Object|String} [arg1] an Object with function property
*      getTokenDispalyName or a String that will be used as a list
*      separator.
* @param {Array} [vocabulary] array from which the i-th value will be
*      drawn if the corresponding bit is set.  Must pass a string as the
*      first argument if using this option.
* @return A commma-separated list of values
*/
toString: function() {
if (arguments.length===0) {
return this.toString1(null);
} else {
if (org.antlr.lang.isString(arguments[0])) {
if (!org.antlr.lang.isValue(arguments[1])) {
return this.toString1(null);
} else {
return this.toString2(arguments[0], arguments[1]);
}
} else {
return this.toString1(arguments[0]);
}
}
},
/**
* Transform a bit set into a string by formatting each element as an
* integer separator The string to put in between elements
* @private
* @return A commma-separated list of values
*/
toString1: function(g) {
var buf = "{",
separator = ",",
i,
havePrintedAnElement = false;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
if (i > 0 && havePrintedAnElement ) {
buf += separator;
}
if ( g ) {
buf += g.getTokenDisplayName(i);
}
else {
buf += i.toString();
}
havePrintedAnElement = true;
}
}
return buf + "}";
},
/**
* Create a string representation where instead of integer elements, the
* ith element of vocabulary is displayed instead.  Vocabulary is a Vector
* of Strings.
* separator The string to put in between elements
* @private
* @return A commma-separated list of character constants.
*/
toString2: function(separator, vocabulary) {
var str = "",
i;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
if (str.length > 0) {
str += separator;
}
if (i >= vocabulary.size()) {
str += "'" + i + "'";
}
else if (!org.antlr.lang.isValue(vocabulary.get(i))) {
str += "'" + i + "'";
}
else {
str += vocabulary.get(i);
}
}
}
return str;
}
/*
* Dump a comma-separated list of the words making up the bit set.
* Split each 32 bit number into two more manageable 16 bit numbers.
* @returns {String} comma separated list view of the this.bits property.
*
toStringOfHalfWords: function() {
var s = "",
tmp,
i;
for (i = 0; i < this.bits.length; i++) {
if (i !== 0) {
s+=", ";
}
tmp = this.bits[i];
tmp &= 0xFFFF;
s += tmp + "UL, ";
tmp = this.bits[i] >> 16;
tmp &= 0xFFFF;
s += tmp+"UL";
}
return s;
},
*/
/*
* Dump a comma-separated list of the words making up the bit set.
* This generates a comma-separated list of Java-like long int constants.
*
toStringOfWords: function() {
var s="",
i;
for (i = 0; i < this.bits.length; i++) {
if (i !== 0) {
s+=", ";
}
s += this.bits[i]+"L";
}
return s;
},
toStringWithRanges: function() {
return this.toString();
}
*/
};
/*
*
*
org.antlr.runtime.IntervalSet = function() {
throw new Error("not implemented");
};
*/
org.antlr.runtime.CharStream = {
EOF: -1
};
org.antlr.runtime.CommonToken = function() {
var oldToken;
this.charPositionInLine = -1; // set to invalid position
this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
this.index = -1;
if (arguments.length == 1) {
if (org.antlr.lang.isNumber(arguments[0])) {
this.type = arguments[0];
} else {
oldToken = arguments[0];
this.text = oldToken.getText();
this.type = oldToken.getType();
this.line = oldToken.getLine();
this.index = oldToken.getTokenIndex();
this.charPositionInLine = oldToken.getCharPositionInLine();
this.channel = oldToken.getChannel();
if ( oldToken instanceof org.antlr.runtime.CommonToken ) {
this.start = oldToken.start;
this.stop = oldToken.stop;
}
}
} else if (arguments.length == 2) {
this.type = arguments[0];
this.text = arguments[1];
this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
} else if (arguments.length == 5) {
this.input = arguments[0];
this.type = arguments[1];
this.channel = arguments[2];
this.start = arguments[3];
this.stop = arguments[4];
}
};
org.antlr.runtime.CommonToken.prototype = {
getType: function() {
return this.type;
},
setLine: function(line) {
this.line = line;
},
getText: function() {
if ( org.antlr.lang.isString(this.text) ) {
return this.text;
}
if ( !this.input ) {
return null;
}
this.text = this.input.substring(this.start,this.stop);
return this.text;
},
/** Override the text for this token.  getText() will return this text
*  rather than pulling from the buffer.  Note that this does not mean
*  that start/stop indexes are not valid.  It means that that input
*  was converted to a new string in the token object.
*/
setText: function(text) {
this.text = text;
},
getLine: function() {
return this.line;
},
getCharPositionInLine: function() {
return this.charPositionInLine;
},
setCharPositionInLine: function(charPositionInLine) {
this.charPositionInLine = charPositionInLine;
},
getChannel: function() {
return this.channel;
},
setChannel: function(channel) {
this.channel = channel;
},
setType: function(type) {
this.type = type;
},
getStartIndex: function() {
return this.start;
},
setStartIndex: function(start) {
this.start = start;
},
getStopIndex: function() {
return this.stop;
},
setStopIndex: function(stop) {
this.stop = stop;
},
getTokenIndex: function() {
return this.index;
},
setTokenIndex: function(index) {
this.index = index;
},
getInputStream: function() {
return this.input;
},
setInputStream: function(input) {
this.input = input;
},
toString: function() {
var channelStr = "";
if ( this.channel>0 ) {
channelStr=",channel="+this.channel;
}
var txt = this.getText();
if ( !org.antlr.lang.isNull(txt) ) {
txt = txt.replace(/\n/g,"\\\\n");
txt = txt.replace(/\r/g,"\\\\r");
txt = txt.replace(/\t/g,"\\\\t");
}
else {
txt = "<no text>";
}
return "[@"+this.getTokenIndex()+","+this.start+":"+this.stop+"='"+txt+"',<"+this.type+">"+channelStr+","+this.line+":"+this.getCharPositionInLine()+"]";
}
};
// NB: Because Token has static members of type CommonToken, the Token dummy
// constructor is defined in CommonToken.  All methods and vars of Token are
// defined here.  Token is an interface, not a subclass in the Java runtime.
/**
* @class Abstract base class of all token types.
* @name Token
* @memberOf org.antlr.runtime
*/
org.antlr.runtime.Token = function() {};
org.antlr.lang.augmentObject(org.antlr.runtime.Token, /** @lends Token */ {
EOR_TOKEN_TYPE: 1,
/** imaginary tree navigation type; traverse "get child" link */
DOWN: 2,
/** imaginary tree navigation type; finish with a child list */
UP: 3,
MIN_TOKEN_TYPE: 4, // UP+1,
EOF: org.antlr.runtime.CharStream.EOF,
EOF_TOKEN: new org.antlr.runtime.CommonToken(org.antlr.runtime.CharStream.EOF),
INVALID_TOKEN_TYPE: 0,
INVALID_TOKEN: new org.antlr.runtime.CommonToken(0),
/** In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
*  will avoid creating a token for this symbol and try to fetch another.
*/
SKIP_TOKEN: new org.antlr.runtime.CommonToken(0),
/** All tokens go to the parser (unless skip() is called in that rule)
*  on a particular "channel".  The parser tunes to a particular channel
*  so that whitespace etc... can go to the parser on a "hidden" channel.
*/
DEFAULT_CHANNEL: 0,
/** Anything on different channel than DEFAULT_CHANNEL is not parsed
*  by parser.
*/
HIDDEN_CHANNEL: 99
});
org.antlr.lang.augmentObject(org.antlr.runtime.CommonToken, org.antlr.runtime.Token);
org.antlr.runtime.tree.RewriteCardinalityException = function(elementDescription) {
this.elementDescription = elementDescription;
};
/** Base class for all exceptions thrown during AST rewrite construction.
*  This signifies a case where the cardinality of two or more elements
*  in a subrule are different: (ID INT)+ where |ID|!=|INT|
*/
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteCardinalityException, Error, {
getMessage: function() {
if ( org.antlr.lang.isString(this.elementDescription) ) {
return this.elementDescription;
}
return null;
},
name: function() {
return "org.antlr.runtime.tree.RewriteCardinalityException";
}
});
/** Ref to ID or expr but no tokens in ID stream or subtrees in expr stream */
org.antlr.runtime.tree.RewriteEmptyStreamException = function(elementDescription) {
var sup = org.antlr.runtime.tree.RewriteEmptyStreamException.superclass; 
sup.constructor.call(this, elementDescription);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEmptyStreamException,
org.antlr.runtime.tree.RewriteCardinalityException, {
name: function() {
return "org.antlr.runtime.tree.RewriteEmptyStreamException";
}
});
/** No elements within a (...)+ in a rewrite rule */
org.antlr.runtime.tree.RewriteEarlyExitException = function(elementDescription) {
var sup = org.antlr.runtime.tree.RewriteEarlyExitException.superclass;
if (org.antlr.lang.isUndefined(elementDescription)) {
elementDescription = null;
}
sup.constructor.call(this, elementDescription);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEarlyExitException,
org.antlr.runtime.tree.RewriteCardinalityException, {
name: function() {
return "org.antlr.runtime.tree.RewriteEarlyExitException";
}    
});
org.antlr.runtime.MismatchedTreeNodeException = function(expecting, input) {
if (expecting && input) {
org.antlr.runtime.MismatchedTreeNodeException.superclass.constructor.call(
this, input);
this.expecting = expecting;
}
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedTreeNodeException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedTreeNodeException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedTreeNodeException"
});
/** A generic tree implementation with no payload.  You must subclass to
*  actually have any user data.  ANTLR v3 uses a list of children approach
*  instead of the child-sibling approach in v2.  A flat tree (a list) is
*  an empty node whose children represent the list.  An empty, but
*  non-null node is called "nil".
*/
org.antlr.runtime.tree.BaseTree = function() {};
org.antlr.runtime.tree.BaseTree.prototype = {
getChild: function(i) {
if ( !this.children || i>=this.children.length ) {
return null;
}
return this.children[i];
},
/** Get the children internal List; note that if you directly mess with
*  the list, do so at your own risk.
*/
getChildren: function() {
return this.children;
},
getFirstChildWithType: function(type) {
var i, t;
for (i = 0; this.children && i < this.children.length; i++) {
t = this.children[i];
if ( t.getType()===type ) {
return t;
}
}    
return null;
},
getChildCount: function() {
if ( !this.children ) {
return 0;
}
return this.children.length;
},
/** Add t as child of this node.
*
*  Warning: if t has no children, but child does
*  and child isNil then this routine moves children to t via
*  t.children = child.children; i.e., without copying the array.
*/
addChild: function(t) {
if ( !org.antlr.lang.isValue(t) ) {
return; // do nothing upon addChild(null)
}
var childTree = t, n, i, c;
if ( childTree.isNil() ) { // t is an empty node possibly with children
if ( this.children && this.children == childTree.children ) {
throw new Error("attempt to add child list to itself");
}
// just add all of childTree's children to this
if ( childTree.children ) {
if ( this.children ) { // must copy, this has children already
n = childTree.children.length;
for (i = 0; i < n; i++) {
c = childTree.children[i];
this.children.push(c);
// handle double-link stuff for each child of nil root
c.setParent(this);
c.setChildIndex(this.children.length-1);
}
}
else {
// no children for this but t has children; just set pointer
// call general freshener routine
this.children = childTree.children;
this.freshenParentAndChildIndexes();
}
}
}
else { // child is not nil (don't care about children)
if ( !this.children ) {
this.children = this.createChildrenList(); // create children list on demand
}
this.children.push(t);
childTree.setParent(this);
childTree.setChildIndex(this.children.length-1);
}
},
/** Add all elements of kids list as children of this node */
addChildren: function(kids) {
var i, t;
for (i = 0; i < kids.length; i++) {
t = kids[i];
this.addChild(t);
}
},
setChild: function(i, t) {
if ( !t ) {
return;
}
if ( t.isNil() ) {
throw new Error("Can't set single child to a list");
}
if ( !this.children ) {
this.children = this.createChildrenList();
}
this.children[i] = t;
t.setParent(this);
t.setChildIndex(i);
},
deleteChild: function(i) {
if ( !this.children ) {
return null;
}
if (i<0 || i>=this.children.length) {
throw new Error("Index out of bounds.");
}
var killed = this.children.splice(i, 1)[0];
// walk rest and decrement their child indexes
this.freshenParentAndChildIndexes(i);
return killed;
},
/** Delete children from start to stop and replace with t even if t is
*  a list (nil-root tree).  num of children can increase or decrease.
*  For huge child lists, inserting children can force walking rest of
*  children to set their childindex; could be slow.
*/
replaceChildren: function(startChildIndex, stopChildIndex, t) {
if ( !this.children ) {
throw new Error("indexes invalid; no children in list");
}
var replacingHowMany = stopChildIndex - startChildIndex + 1;
var replacingWithHowMany;
var newTree = t;
var newChildren = null;
// normalize to a list of children to add: newChildren
if ( newTree.isNil() ) {
newChildren = newTree.children;
}
else {
newChildren = [];
newChildren.push(newTree);
}
replacingWithHowMany = newChildren.length;
var numNewChildren = newChildren.length;
var delta = replacingHowMany - replacingWithHowMany;
var j, i, child, indexToDelete, c, killed, numToInsert;
// if same number of nodes, do direct replace
if ( delta === 0 ) {
j = 0; // index into new children
for (i=startChildIndex; i<=stopChildIndex; i++) {
child = newChildren[j];
this.children[i] = child;
child.setParent(this);
child.setChildIndex(i);
j++;
}
}
else if ( delta > 0 ) { // fewer new nodes than there were
// set children and then delete extra
for (j=0; j<numNewChildren; j++) {
this.children[startChildIndex+j] = newChildren[j];
}
indexToDelete = startChildIndex+numNewChildren;
for (c=indexToDelete; c<=stopChildIndex; c++) {
// delete same index, shifting everybody down each time
killed = this.children.splice(indexToDelete, 1)[0];
}
this.freshenParentAndChildIndexes(startChildIndex);
}
else { // more new nodes than were there before
// fill in as many children as we can (replacingHowMany) w/o moving data
for (j=0; j<replacingHowMany; j++) {
this.children[startChildIndex+j] = newChildren[j];
}
numToInsert = replacingWithHowMany-replacingHowMany;
for (j=replacingHowMany; j<replacingWithHowMany; j++) {
this.children.splice(startChildIndex+j, 0, newChildren[j]);
}
this.freshenParentAndChildIndexes(startChildIndex);
}
},
/** Override in a subclass to change the impl of children list */
createChildrenList: function() {
return [];
},
isNil: function() {
return false;
},
freshenParentAndChildIndexes: function(offset) {
if (!org.antlr.lang.isNumber(offset)) {
offset = 0;
}
var n = this.getChildCount(),
c,
child;
for (c = offset; c < n; c++) {
child = this.getChild(c);
child.setChildIndex(c);
child.setParent(this);
}
},
sanityCheckParentAndChildIndexes: function(parent, i) {
if (arguments.length===0) {
parent = null;
i = -1;
}
if ( parent!==this.getParent() ) {
throw new Error("parents don't match; expected "+parent+" found "+this.getParent());
}
if ( i!==this.getChildIndex() ) {
throw new Error("child indexes don't match; expected "+i+" found "+this.getChildIndex());
}
var n = this.getChildCount(),
c,
child;
for (c = 0; c < n; c++) {
child = this.getChild(c);
child.sanityCheckParentAndChildIndexes(this, c);
}
},
/** BaseTree doesn't track child indexes. */
getChildIndex: function() {
return 0;
},
setChildIndex: function(index) {
},
/** BaseTree doesn't track parent pointers. */
getParent: function() {
return null;
},
setParent: function(t) {
},
getTree: function() {
return this;
},
/** Print out a whole tree not just a node */
toStringTree: function() {
if ( !this.children || this.children.length===0 ) {
return this.toString();
}
var buf = "",
i,
t;
if ( !this.isNil() ) {
buf += "(";
buf += this.toString();
buf += ' ';
}
for (i = 0; this.children && i < this.children.length; i++) {
t = this.children[i];
if ( i>0 ) {
buf += ' ';
}
buf += t.toStringTree();
}
if ( !this.isNil() ) {
buf += ")";
}
return buf;
},
getLine: function() {
return 0;
},
getCharPositionInLine: function() {
return 0;
}
};
/** A tree node that is wrapper for a Token object.  After 3.0 release
*  while building tree rewrite stuff, it became clear that computing
*  parent and child index is very difficult and cumbersome.  Better to
*  spend the space in every tree node.  If you don't want these extra
*  fields, it's easy to cut them out in your own BaseTree subclass.
*/
org.antlr.runtime.tree.CommonTree = function(node) {
/** What token indexes bracket all tokens associated with this node
*  and below?
*/
this.startIndex = -1;
this.stopIndex = -1;
/** What index is this node in the child list? Range: 0..n-1 */
this.childIndex = -1;
/** Who is the parent node of this node; if null, implies node is root */
this.parent = null;
/** A single token is the payload */
this.token = null;
if (node instanceof org.antlr.runtime.tree.CommonTree) {
org.antlr.runtime.tree.CommonTree.superclass.constructor.call(this, node);
this.token = node.token;
this.startIndex = node.startIndex;
this.stopIndex = node.stopIndex;
} else if (node instanceof org.antlr.runtime.CommonToken) {
this.token = node;
}
};
/** A tree node that is wrapper for a Token object. */
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTree, org.antlr.runtime.tree.BaseTree, {
getToken: function() {
return this.token;
},
dupNode: function() {
return new org.antlr.runtime.tree.CommonTree(this);
},
isNil: function() {
return !this.token;
},
getType: function() {
if ( !this.token ) {
return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
}
return this.token.getType();
},
getText: function() {
if ( !this.token ) {
return null;
}
return this.token.getText();
},
getLine: function() {
if ( !this.token || this.token.getLine()===0 ) {
if ( this.getChildCount()>0 ) {
return this.getChild(0).getLine();
}
return 0;
}
return this.token.getLine();
},
getCharPositionInLine: function() {
if ( !this.token || this.token.getCharPositionInLine()===-1 ) {
if ( this.getChildCount()>0 ) {
return this.getChild(0).getCharPositionInLine();
}
return 0;
}
return this.token.getCharPositionInLine();
},
getTokenStartIndex: function() {
if ( this.token ) {
return this.token.getTokenIndex();
}
return this.startIndex;
},
setTokenStartIndex: function(index) {
this.startIndex = index;
},
getTokenStopIndex: function() {
if ( this.token ) {
return this.token.getTokenIndex();
}
return this.stopIndex;
},
setTokenStopIndex: function(index) {
this.stopIndex = index;
},
getChildIndex: function() {
return this.childIndex;
},
getParent: function() {
return this.parent;
},
setParent: function(t) {
this.parent = t;
},
setChildIndex: function(index) {
this.childIndex = index;
},
toString: function() {
if ( this.isNil() ) {
return "nil";
}
if ( this.getType()===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
return "<errornode>";
}
if ( !this.token ) {
return null;
}
return this.token.getText();
}
});
/** What does a tree look like?  ANTLR has a number of support classes
*  such as CommonTreeNodeStream that work on these kinds of trees.  You
*  don't have to make your trees implement this interface, but if you do,
*  you'll be able to use more support code.
*
*  NOTE: When constructing trees, ANTLR can build any kind of tree; it can
*  even use Token objects as trees if you add a child list to your tokens.
*
*  This is a tree node without any payload; just navigation and factory stuff.
*/
org.antlr.runtime.tree.Tree = {
INVALID_NODE: new org.antlr.runtime.tree.CommonTree(org.antlr.runtime.Token.INVALID_TOKEN)
};
org.antlr.runtime.tree.CommonErrorNode = function(input, start, stop, e) {
if ( !stop ||
(stop.getTokenIndex() < start.getTokenIndex() &&
stop.getType()!=org.antlr.runtime.Token.EOF) )
{
// sometimes resync does not consume a token (when LT(1) is
// in follow set.  So, stop will be 1 to left to start. adjust.
// Also handle case where start is the first token and no token
// is consumed during recovery; LT(-1) will return null.
stop = start;
}
this.input = input;
this.start = start;
this.stop = stop;
this.trappedException = e;
};
org.antlr.lang.extend(org.antlr.runtime.tree.CommonErrorNode, org.antlr.runtime.tree.CommonTree, {
isNil: function() {
return false;
},
getType: function() {
return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
},
getText: function() {
var badText = null;
if ( this.start instanceof org.antlr.runtime.CommonToken ) {
var i = this.start.getTokenIndex();
var j = this.stop.getTokenIndex();
if ( this.stop.getType() === org.antlr.runtime.Token.EOF ) {
j = this.input.size();
}
badText = this.input.toString(i, j);
}
else if ( this.start instanceof org.antlr.runtime.tree.CommonTree ) {
badText = this.input.toString(this.start, this.stop);
}
else {
// people should subclass if they alter the tree type so this
// next one is for sure correct.
badText = "<unknown>";
}
return badText;
},
toString: function() {
if ( this.trappedException instanceof org.antlr.runtime.MissingTokenException ) {
return "<missing type: "+
this.trappedException.getMissingType()+
">";
}
else if ( this.trappedException instanceof org.antlr.runtime.UnwantedTokenException ) {
return "<extraneous: "+
this.trappedException.getUnexpectedToken()+
", resync="+this.getText()+">";
}
else if ( this.trappedException instanceof org.antlr.runtime.MismatchedTokenException ) {
return "<mismatched token: "+this.trappedException.token+", resync="+this.getText()+">";
}
else if ( this.trappedException instanceof org.antlr.runtime.NoViableAltException ) {
return "<unexpected: "+this.trappedException.token+
", resync="+this.getText()+">";
}
return "<error: "+this.getText()+">";
}
});
/** A TreeAdaptor that works with any Tree implementation. */
org.antlr.runtime.tree.BaseTreeAdaptor = function() {
this.uniqueNodeID = 1;
};
org.antlr.runtime.tree.BaseTreeAdaptor.prototype = {
nil: function() {
return this.create(null);
},
/** create tree node that holds the start and stop tokens associated
*  with an error.
*
*  If you specify your own kind of tree nodes, you will likely have to
*  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
*  if no token payload but you might have to set token type for diff
*  node type.
*/
errorNode: function(input, start, stop, e) {
var t = new org.antlr.runtime.tree.CommonErrorNode(input, start, stop, e);
return t;
},
isNil: function(tree) {
return tree.isNil();
},
/** This is generic in the sense that it will work with any kind of
*  tree (not just Tree interface).  It invokes the adaptor routines
*  not the tree node routines to do the construction.  
*/
dupTree: function(t, parent) {
if (arguments.length===1) {
parent = null;
}
if ( !t ) {
return null;
}
var newTree = this.dupNode(t);
// ensure new subtree root has parent/child index set
this.setChildIndex(newTree, this.getChildIndex(t)); // same index in new tree
this.setParent(newTree, parent);
var n = this.getChildCount(t),
i, child, newSubTree;
for (i = 0; i < n; i++) {
child = this.getChild(t, i);
newSubTree = this.dupTree(child, t);
this.addChild(newTree, newSubTree);
}
return newTree;
},
/** Add a child to the tree t.  If child is a flat tree (a list), make all
*  in list children of t.  Warning: if t has no children, but child does
*  and child isNil then you can decide it is ok to move children to t via
*  t.children = child.children; i.e., without copying the array.  Just
*  make sure that this is consistent with have the user will build
*  ASTs.
*/
addChild: function(t, child) {
if ( t && org.antlr.lang.isValue(child) ) {
t.addChild(child);
}
},
/** If oldRoot is a nil root, just copy or move the children to newRoot.
*  If not a nil root, make oldRoot a child of newRoot.
*
*    old=^(nil a b c), new=r yields ^(r a b c)
*    old=^(a b c), new=r yields ^(r ^(a b c))
*
*  If newRoot is a nil-rooted single child tree, use the single
*  child as the new root node.
*
*    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
*    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
*
*  If oldRoot was null, it's ok, just return newRoot (even if isNil).
*
*    old=null, new=r yields r
*    old=null, new=^(nil r) yields ^(nil r)
*
*  Return newRoot.  Throw an exception if newRoot is not a
*  simple node or nil root with a single child node--it must be a root
*  node.  If newRoot is ^(nil x) return x as newRoot.
*
*  Be advised that it's ok for newRoot to point at oldRoot's
*  children; i.e., you don't have to copy the list.  We are
*  constructing these nodes so we should have this control for
*  efficiency.
*/
becomeRoot: function(newRoot, oldRoot) {
if (newRoot instanceof org.antlr.runtime.CommonToken || !newRoot) {
newRoot = this.create(newRoot);
}
var newRootTree = newRoot,
oldRootTree = oldRoot;
if ( !oldRoot ) {
return newRoot;
}
// handle ^(nil real-node)
if ( newRootTree.isNil() ) {
if ( newRootTree.getChildCount()>1 ) {
// TODO: make tree run time exceptions hierarchy
throw new Error("more than one node as root (TODO: make exception hierarchy)");
}
newRootTree = newRootTree.getChild(0);
}
// add oldRoot to newRoot; addChild takes care of case where oldRoot
// is a flat list (i.e., nil-rooted tree).  All children of oldRoot
// are added to newRoot.
newRootTree.addChild(oldRootTree);
return newRootTree;
},
/** Transform ^(nil x) to x */
rulePostProcessing: function(root) {
var r = root;
if ( r && r.isNil() ) {
if ( r.getChildCount()===0 ) {
r = null;
}
else if ( r.getChildCount()===1 ) {
r = r.getChild(0);
// whoever invokes rule will set parent and child index
r.setParent(null);
r.setChildIndex(-1);
}
}
return r;
},
create: function(tokenType, fromToken) {
var text, t;
if (arguments.length===2) {
if (org.antlr.lang.isString(arguments[1])) {
text = arguments[1];
fromToken = this.createToken(tokenType, text);
t = this.create(fromToken);
return t;
} else {
fromToken = this.createToken(fromToken);
fromToken.setType(tokenType);
t = this.create(fromToken);
return t;
}
} else if (arguments.length===3) {
text = arguments[2];
fromToken = this.createToken(fromToken);
fromToken.setType(tokenType);
fromToken.setText(text);
t = this.create(fromToken);
return t;
}
},
getType: function(t) {
t.getType();
return 0;
},
setType: function(t, type) {
throw new Error("don't know enough about Tree node");
},
getText: function(t) {
return t.getText();
},
setText: function(t, text) {
throw new Error("don't know enough about Tree node");
},
getChild: function(t, i) {
return t.getChild(i);
},
setChild: function(t, i, child) {
t.setChild(i, child);
},
deleteChild: function(t, i) {
return t.deleteChild(i);
},
getChildCount: function(t) {
return t.getChildCount();
},
getUniqueID: function(node) {
if ( !this.treeToUniqueIDMap ) {
this.treeToUniqueIDMap = {};
}
var prevID = this.treeToUniqueIDMap[node];
if ( org.antlr.lang.isValue(prevID) ) {
return prevID;
}
var ID = this.uniqueNodeID;
this.treeToUniqueIDMap[node] = ID;
this.uniqueNodeID++;
return ID;
// GC makes these nonunique:
// return System.identityHashCode(node);
}
};
/** A TreeAdaptor that works with any Tree implementation.  It provides
*  really just factory methods; all the work is done by BaseTreeAdaptor.
*  If you would like to have different tokens created than ClassicToken
*  objects, you need to override this and then set the parser tree adaptor to
*  use your subclass.
*
*  To get your parser to build nodes of a different type, override
*  create(Token).
*/
org.antlr.runtime.tree.CommonTreeAdaptor = function() {};
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeAdaptor,
org.antlr.runtime.tree.BaseTreeAdaptor, {
/** Duplicate a node.  This is part of the factory;
*    override if you want another kind of node to be built.
*
*  I could use reflection to prevent having to override this
*  but reflection is slow.
*/
dupNode: function(t) {
if ( !org.antlr.lang.isValue(t) ) {
return null;
}
return t.dupNode();
},
create: function(payload) {
if (arguments.length>1) {
return org.antlr.runtime.tree.CommonTreeAdaptor.superclass.create.apply(this, arguments);
}
return new org.antlr.runtime.tree.CommonTree(payload);
},
/** Tell me how to create a token for use with imaginary token nodes.
*  For example, there is probably no input symbol associated with imaginary
*  token DECL, but you need to create it as a payload or whatever for
*  the DECL node as in ^(DECL type ID).
*
*  If you care what the token payload objects' type is, you should
*  override this method and any other createToken variant.
*
* Tell me how to create a token for use with imaginary token nodes.
*  For example, there is probably no input symbol associated with imaginary
*  token DECL, but you need to create it as a payload or whatever for
*  the DECL node as in ^(DECL type ID).
*
*  This is a variant of createToken where the new token is derived from
*  an actual real input token.  Typically this is for converting '{'
*  tokens to BLOCK etc...  You'll see
*
*    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
*
*  If you care what the token payload objects' type is, you should
*  override this method and any other createToken variant.
*/
createToken: function(fromToken) {
if (arguments.length===2) {
return new org.antlr.runtime.CommonToken(arguments[0], arguments[1]);
} else {
return new org.antlr.runtime.CommonToken(arguments[0]);
}
},
/** Track start/stop token for subtree root created for a rule.
*  Only works with Tree nodes.  For rules that match nothing,
*  seems like this will yield start=i and stop=i-1 in a nil node.
*  Might be useful info so I'll not force to be i..i.
*/
setTokenBoundaries: function(t, startToken, stopToken) {
if ( !org.antlr.lang.isValue(t) ) {
return;
}
var start = 0,
stop = 0;
if ( org.antlr.lang.isValue(startToken) ) {
if (startToken.getTokenIndex) {
start = startToken.getTokenIndex();
} else if (startToken.getStartIndex) {
start = startToken.getStartIndex();
} else {
start = startToken.getTokenStartIndex();
}
}
if ( org.antlr.lang.isValue(stopToken) ) {
if (stop.getTokenIndex) {
stop = stopToken.getTokenIndex();
} else if (stopToken.getStopIndex) {
stop = stopToken.getStopIndex();
} else {
stop = stopToken.getTokenStopIndex();
}
}
t.setTokenStartIndex(start);
t.setTokenStopIndex(stop);
},
getTokenStartIndex: function(t) {
if (!t) {
return -1;
}
return t.getTokenStartIndex();
},
getTokenStopIndex: function(t) {
if (!t) {
return -1;
}
return t.getTokenStopIndex();
},
getText: function(t) {
if (!t) {
return null;
}
return t.getText();
},
getType: function(t) {
if (!t) {
return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
}
return t.getType();
},
/** What is the Token associated with this node?  If
*  you are not using CommonTree, then you must
*  override this in your own adaptor.
*/
getToken: function(t) {
if ( t instanceof org.antlr.runtime.tree.CommonTree ) {
return t.getToken();
}
return null; // no idea what to do
},
getChild: function(t, i) {
if (!t) {
return null;
}
return t.getChild(i);
},
getChildCount: function(t) {
if (!t) {
return 0;
}
return t.getChildCount();
},
getParent: function(t) {
return t.getParent();
},
setParent: function(t, parent) {
t.setParent(parent);
},
getChildIndex: function(t) {
return t.getChildIndex();
},
setChildIndex: function(t, index) {
t.setChildIndex(index);
},
replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
if ( parent ) {
parent.replaceChildren(startChildIndex, stopChildIndex, t);
}
}
});
/**
* A stream of characters created from a JavaScript string that in turn gets
* fed to a lexer.
* @class
* @param {String} data the string from which this stream will be created.
*/
org.antlr.runtime.ANTLRStringStream = function(data) {
/**
* Location in the stream.
* Ranges from 0 to (stream length - 1).
* @private
* @type Number
*/
this.p = 0;
/**
* The current line in the input.
* Ranges from 1 to (number of lines).
* @private
* @type Number
*/
this.line = 1;
/**
* The index of the character relative to the beginning of the line.
* Ranges from 0 to (length of line - 1).
* @private
* @type Number
*/
this.charPositionInLine = 0;
/**
* Tracks how deep mark() calls are nested
* @private
* @type Number
*/
this.markDepth = 0;
/**
* An Array of objects that tracks the stream state
* values line, charPositionInLine, and p that can change as you
* move through the input stream.  Indexed from 1..markDepth.
* A null is kept at index 0.  Created upon first call to mark().
* @private
* @type Array
*/
this.markers = null;
/**
* Track the last mark() call result value for use in rewind().
* @private
* @type Number
*/
this.lastMarker = null;
/**
* The data being scanned.
* @private
* @type String
*/
this.data = data;
/**
* The number of characters in the stream.
* @private
* @type Number
*/
this.n = data.length;
};
org.antlr.runtime.ANTLRStringStream.prototype = {
/**
* Reset the stream so that it's in the same state it was
* when the object was created *except* the data array is not
* touched.
*/
reset: function() {
this.p = 0;
this.line = 1;
this.charPositionInLine = 0;
this.markDepth = 0;
},
/**
* Consume the next character of data in the stream.
*/
consume: function() {
if ( this.p < this.n ) {
this.charPositionInLine++;
if ( this.data.charAt(this.p)==="\n" ) {
this.line++;
this.charPositionInLine=0;
}
this.p++;
}
},
/**
* Get character at current input pointer + i ahead where i=1 is next int.
* Negative indexes are allowed.  LA(-1) is previous token (token
* just matched).  LA(-i) where i is before first token should
* yield -1, invalid char / EOF.
* @param {Number} i non-zero amount of lookahead or lookback
* @returns {String|Number} The charcter at the specified position or -1 if
*      you fell off either end of the stream.
*/
LA: function(i) {
if ( i<0 ) {
i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
}
var new_pos = this.p+i-1;
if (new_pos>=this.n || new_pos<0) {
return org.antlr.runtime.CharStream.EOF;
}
return this.data.charAt(new_pos);
},
/**
* Return the current input symbol index 0..n where n indicates the
* last symbol has been read.  The index is the index of char to
* be returned from LA(1) (i.e. the one about to be consumed).
* @returns {Number} the index of the current input symbol
*/
index: function() {
return this.p;
},
/**
* The length of this stream.
* @returns {Number} the length of this stream.
*/
size: function() {
return this.n;
},
/**
* Tell the stream to start buffering if it hasn't already.  Return
* current input position, index(), or some other marker so that
* when passed to rewind() you get back to the same spot.
* rewind(mark()) should not affect the input cursor.  The Lexer
* tracks line/col info as well as input index so its markers are
* not pure input indexes.  Same for tree node streams.
*
* <p>Marking is a mechanism for storing the current position of a stream
* in a stack.  This corresponds with the predictive look-ahead mechanism
* used in Lexers.</p>
* @returns {Number} the current size of the mark stack.
*/
mark: function() {
if ( !this.markers ) {
this.markers = [];
this.markers.push(null); // depth 0 means no backtracking, leave blank
}
this.markDepth++;
var state = null;
if ( this.markDepth>=this.markers.length ) {
state = {};
this.markers.push(state);
}
else {
state = this.markers[this.markDepth];
}
state.p = this.p;
state.line = this.line;
state.charPositionInLine = this.charPositionInLine;
this.lastMarker = this.markDepth;
return this.markDepth;
},
/**
* Rewind to the input position of the last marker.
* Used currently only after a cyclic DFA and just
* before starting a sem/syn predicate to get the
* input position back to the start of the decision.
* Do not "pop" the marker off the state.  mark(i)
* and rewind(i) should balance still. It is
* like invoking rewind(last marker) but it should not "pop"
* the marker off.  It's like seek(last marker's input position).
* @param {Number} [m] the index in the mark stack to load instead of the
*      last.
*/
rewind: function(m) {
if (!org.antlr.lang.isNumber(m)) {
m = this.lastMarker;
}
var state = this.markers[m];
// restore stream state
this.seek(state.p);
this.line = state.line;
this.charPositionInLine = state.charPositionInLine;
this.release(m);
},
/**
* You may want to commit to a backtrack but don't want to force the
* stream to keep bookkeeping objects around for a marker that is
* no longer necessary.  This will have the same behavior as
* rewind() except it releases resources without the backward seek.
* This must throw away resources for all markers back to the marker
* argument.  So if you're nested 5 levels of mark(), and then release(2)
* you have to release resources for depths 2..5.
* @param {Number} marker the mark depth above which all mark states will
*      be released.
*/
release: function(marker) {
// unwind any other markers made after m and release m
this.markDepth = marker;
// release this marker
this.markDepth--;
},
/**
* Set the input cursor to the position indicated by index.  This is
* normally used to seek ahead in the input stream.  No buffering is
* required to do this unless you know your stream will use seek to
* move backwards such as when backtracking.
*
* <p>This is different from rewind in its multi-directional
* requirement and in that its argument is strictly an input cursor
* (index).</p>
*
* <p>For char streams, seeking forward must update the stream state such
* as line number.  For seeking backwards, you will be presumably
* backtracking using the mark/rewind mechanism that restores state and
* so this method does not need to update state when seeking backwards.</p>
*
* <p>Currently, this method is only used for efficient backtracking using
* memoization, but in the future it may be used for incremental
* parsing.</p>
*
* <p>The index is 0..n-1.  A seek to position i means that LA(1) will
* return the ith symbol.  So, seeking to 0 means LA(1) will return the
* first element in the stream.</p>
*
* <p>Esentially this method method moves the input position,
* {@link #consume}-ing data if necessary.</p>
*
* @param {Number} index the position to seek to.
*/
seek: function(index) {
if ( index<=this.p ) {
this.p = index; // just jump; don't update stream state (line, ...)
return;
}
// seek forward, consume until p hits index
while ( this.p<index ) {
this.consume();
}
},
/**
* Retrieve a substring from this stream.
* @param {Number} start the starting index of the substring (inclusive).
* @param {Number} stop the last index of the substring (inclusive).
* @returns {String}
*/
substring: function(start, stop) {
return this.data.substr(start,stop-start+1);
},
/**
* Return the current line position in the stream.
* @returns {Number} the current line position in the stream (1..numlines).
*/
getLine: function() {
return this.line;
},
/**
* Get the index of the character relative to the beginning of the line.
* Ranges from 0 to (length of line - 1).
* @returns {Number}
*/
getCharPositionInLine: function() {
return this.charPositionInLine;
},
/**
* Set the current line in the input stream.
* This is used internally when performing rewinds.
* @param {Number} line
* @private
*/
setLine: function(line) {
this.line = line;
},
/**
* Set the index of the character relative to the beginning of the line.
* Ranges from 0 to (length of line - 1).
* @param {Number} pos
* @private
*/
setCharPositionInLine: function(pos) {
this.charPositionInLine = pos;
},
/** Where are you getting symbols from? Normally, implementations will
*  pass the buck all the way to the lexer who can ask its input stream
*  for the file name or whatever.
*/
getSourceName: function() {
return null;
}
};
/**
* Alias for {@link #LA}.
* @methodOf org.antlr.runtime.ANTLRStringStream.prototype
* @name LT
*/
org.antlr.runtime.ANTLRStringStream.LT = org.antlr.runtime.ANTLRStringStream.LA;
/** The most common stream of tokens is one where every token is buffered up
*  and tokens are prefiltered for a certain channel (the parser will only
*  see these tokens and cannot change the filter channel number during the
*  parse).
*
*  TODO: how to access the full token stream?  How to track all tokens matched per rule?
*/
org.antlr.runtime.CommonTokenStream = function(tokenSource, channel) {
this.p = -1;
this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
this.v_discardOffChannelTokens = false;
this.tokens = [];
if (arguments.length >= 2) {
this.channel = channel;
} else if (arguments.length === 1) {
this.tokenSource = tokenSource;
}
};
org.antlr.runtime.CommonTokenStream.prototype = {
/** Reset this token stream by setting its token source. */
setTokenSource: function(tokenSource) {
this.tokenSource = tokenSource;
this.tokens = [];
this.p = -1;
this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
},
/** Load all tokens from the token source and put in tokens.
*  This is done upon first LT request because you might want to
*  set some token type / channel overrides before filling buffer.
*/
fillBuffer: function() {
var index = 0,
t = this.tokenSource.nextToken(),
discard,
channelI;
while ( org.antlr.lang.isValue(t) && 
t.getType()!=org.antlr.runtime.CharStream.EOF )
{
discard = false;
// is there a channel override for token type?
if ( this.channelOverrideMap ) {
channelI = this.channelOverrideMap[t.getType()];
if ( org.antlr.lang.isValue(channelI) ) {
t.setChannel(channelI);
}
}
if ( this.discardSet && this.discardSet[t.getType()] )
{
discard = true;
}
else if ( this.v_discardOffChannelTokens &&
t.getChannel()!=this.channel )
{
discard = true;
}
if ( !discard )    {
t.setTokenIndex(index);
this.tokens.push(t);
index++;
}
t = this.tokenSource.nextToken();
}
// leave p pointing at first token on channel
this.p = 0;
this.p = this.skipOffTokenChannels(this.p);
},
/** Move the input pointer to the next incoming token.  The stream
*  must become active with LT(1) available.  consume() simply
*  moves the input pointer so that LT(1) points at the next
*  input symbol. Consume at least one token.
*
*  Walk past any token not on the channel the parser is listening to.
*/
consume: function() {
if ( this.p<this.tokens.length ) {
this.p++;
this.p = this.skipOffTokenChannels(this.p); // leave p on valid token
}
},
/** Given a starting index, return the index of the first on-channel
*  token.
*/
skipOffTokenChannels: function(i) {
var n = this.tokens.length;
while ( i<n && (this.tokens[i]).getChannel()!=this.channel ) {
i++;
}
return i;
},
skipOffTokenChannelsReverse: function(i) {
while ( i>=0 && (this.tokens[i]).getChannel()!=this.channel ) {
i--;
}
return i;
},
/** A simple filter mechanism whereby you can tell this token stream
*  to force all tokens of type ttype to be on channel.  For example,
*  when interpreting, we cannot exec actions so we need to tell
*  the stream to force all WS and NEWLINE to be a different, ignored
*  channel.
*/
setTokenTypeChannel: function(ttype, channel) {
if ( !this.channelOverrideMap ) {
this.channelOverrideMap = {};
}
this.channelOverrideMap[ttype] = channel;
},
discardTokenType: function(ttype) {
if ( !this.discardSet ) {
this.discardSet = {};
}
this.discardSet[ttype] = true;
},
discardOffChannelTokens: function(b) {
this.v_discardOffChannelTokens = b;
},
/** Given a start and stop index, return a List of all tokens in
*  the token type BitSet.  Return null if no tokens were found.  This
*  method looks at both on and off channel tokens.
*/
getTokens: function(start, stop, types) {
if ( this.p === -1 ) {
this.fillBuffer();
}
if (arguments.length===0) {
return this.tokens;
}
if (org.antlr.lang.isArray(types)) {
types = new org.antlr.runtime.BitSet(types);
} else if (org.antlr.lang.isNumber(types)) {
types = org.antlr.runtime.BitSet.of(types);
}
if ( stop>=this.tokens.length ) {
stop=this.tokens.length-1;
}
if ( start<0 ) {
start=0;
}
if ( start>stop ) {
return null;
}
// list = tokens[start:stop]:{Token t, t.getType() in types}
var filteredTokens = [],
i,
t;
for (i=start; i<=stop; i++) {
t = this.tokens[i];
if ( !this.types || types.member(t.getType()) ) {
filteredTokens.push(t);
}
}
if ( filteredTokens.length===0 ) {
filteredTokens = null;
}
return filteredTokens;
},
/** Get the ith token from the current position 1..n where k=1 is the
*  first symbol of lookahead.
*/
LT: function(k) {
if ( this.p === -1 ) {
this.fillBuffer();
}
if ( k===0 ) {
return null;
}
if ( k<0 ) {
return this.LB(-1*k);
}
if ( (this.p+k-1) >= this.tokens.length ) {
return org.antlr.runtime.Token.EOF_TOKEN;
}
var i = this.p,
n = 1;
// find k good tokens
while ( n<k ) {
// skip off-channel tokens
i = this.skipOffTokenChannels(i+1); // leave p on valid token
n++;
}
if ( i>=this.tokens.length ) {
return org.antlr.runtime.Token.EOF_TOKEN;
}
return this.tokens[i];
},
/** Look backwards k tokens on-channel tokens */
LB: function(k) {
if ( this.p === -1 ) {
this.fillBuffer();
}
if ( k===0 ) {
return null;
}
if ( (this.p-k)<0 ) {
return null;
}
var i = this.p,
n = 1;
// find k good tokens looking backwards
while ( n<=k ) {
// skip off-channel tokens
i = this.skipOffTokenChannelsReverse(i-1); // leave p on valid token
n++;
}
if ( i<0 ) {
return null;
}
return this.tokens[i];
},
/** Return absolute token i; ignore which channel the tokens are on;
*  that is, count all tokens not just on-channel tokens.
*/
get: function(i) {
return this.tokens[i];
},
LA: function(i) {
return this.LT(i).getType();
},
mark: function() {
if ( this.p === -1 ) {
this.fillBuffer();
}
this.lastMarker = this.index();
return this.lastMarker;
},
release: function(marker) {
// no resources to release
},
size: function() {
return this.tokens.length;
},
index: function() {
return this.p;
},
rewind: function(marker) {
if (!org.antlr.lang.isNumber(marker)) {
marker = this.lastMarker;
}
this.seek(marker);
},
reset: function() {
this.p = -1;
this.lastMarker = 0;
},
seek: function(index) {
this.p = index;
},
getTokenSource: function() {
return this.tokenSource;
},
getSourceName: function() {
return this.getTokenSource().getSourceName();
},
toString: function(start, stop) {
if (arguments.length===0) {
if ( this.p === -1 ) {
this.fillBuffer();
}
start = 0;
stop = this.tokens.length-1;
}
if (!org.antlr.lang.isNumber(start) && !org.antlr.lang.isNumber(stop)) {
if ( org.antlr.lang.isValue(start) && org.antlr.lang.isValue(stop) ) {
start = start.getTokenIndex();
stop = stop.getTokenIndex();
} else {
return null;
}
}
var buf = "",
i;
if ( start<0 || stop<0 ) {
return null;
}
if ( this.p == -1 ) {
this.fillBuffer();
}
if ( stop>=this.tokens.length ) {
stop = this.tokens.length-1;
}
for (i = start; i <= stop; i++) {
t = this.tokens[i];
buf = buf + this.tokens[i].getText();
}
return buf;
}
};
/* Useful for dumping out the input stream after doing some
*  augmentation or other manipulations.
*
*  You can insert stuff, replace, and delete chunks.  Note that the
*  operations are done lazily--only if you convert the buffer to a
*  String.  This is very efficient because you are not moving data around
*  all the time.  As the buffer of tokens is converted to strings, the
*  toString() method(s) check to see if there is an operation at the
*  current index.  If so, the operation is done and then normal String
*  rendering continues on the buffer.  This is like having multiple Turing
*  machine instruction streams (programs) operating on a single input tape. :)
*
*  Since the operations are done lazily at toString-time, operations do not
*  screw up the token index values.  That is, an insert operation at token
*  index i does not change the index values for tokens i+1..n-1.
*
*  Because operations never actually alter the buffer, you may always get
*  the original token stream back without undoing anything.  Since
*  the instructions are queued up, you can easily simulate transactions and
*  roll back any changes if there is an error just by removing instructions.
*  For example,
*
*   CharStream input = new ANTLRFileStream("input");
*   TLexer lex = new TLexer(input);
*   TokenRewriteStream tokens = new TokenRewriteStream(lex);
*   T parser = new T(tokens);
*   parser.startRule();
*
*      Then in the rules, you can execute
*      Token t,u;
*      ...
*      input.insertAfter(t, "text to put after t");}
*         input.insertAfter(u, "text after u");}
*         System.out.println(tokens.toString());
*
*  Actually, you have to cast the 'input' to a TokenRewriteStream. :(
*
*  You can also have multiple "instruction streams" and get multiple
*  rewrites from a single pass over the input.  Just name the instruction
*  streams and use that name again when printing the buffer.  This could be
*  useful for generating a C file and also its header file--all from the
*  same buffer:
*
*      tokens.insertAfter("pass1", t, "text to put after t");}
*         tokens.insertAfter("pass2", u, "text after u");}
*         System.out.println(tokens.toString("pass1"));
*         System.out.println(tokens.toString("pass2"));
*
*  If you don't use named rewrite streams, a "default" stream is used as
*  the first example shows.
*/
org.antlr.runtime.TokenRewriteStream = function() {
var sup = org.antlr.runtime.TokenRewriteStream.superclass;
/** You may have multiple, named streams of rewrite operations.
*  I'm calling these things "programs."
*  Maps String (name) -> rewrite (List)
*/
this.programs = null;
/** Map String (program name) -> Integer index */
this.lastRewriteTokenIndexes = null;
if (arguments.length===0) {
this.init();
} else {
sup.constructor.apply(this, arguments);
this.init();
}
};
(function(){
var trs = org.antlr.runtime.TokenRewriteStream;
org.antlr.lang.augmentObject(trs, {
DEFAULT_PROGRAM_NAME: "default",
PROGRAM_INIT_SIZE: 100,
MIN_TOKEN_INDEX: 0
});
//
// Define the rewrite operation hierarchy
//
trs.RewriteOperation = function(index, text) {
this.index = index;
this.text = text;
};
/** Execute the rewrite operation by possibly adding to the buffer.
*  Return the index of the next token to operate on.
*/
trs.RewriteOperation.prototype = {
execute: function(buf) {
return this.index;
},
toString: function() {
/*String opName = getClass().getName();
int $index = opName.indexOf('$');
opName = opName.substring($index+1, opName.length());
return opName+"@"+index+'"'+text+'"';*/
return this.text;
}
};
trs.InsertBeforeOp = function(index, text) {
trs.InsertBeforeOp.superclass.constructor.call(this, index, text);
};
org.antlr.lang.extend(trs.InsertBeforeOp, trs.RewriteOperation, {
execute: function(buf) {
buf.push(this.text);
return this.index;
}
});
/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
*  instructions.
*/
trs.ReplaceOp = function(from, to, text) {
trs.ReplaceOp.superclass.constructor.call(this, from, text); 
this.lastIndex = to;
};
org.antlr.lang.extend(trs.ReplaceOp, trs.RewriteOperation, {
execute: function(buf) {
if (org.antlr.lang.isValue(this.text)) {
buf.push(this.text);
}
return this.lastIndex+1;
}
});
trs.DeleteOp = function(from, to) {
trs.DeleteOp.superclass.constructor.call(this, from, to); 
};
org.antlr.lang.extend(trs.DeleteOp, trs.ReplaceOp);
org.antlr.lang.extend(trs, org.antlr.runtime.CommonTokenStream, {
init: function() {
this.programs = {};
this.programs[trs.DEFAULT_PROGRAM_NAME] = [];
this.lastRewriteTokenIndexes = {};
},
/** Rollback the instruction stream for a program so that
*  the indicated instruction (via instructionIndex) is no
*  longer in the stream.  UNTESTED!
*/
rollback: function() {
var programName,
instructionIndex;
if (arguments.length===1) {
programName = trs.DEFAULT_PROGRAM_NAME;
instructionIndex = arguments[0];
} else if (arguments.length===2) {
programName = arguments[0];
instructionIndex = arguments[1];
}
var is = this.programs[programName];
if (is) {
programs[programName] = is.slice(trs.MIN_TOKEN_INDEX, this.instructionIndex);
}
},
/** Reset the program so that no instructions exist */
deleteProgram: function(programName) {
programName = programName || trs.DEFAULT_PROGRAM_NAME;
this.rollback(programName, trs.MIN_TOKEN_INDEX);
},
/** Add an instruction to the rewrite instruction list ordered by
*  the instruction number (use a binary search for efficiency).
*  The list is ordered so that toString() can be done efficiently.
*
*  When there are multiple instructions at the same index, the instructions
*  must be ordered to ensure proper behavior.  For example, a delete at
*  index i must kill any replace operation at i.  Insert-before operations
*  must come before any replace / delete instructions.  If there are
*  multiple insert instructions for a single index, they are done in
*  reverse insertion order so that "insert foo" then "insert bar" yields
*  "foobar" in front rather than "barfoo".  This is convenient because
*  I can insert new InsertOp instructions at the index returned by
*  the binary search.  A ReplaceOp kills any previous replace op.  Since
*  delete is the same as replace with null text, i can check for
*  ReplaceOp and cover DeleteOp at same time. :)
*/
addToSortedRewriteList: function() {
var programName,
op;
if (arguments.length===1) {
programName = trs.DEFAULT_PROGRAM_NAME;
op = arguments[0];
} else if (arguments.length===2) {
programName = arguments[0];
op = arguments[1];
}
var rewrites = this.getProgram(programName);
var len, pos, searchOp, replaced, prevOp, i;
for (pos=0, len=rewrites.length; pos<len; pos++) {
searchOp = rewrites[pos];
if (searchOp.index===op.index) {
// now pos is the index in rewrites of first op with op.index
// an instruction operating already on that index was found;
// make this one happen after all the others
if (op instanceof trs.ReplaceOp) {
replaced = false;
// look for an existing replace
for (i=pos; i<rewrites.length; i++) {
prevOp = rewrites[pos];
if (prevOp.index!==op.index) {
break;
}
if (prevOp instanceof trs.ReplaceOp) {
rewrites[pos] = op; // replace old with new
replaced=true;
break;
}
// keep going; must be an insert
}
if ( !replaced ) {
// add replace op to the end of all the inserts
rewrites.splice(i, 0, op);
}
} else {
// inserts are added in front of existing inserts
rewrites.splice(pos, 0, op);
}
break;
} else if (searchOp.index > op.index) {
rewrites.splice(pos, 0, op);
break;
}
}
if (pos===len) {
rewrites.push(op);
}
},
insertAfter: function() {
var index, programName, text;
if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
index = arguments[0];
text = arguments[1];
} else if (arguments.length===3) {
programName = arguments[0];
index = arguments[1];
text = arguments[2];
}
if (index instanceof org.antlr.runtime.CommonToken) {
// index is a Token, grab it's stream index
index = index.index; // that's ugly
}
// insert after is the same as insert before the next index
this.insertBefore(programName, index+1, text);
},
insertBefore: function() {
var index, programName, text;
if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
index = arguments[0];
text = arguments[1];
} else if (arguments.length===3) {
programName = arguments[0];
index = arguments[1];
text = arguments[2];
}
if (index instanceof org.antlr.runtime.CommonToken) {
// index is a Token, grab it's stream index
index = index.index; // that's ugly
}
this.addToSortedRewriteList(
programName,
new trs.InsertBeforeOp(index,text)
);
},
replace: function() {
var programName, first, last, text;
if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
first = arguments[0];
last = arguments[0];
text = arguments[1];
} else if (arguments.length===3) {
programName = trs.DEFAULT_PROGRAM_NAME;
first = arguments[0];
last = arguments[1];
text = arguments[2];
} if (arguments.length===4) {
programName = arguments[0];
first = arguments[1];
last = arguments[2];
text = arguments[3];
} 
if (first instanceof org.antlr.runtime.CommonToken) {
first = first.index;
}
if (last instanceof org.antlr.runtime.CommonToken) {
last = last.index; // that's ugly
}
if ( first > last || last<0 || first<0 ) {
return;
}
this.addToSortedRewriteList(
programName,
new trs.ReplaceOp(first, last, text));
},
// !!! API Break: delete is a JS keyword, so using remove instead.
remove: function() {
// convert arguments to a real array
var args=[], i=arguments.length-1;
while (i>=0) {
args[i] = arguments[i];
i--;
}
args.push("");
this.replace.apply(this, args);
},
getLastRewriteTokenIndex: function(programName) {
programName = programName || trs.DEFAULT_PROGRAM_NAME;
return this.lastRewriteTokenIndexes[programName] || -1;
},
setLastRewriteTokenIndex: function(programName, i) {
this.lastRewriteTokenIndexes[programName] = i;
},
getProgram: function(name) {
var is = this.programs[name];
if ( !is ) {
is = this.initializeProgram(name);
}
return is;
},
initializeProgram: function(name) {
var is = [];
this.programs[name] = is;
return is;
},
toOriginalString: function(start, end) {
if (!org.antlr.lang.isNumber(start)) {
start = trs.MIN_TOKEN_INDEX;
}
if (!org.antlr.lang.isNumber(end)) {
end = this.size()-1;
}
var buf = [], i;
for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
buf.push(this.get(i).getText());
}
return buf.join("");
},
toString: function() {
var programName, start, end;
if (arguments.length===0) {
programName = trs.DEFAULT_PROGRAM_NAME;
start = trs.MIN_TOKEN_INDEX;
end = this.size() - 1;
} else if (arguments.length===1) {
programName = arguments[0];
start = trs.MIN_TOKEN_INDEX;
end = this.size() - 1;
} else if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
start = arguments[0];
end = arguments[1];
}
var rewrites = this.programs[programName];
if ( !rewrites || rewrites.length===0 ) {
return this.toOriginalString(start,end);
}
/// Index of first rewrite we have not done
var rewriteOpIndex = 0,
tokenCursor=start,
buf = [],
op;
while ( tokenCursor>=trs.MIN_TOKEN_INDEX &&
tokenCursor<=end &&
tokenCursor<this.tokens.length )
{
// execute instructions associated with this token index
if ( rewriteOpIndex<rewrites.length ) {
op = rewrites[rewriteOpIndex];
// skip all ops at lower index
while (op.index<tokenCursor && rewriteOpIndex<rewrites.length) {
rewriteOpIndex++;
if ( rewriteOpIndex<rewrites.length ) {
op = rewrites[rewriteOpIndex];
}
}
// while we have ops for this token index, exec them
while (tokenCursor===op.index && rewriteOpIndex<rewrites.length) {
//System.out.println("execute "+op+" at instruction "+rewriteOpIndex);
tokenCursor = op.execute(buf);
//System.out.println("after execute tokenCursor = "+tokenCursor);
rewriteOpIndex++;
if ( rewriteOpIndex<rewrites.length ) {
op = rewrites[rewriteOpIndex];
}
}
}
// dump the token at this index
if ( tokenCursor<=end ) {
buf.push(this.get(tokenCursor).getText());
tokenCursor++;
}
}
// now see if there are operations (append) beyond last token index
var opi;
for (opi=rewriteOpIndex; opi<rewrites.length; opi++) {
op = rewrites[opi];
if ( op.index>=this.size() ) {
op.execute(buf); // must be insertions if after last token
}
}
return buf.join("");
},
toDebugString: function(start, end) {
if (!org.antlr.lang.isNumber(start)) {
start = trs.MIN_TOKEN_INDEX;
}
if (!org.antlr.lang.isNumber(end)) {
end = this.size()-1;
}
var buf = [],
i;
for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
buf.push(this.get(i));
}
return buf.join("");
}
});
})();
/** A stream of tree nodes, accessing nodes from a tree of some kind */
org.antlr.runtime.tree.TreeNodeStream = function() {};
/** A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.
*
*  This node stream sucks all nodes out of the tree specified in
*  the constructor during construction and makes pointers into
*  the tree using an array of Object pointers. The stream necessarily
*  includes pointers to DOWN and UP and EOF nodes.
*
*  This stream knows how to mark/release for backtracking.
*
*  This stream is most suitable for tree interpreters that need to
*  jump around a lot or for tree parsers requiring speed (at cost of memory).
*  There is some duplicated functionality here with UnBufferedTreeNodeStream
*  but just in bookkeeping, not tree walking etc...
*
*  @see UnBufferedTreeNodeStream
*/
org.antlr.runtime.tree.CommonTreeNodeStream = function(adaptor,
tree,
initialBufferSize)
{
if (arguments.length===1) {
tree = adaptor;
adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
}
if (arguments.length <= 2) {
initialBufferSize =
org.antlr.runtime.tree.CommonTreeNodeStream.DEFAULT_INITIAL_BUFFER_SIZE;
}
/** Reuse same DOWN, UP navigation nodes unless this is true */
this.uniqueNavigationNodes = false;
/** The index into the nodes list of the current node (next node
*  to consume).  If -1, nodes array not filled yet.
*/
this.p = -1;
var Token = org.antlr.runtime.Token;
this.root = tree;
this.adaptor = adaptor;
this.nodes = []; //new ArrayList(initialBufferSize);
this.down = this.adaptor.create(Token.DOWN, "DOWN");
this.up = this.adaptor.create(Token.UP, "UP");
this.eof = this.adaptor.create(Token.EOF, "EOF");
};
org.antlr.lang.augmentObject(org.antlr.runtime.tree.CommonTreeNodeStream, {
DEFAULT_INITIAL_BUFFER_SIZE: 100,
INITIAL_CALL_STACK_SIZE: 10
});
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeNodeStream,
org.antlr.runtime.tree.TreeNodeStream, 
{
StreamIterator: function() {
var i = 0,
nodes = this.nodes,
eof = this.eof;
return {
hasNext: function() {
return i<nodes.length;
},
next: function() {
var current = i;
i++;
if ( current < nodes.length ) {
return nodes[current];
}
return eof;
},
remove: function() {
throw new Error("cannot remove nodes from stream");
}
};
},
/** Walk tree with depth-first-search and fill nodes buffer.
*  Don't do DOWN, UP nodes if its a list (t is isNil).
*/
fillBuffer: function(t) {
var reset_p = false;
if (org.antlr.lang.isUndefined(t)) {
t = this.root;
reset_p = true;
}
var nil = this.adaptor.isNil(t);
if ( !nil ) {
this.nodes.push(t); // add this node
}
// add DOWN node if t has children
var n = this.adaptor.getChildCount(t);
if ( !nil && n>0 ) {
this.addNavigationNode(org.antlr.runtime.Token.DOWN);
}
// and now add all its children
var c, child;
for (c=0; c<n; c++) {
child = this.adaptor.getChild(t,c);
this.fillBuffer(child);
}
// add UP node if t has children
if ( !nil && n>0 ) {
this.addNavigationNode(org.antlr.runtime.Token.UP);
}
if (reset_p) {
this.p = 0; // buffer of nodes intialized now
}
},
getNodeIndex: function(node) {
if ( this.p==-1 ) {
this.fillBuffer();
}
var i, t;
for (i=0; i<this.nodes.length; i++) {
t = this.nodes[i];
if ( t===node ) {
return i;
}
}
return -1;
},
/** As we flatten the tree, we use UP, DOWN nodes to represent
*  the tree structure.  When debugging we need unique nodes
*  so instantiate new ones when uniqueNavigationNodes is true.
*/
addNavigationNode: function(ttype) {
var navNode = null;
if ( ttype===org.antlr.runtime.Token.DOWN ) {
if ( this.hasUniqueNavigationNodes() ) {
navNode = this.adaptor.create(org.antlr.runtime.Token.DOWN, "DOWN");
}
else {
navNode = this.down;
}
}
else {
if ( this.hasUniqueNavigationNodes() ) {
navNode = this.adaptor.create(org.antlr.runtime.Token.UP, "UP");
}
else {
navNode = this.up;
}
}
this.nodes.push(navNode);
},
get: function(i) {
if ( this.p===-1 ) {
this.fillBuffer();
}
return this.nodes[i];
},
LT: function(k) {
if ( this.p===-1 ) {
this.fillBuffer();
}
if ( k===0 ) {
return null;
}
if ( k<0 ) {
return this.LB(-1*k);
}
if ( (this.p+k-1) >= this.nodes.length ) {
return this.eof;
}
return this.nodes[this.p+k-1];
},
getCurrentSymbol: function() { return this.LT(1); },
/** Look backwards k nodes */
LB: function(k) {
if ( k===0 ) {
return null;
}
if ( (this.p-k)<0 ) {
return null;
}
return this.nodes[this.p-k];
},
getTreeSource: function() {
return this.root;
},
getSourceName: function() {
return this.getTokenStream().getSourceName();
},
getTokenStream: function() {
return this.tokens;
},
setTokenStream: function(tokens) {
this.tokens = tokens;
},
getTreeAdaptor: function() {
return this.adaptor;
},
setTreeAdaptor: function(adaptor) {
this.adaptor = adaptor;
},
hasUniqueNavigationNodes: function() {
return this.uniqueNavigationNodes;
},
setUniqueNavigationNodes: function(uniqueNavigationNodes) {
this.uniqueNavigationNodes = uniqueNavigationNodes;
},
consume: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
this.p++;
},
LA: function(i) {
return this.adaptor.getType(this.LT(i));
},
mark: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
this.lastMarker = this.index();
return this.lastMarker;
},
release: function(marker) {
// no resources to release
},
index: function() {
return this.p;
},
rewind: function(marker) {
if (!org.antlr.lang.isNumber(marker)) {
marker = this.lastMarker;
}
this.seek(marker);
},
seek: function(index) {
if ( this.p===-1 ) {
this.fillBuffer();
}
this.p = index;
},
/** Make stream jump to a new location, saving old location.
*  Switch back with pop().
*/
push: function(index) {
if ( !this.calls ) {
this.calls = [];
}
this.calls.push(this.p); // save current index
this.seek(index);
},
/** Seek back to previous index saved during last push() call.
*  Return top of stack (return index).
*/
pop: function() {
var ret = this.calls.pop();
this.seek(ret);
return ret;
},
reset: function() {
this.p = -1;
this.lastMarker = 0;
if (this.calls) {
this.calls = [];
}
},
size: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
return this.nodes.length;
},
iterator: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
return this.StreamIterator();
},
replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
if ( parent ) {
this.adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t);
}
},
/** Debugging */
toTokenString: function(start, stop) {
if ( this.p===-1 ) {
this.fillBuffer();
}
var buf='', i, t;
for (i = start; i < this.nodes.length && i <= stop; i++) {
t = this.nodes[i];
buf += " "+this.adaptor.getToken(t);
}
return buf;
},
/** Used for testing, just return the token type stream */
toString: function(start, stop) {
var buf = "",
text,
t,
i;
if (arguments.length===0) {
if ( this.p===-1 ) {
this.fillBuffer();
}
for (i = 0; i < this.nodes.length; i++) {
t = this.nodes[i];
buf += " ";
buf += this.adaptor.getType(t);
}
return buf;
} else {
if ( !org.antlr.lang.isNumber(start) || !org.antlr.lang.isNumber(stop) ) {
return null;
}
if ( this.p===-1 ) {
this.fillBuffer();
}
//System.out.println("stop: "+stop);
if ( start instanceof org.antlr.runtime.tree.CommonTree ) {
//System.out.print("toString: "+((CommonTree)start).getToken()+", ");
} else {
//System.out.println(start);
}
if ( stop instanceof org.antlr.runtime.tree.CommonTree ) {
//System.out.println(((CommonTree)stop).getToken());
} else {
//System.out.println(stop);
}
// if we have the token stream, use that to dump text in order
var beginTokenIndex,
endTokenIndex;
if ( this.tokens ) {
beginTokenIndex = this.adaptor.getTokenStartIndex(start);
endTokenIndex = this.adaptor.getTokenStopIndex(stop);
// if it's a tree, use start/stop index from start node
// else use token range from start/stop nodes
if ( this.adaptor.getType(stop)===org.antlr.runtime.Token.UP ) {
endTokenIndex = this.adaptor.getTokenStopIndex(start);
}
else if ( this.adaptor.getType(stop)==org.antlr.runtime.Token.EOF )
{
endTokenIndex = this.size()-2; // don't use EOF
}
return this.tokens.toString(beginTokenIndex, endTokenIndex);
}
// walk nodes looking for start
t = null;
i = 0;
for (; i < this.nodes.length; i++) {
t = this.nodes[i];
if ( t===start ) {
break;
}
}
// now walk until we see stop, filling string buffer with text
buf = text = "";
t = this.nodes[i];
while ( t!==stop ) {
text = this.adaptor.getText(t);
if ( !org.antlr.lang.isString(text) ) {
text = " "+this.adaptor.getType(t).toString();
}
buf += text;
i++;
t = nodes[i];
}
// include stop node too
text = this.adaptor.getText(stop);
if ( !org.antlr.lang.isString(text) ) {
text = " "+this.adaptor.getType(stop).toString();
}
buf += text;
return buf;
}
}
});
/** A generic list of elements tracked in an alternative to be used in
*  a -> rewrite rule.  We need to subclass to fill in the next() method,
*  which returns either an AST node wrapped around a token payload or
*  an existing subtree.
*
*  Once you start next()ing, do not try to add more elements.  It will
*  break the cursor tracking I believe.
*
*  @see org.antlr.runtime.tree.RewriteRuleSubtreeStream
*  @see org.antlr.runtime.tree.RewriteRuleTokenStream
*
*  TODO: add mechanism to detect/puke on modification after reading from stream
*/
org.antlr.runtime.tree.RewriteRuleElementStream = function(adaptor, elementDescription, el) {
/** Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
*  which bumps it to 1 meaning no more elements.
*/
this.cursor = 0;
/** Once a node / subtree has been used in a stream, it must be dup'd
*  from then on.  Streams are reset after subrules so that the streams
*  can be reused in future subrules.  So, reset must set a dirty bit.
*  If dirty, then next() always returns a dup.
*
*  I wanted to use "naughty bit" here, but couldn't think of a way
*  to use "naughty".
*/
this.dirty = false;
this.elementDescription = elementDescription;
this.adaptor = adaptor;
if (el) {
if (org.antlr.lang.isArray(el)) {
this.singleElement = null;
this.elements = el;
} else {
this.add(el);
}
}
};
org.antlr.runtime.tree.RewriteRuleElementStream.prototype = {
/** Reset the condition of this stream so that it appears we have
*  not consumed any of its elements.  Elements themselves are untouched.
*  Once we reset the stream, any future use will need duplicates.  Set
*  the dirty bit.
*/
reset: function() {
this.cursor = 0;
this.dirty = true;
},
add: function(el) {
if ( !org.antlr.lang.isValue(el) ) {
return;
}
if ( this.elements ) { // if in list, just add
this.elements.push(el);
return;
}
if ( !org.antlr.lang.isValue(this.singleElement) ) { // no elements yet, track w/o list
this.singleElement = el;
return;
}
// adding 2nd element, move to list
this.elements = [];
this.elements.push(this.singleElement);
this.singleElement = null;
this.elements.push(el);
},
/** Return the next element in the stream.  If out of elements, throw
*  an exception unless size()==1.  If size is 1, then return elements[0].
*  Return a duplicate node/subtree if stream is out of elements and
*  size==1.  If we've already used the element, dup (dirty bit set).
*/
nextTree: function() {
var n = this.size(),
el;
if ( this.dirty || (this.cursor>=n && n==1) ) {
// if out of elements and size is 1, dup
el = this._next();
return this.dup(el);
}
// test size above then fetch
el = this._next();
return el;
},
/** do the work of getting the next element, making sure that it's
*  a tree node or subtree.  Deal with the optimization of single-
*  element list versus list of size > 1.  Throw an exception
*  if the stream is empty or we're out of elements and size>1.
*  protected so you can override in a subclass if necessary.
*/
_next: function() {
var n = this.size();
if (n===0) {
throw new org.antlr.runtime.tree.RewriteEmptyStreamException(this.elementDescription);
}
if ( this.cursor>= n) { // out of elements?
if ( n===1 ) {  // if size is 1, it's ok; return and we'll dup
return this.toTree(this.singleElement);
}
// out of elements and size was not 1, so we can't dup
throw new org.antlr.runtime.tree.RewriteCardinalityException(this.elementDescription);
}
// we have elements
if ( org.antlr.lang.isValue(this.singleElement) ) {
this.cursor++; // move cursor even for single element list
return this.toTree(this.singleElement);
}
// must have more than one in list, pull from elements
var o = this.toTree(this.elements[this.cursor]);
this.cursor++;
return o;
},
/** Ensure stream emits trees; tokens must be converted to AST nodes.
*  AST nodes can be passed through unmolested.
*/
toTree: function(el) {
if (el && el.getTree) {
return el.getTree();
}
return el;
},
hasNext: function() {
return (org.antlr.lang.isValue(this.singleElement) && this.cursor < 1) ||
(this.elements && this.cursor < this.elements.length);
},
size: function() {
var n = 0;
if ( org.antlr.lang.isValue(this.singleElement) ) {
n = 1;
}
if ( this.elements ) {
return this.elements.length;
}
return n;
},
getDescription: function() {
return this.elementDescription;
}
};
/** Queues up nodes matched on left side of -> in a tree parser. This is
*  the analog of RewriteRuleTokenStream for normal parsers. 
*/
org.antlr.runtime.tree.RewriteRuleNodeStream = function(adaptor, elementDescription, el) {
org.antlr.runtime.tree.RewriteRuleNodeStream.superclass.constructor.apply(this, arguments);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleNodeStream,
org.antlr.runtime.tree.RewriteRuleElementStream,
{
nextNode: function() {
return this._next();
},
toTree: function(el) {
return this.adaptor.dupNode(el);
},
dup: function() {
// we dup every node, so don't have to worry about calling dup; short-
// circuited next() so it doesn't call.
throw new Error("dup can't be called for a node stream.");
}
});
org.antlr.runtime.tree.RewriteRuleTokenStream = function(adaptor, elementDescription, el) {
var sup = org.antlr.runtime.tree.RewriteRuleTokenStream.superclass;
sup.constructor.apply(this, arguments);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleTokenStream,
org.antlr.runtime.tree.RewriteRuleElementStream, {
/** Get next token from stream and make a node for it */
nextNode: function() {
var t = this._next();
return this.adaptor.create(t);
},
nextToken: function() {
return this._next();
},
/** Don't convert to a tree unless they explicitly call nextTree.
*  This way we can do hetero tree nodes in rewrite.
*/
toTree: function(el) {
return el;
},
dup: function(el) {
throw new Error("dup can't be called for a token stream.");
}
});
org.antlr.runtime.tree.RewriteRuleSubtreeStream = function() {
var sup = org.antlr.runtime.tree.RewriteRuleSubtreeStream.superclass;
sup.constructor.apply(this, arguments);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleSubtreeStream,
org.antlr.runtime.tree.RewriteRuleElementStream, {
/** Treat next element as a single node even if it's a subtree.
*  This is used instead of next() when the result has to be a
*  tree root node.  Also prevents us from duplicating recently-added
*  children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
*  must dup the type node, but ID has been added.
*
*  Referencing a rule result twice is ok; dup entire tree as
*  we can't be adding trees as root; e.g., expr expr.
*
*  Hideous code duplication here with super.next().  Can't think of
*  a proper way to refactor.  This needs to always call dup node
*  and super.next() doesn't know which to call: dup node or dup tree.
*/
nextNode: function() {
var n = this.size(),
el;
if ( this.dirty || (this.cursor>=n && n===1) ) {
// if out of elements and size is 1, dup (at most a single node
// since this is for making root nodes).
el = this._next();
return this.adaptor.dupNode(el);
}
// test size above then fetch
el = this._next();
return el;
},
dup: function(el) {
return this.adaptor.dupTree(el);
}
});/** A generic recognizer that can handle recognizers generated from
*  lexer, parser, and tree grammars.  This is all the parsing
*  support code essentially; most of it is error recovery stuff and
*  backtracking.
*
*  <p>This class should not be instantiated directly.  Instead, use one of its
*  subclasses.</p>
*
*  @class
*  @param {org.antlr.runtime.RecognizerSharedState} [state] optional state object
*      with which to initialize this recognizer.
*/
org.antlr.runtime.BaseRecognizer = function(state) {
/** State of a lexer, parser, or tree parser are collected into a state
*  object so the state can be shared.  This sharing is needed to
*  have one grammar import others and share same error variables
*  and other state variables.  It's a kind of explicit multiple
*  inheritance via delegation of methods and shared state.
*/
this.state = state || new org.antlr.runtime.RecognizerSharedState();
};
/* static vars, methods */
org.antlr.lang.augmentObject(org.antlr.runtime.BaseRecognizer, {
MEMO_RULE_FAILED: -2,
MEMO_RULE_UNKNOWN: -1,
INITIAL_FOLLOW_STACK_SIZE: 100,
MEMO_RULE_FAILED_I: -2,
DEFAULT_TOKEN_CHANNEL: org.antlr.runtime.Token.DEFAULT_CHANNEL,
HIDDEN: org.antlr.runtime.Token.HIDDEN_CHANNEL,
NEXT_TOKEN_RULE_NAME: "nextToken"
});
org.antlr.runtime.BaseRecognizer.prototype = {
/** Reset the parser's state.  Subclasses must rewinds the input stream */
reset: function() {
var i, len;
// wack everything related to error recovery
if (!this.state) {
return; // no shared state work to do
}
this.state._fsp = -1;
this.state.errorRecovery = false;
this.state.lastErrorIndex = -1;
this.state.failed = false;
this.state.syntaxErrors = 0;
// wack everything related to backtracking and memoization
this.state.backtracking = 0;
// wipe cache
if (this.state.ruleMemo) {
for (i=0, len=this.state.ruleMemo.length; i<len; i++) {
this.state.ruleMemo[i] = null;
}
}
},
/** Match current input symbol against ttype.  Attempt
*  single token insertion or deletion error recovery.  If
*  that fails, throw {@link org.antlr.runtime.MismatchedTokenException}.
*
*  <p>To turn off single token insertion or deletion error
*  recovery, override {@link #mismatchRecover} and have it call
*  plain {@link #mismatch}, which does not recover.  Then any error
*  in a rule will cause an exception and immediate exit from
*  rule.  Rule would recover by resynchronizing to the set of
*  symbols that can follow rule ref.</p>
*
*  @param {org.antlr.runtime.IntStream} input input stream to match against.
*  @param {Number} ttype  input type to match.
*  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
*      matched token.
*  @returns {Object} the matched symbol
*/
match: function(input, ttype, follow) {
var matchedSymbol = this.getCurrentInputSymbol(input);
if ( input.LA(1)===ttype ) {
input.consume();
this.state.errorRecovery = false;
this.state.failed = false;
return matchedSymbol;
}
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return matchedSymbol;
}
matchedSymbol = this.recoverFromMismatchedToken(input, ttype, follow);
return matchedSymbol;
},
/**
* Match any token.
* @param {org.antlr.runtime.IntStream} input input stream to match against.
*/
matchAny: function(input) {
this.state.errorRecovery = false;
this.state.failed = false;
input.consume();
},
/**
* Is the following token (LA(2)) the unwanted type (ttype)?
* @param {org.antlr.runtime.IntStream} input input stream to match against.
* @param {Number} ttype the undesired token type.
* @returns {Boolean} true if and only if the following token is the
*      unwanted type.
*/
mismatchIsUnwantedToken: function(input, ttype) {
return input.LA(2)===ttype;
},
/**
* Does the stream appear to be missing a single token?
* @param {org.antlr.runtime.IntStream} input input stream to match against.
* @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
*      matched token.
* @returns {Boolean} true if and only if it appears that the stream is
*      missing a single token.
*/
mismatchIsMissingToken: function(input, follow) {
if ( !follow ) {
// we have no information about the follow; we can only consume
// a single token and hope for the best
return false;
}
// compute what can follow this grammar element reference
if ( follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) ) {
if ( this.state._fsp>=0 ) { // remove EOR if we're not the start symbol
follow.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
}
var viableTokensFollowingThisRule = this.computeContextSensitiveRuleFOLLOW();
follow = follow.or(this.viableTokensFollowingThisRule);
}
// if current token is consistent with what could come after set
// then we know we're missing a token; error recovery is free to
// "insert" the missing token
// BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
// in follow set to indicate that the fall of the start symbol is
// in the set (EOF can follow).
if ( follow.member(input.LA(1)) ||
follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
{
return true;
}
return false;
},
/** Factor out what to do upon token mismatch so tree parsers can behave
*  differently.  Override and call {@link #mismatchRecover}
*  to get single token insertion and deletion.
*
*  @param {org.antlr.runtime.IntStream} input input stream to match against.
*  @param {Number} ttype  input type to match.
*  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
*      matched token.
*/
mismatch: function(input, ttype, follow) {
if ( this.mismatchIsUnwantedToken(input, ttype) ) {
throw new org.antlr.runtime.UnwantedTokenException(ttype, input);
} else if ( this.mismatchIsMissingToken(input, follow) ) {
throw new org.antlr.runtime.MissingTokenException(ttype, input, null);
}
throw new org.antlr.runtime.MismatchedTokenException(ttype, input);
},
/** Report a recognition problem.
*
*  <p>This method sets errorRecovery to indicate the parser is recovering
*  not parsing.  Once in recovery mode, no errors are generated.
*  To get out of recovery mode, the parser must successfully match
*  a token (after a resync).  So it will go:</p>
*  <ol>
*      <li>error occurs</li>
*      <li>enter recovery mode, report error</li>
*      <li>consume until token found in resynch set</li>
*      <li>try to resume parsing</li>
*      <li>next match() will reset errorRecovery mode</li>
*  </ol>
*
*  <p>If you override, make sure to update this.state.syntaxErrors if you
*  care about that.</p>
*  @param {org.antlr.runtime.RecognitionException} e the error to be reported.
*/
reportError: function(e) {
// if we've already reported an error and have not matched a token
// yet successfully, don't report any errors.
if ( this.state.errorRecovery ) {
return;
}
this.state.syntaxErrors++;
this.state.errorRecovery = true;
this.displayRecognitionError(this.getTokenNames(), e);
},
/**
* Assemble recognition error message.
* @param {Array} tokenNames array of token names (strings).
* @param {org.antlr.runtime.RecognitionException} e the error to be reported.
*/
displayRecognitionError: function(tokenNames, e) {
var hdr = this.getErrorHeader(e),
msg = this.getErrorMessage(e, tokenNames);
this.emitErrorMessage(hdr+" "+msg);
},
/**
* Create error header message.  Format is <q>line
* lineNumber:positionInLine</q>.
* @param {org.antlr.runtime.RecognitionException} e the error to be reported.
* @returns {String} The error header.
*/
getErrorHeader: function(e) {
/* handle null input */
if (!org.antlr.lang.isNumber(e.line)) {
e.line = 0;
}
return "line "+e.line+":"+e.charPositionInLine;
},
/**
* Override this method to change where error messages go.
* Defaults to "alert"-ing the error in browsers and "print"-ing the error
* in other environments (e.g. Rhino, SpiderMonkey).
* @param {String} msg the error message to be displayed.
*/
emitErrorMessage: function(msg) {
if (typeof(window) != 'undefined' && window.alert) {
alert(msg);
} else if (console.warn) {
console.warn(msg);
} else {
print(msg);
}
},
/** What error message should be generated for the various
*  exception types?
*
*  <p>Not very object-oriented code, but I like having all error message
*  generation within one method rather than spread among all of the
*  exception classes. This also makes it much easier for the exception
*  handling because the exception classes do not have to have pointers back
*  to this object to access utility routines and so on. Also, changing
*  the message for an exception type would be difficult because you
*  would have to be subclassing exceptions, but then somehow get ANTLR
*  to make those kinds of exception objects instead of the default.</p>
*
*  <p>For grammar debugging, you will want to override this to add
*  more information such as the stack frame and no viable alts.</p>
*
*  <p>Override this to change the message generated for one or more
*  exception types.</p>
*
* @param {Array} tokenNames array of token names (strings).
* @param {org.antlr.runtime.RecognitionException} e the error to be reported.
* @returns {String} the error message to be emitted.
*/
getErrorMessage: function(e, tokenNames) {
var msg = (e && e.getMessage) ? e.getMessage() : null,
mte,
tokenName;
if ( e instanceof org.antlr.runtime.UnwantedTokenException ) {
var ute = e;
tokenName="<unknown>";
if ( ute.expecting== org.antlr.runtime.Token.EOF ) {
tokenName = "EOF";
} else {
tokenName = tokenNames[ute.expecting];
}
msg = "extraneous input "+this.getTokenErrorDisplay(ute.getUnexpectedToken())+
" expecting "+tokenName;
}
else if ( e instanceof org.antlr.runtime.MissingTokenException ) {
mte = e;
tokenName="<unknown>";
if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
tokenName = "EOF";
} else {
tokenName = tokenNames[mte.expecting];
}
msg = "missing "+tokenName+" at "+this.getTokenErrorDisplay(e.token);
}
else if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
mte = e;
tokenName="<unknown>";
if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
tokenName = "EOF";
}
else {
tokenName = tokenNames[mte.expecting];
}
msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
" expecting "+tokenName;
}
else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
msg = "no viable alternative at input "+this.getTokenErrorDisplay(e.token);
}
else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
msg = "required (...)+ loop did not match anything at input "+
this.getTokenErrorDisplay(e.token);
}
else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.FailedPredicateException ) {
msg = "rule "+e.ruleName+" failed predicate: {"+
e.predicateText+"}?";
}
return msg;
},
/** Get number of recognition errors (lexer, parser, tree parser).  Each
*  recognizer tracks its own number.  So parser and lexer each have
*  separate count.  Does not count the spurious errors found between
*  an error and next valid token match
*
*  See also reportError()
*/
getNumberOfSyntaxErrors: function() {
return this.state.syntaxErrors;
},
/** How should a token be displayed in an error message? The default
*  is to display just the text, but during development you might
*  want to have a lot of information spit out.  Override in that case
*  to use t.toString() (which, for CommonToken, dumps everything about
*  the token). This is better than forcing you to override a method in
*  your token objects because you don't have to go modify your lexer
*  so that it creates a new Java type.
*/
getTokenErrorDisplay: function(t) {
var s = t.toString(); // t.getText();
if ( !org.antlr.lang.isValue(s) ) {
if ( t.getType()==org.antlr.runtime.Token.EOF ) {
s = "<EOF>";
}
else {
s = "<"+t.getType()+">";
}
}
s = s.replace(/\n/g,"\\n");
s = s.replace(/\r/g,"\\r");
s = s.replace(/\t/g,"\\t");
return "'"+s+"'";
},
/** Recover from an error found on the input stream.  This is
*  for NoViableAlt and mismatched symbol exceptions.  If you enable
*  single token insertion and deletion, this will usually not
*  handle mismatched symbol exceptions but there could be a mismatched
*  token that the match() routine could not recover from.
*/
recover: function(input, re) {
if ( this.state.lastErrorIndex==input.index() ) {
// uh oh, another error at same token index; must be a case
// where LT(1) is in the recovery token set so nothing is
// consumed; consume a single token so at least to prevent
// an infinite loop; this is a failsafe.
input.consume();
}
this.state.lastErrorIndex = input.index();
var followSet = this.computeErrorRecoverySet();
this.beginResync();
this.consumeUntil(input, followSet);
this.endResync();
},
/** A hook to listen in on the token consumption during error recovery.
*  The DebugParser subclasses this to fire events to the listenter.
*/
beginResync: function() {
},
endResync: function() {
},
/*  Compute the error recovery set for the current rule.  During
*  rule invocation, the parser pushes the set of tokens that can
*  follow that rule reference on the stack; this amounts to
*  computing FIRST of what follows the rule reference in the
*  enclosing rule. This local follow set only includes tokens
*  from within the rule; i.e., the FIRST computation done by
*  ANTLR stops at the end of a rule.
*
*  EXAMPLE
*
*  When you find a "no viable alt exception", the input is not
*  consistent with any of the alternatives for rule r.  The best
*  thing to do is to consume tokens until you see something that
*  can legally follow a call to r *or* any rule that called r.
*  You don't want the exact set of viable next tokens because the
*  input might just be missing a token--you might consume the
*  rest of the input looking for one of the missing tokens.
*
*  Consider grammar:
*
*  a : '[' b ']'
*    | '(' b ')'
*    ;
*  b : c '^' INT ;
*  c : ID
*    | INT
*    ;
*
*  At each rule invocation, the set of tokens that could follow
*  that rule is pushed on a stack.  Here are the various "local"
*  follow sets:
*
*  FOLLOW(b1_in_a) = FIRST(']') = ']'
*  FOLLOW(b2_in_a) = FIRST(')') = ')'
*  FOLLOW(c_in_b) = FIRST('^') = '^'
*
*  Upon erroneous input "[]", the call chain is
*
*  a -> b -> c
*
*  and, hence, the follow context stack is:
*
*  depth  local follow set     after call to rule
*    0         <EOF>                    a (from main())
*    1          ']'                     b
*    3          '^'                     c
*
*  Notice that ')' is not included, because b would have to have
*  been called from a different context in rule a for ')' to be
*  included.
*
*  For error recovery, we cannot consider FOLLOW(c)
*  (context-sensitive or otherwise).  We need the combined set of
*  all context-sensitive FOLLOW sets--the set of all tokens that
*  could follow any reference in the call chain.  We need to
*  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
*  we resync'd to that token, we'd consume until EOF.  We need to
*  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
*  In this case, for input "[]", LA(1) is in this set so we would
*  not consume anything and after printing an error rule c would
*  return normally.  It would not find the required '^' though.
*  At this point, it gets a mismatched token error and throws an
*  exception (since LA(1) is not in the viable following token
*  set).  The rule exception handler tries to recover, but finds
*  the same recovery set and doesn't consume anything.  Rule b
*  exits normally returning to rule a.  Now it finds the ']' (and
*  with the successful match exits errorRecovery mode).
*
*  So, you cna see that the parser walks up call chain looking
*  for the token that was a member of the recovery set.
*
*  Errors are not generated in errorRecovery mode.
*
*  ANTLR's error recovery mechanism is based upon original ideas:
*
*  "Algorithms + Data Structures = Programs" by Niklaus Wirth
*
*  and
*
*  "A note on error recovery in recursive descent parsers":
*  http://portal.acm.org/citation.cfm?id=947902.947905
*
*  Later, Josef Grosch had some good ideas:
*
*  "Efficient and Comfortable Error Recovery in Recursive Descent
*  Parsers":
*  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
*
*  Like Grosch I implemented local FOLLOW sets that are combined
*  at run-time upon error to avoid overhead during parsing.
*/
computeErrorRecoverySet: function() {
return this.combineFollows(false);
},
/** Compute the context-sensitive FOLLOW set for current rule.
*  This is set of token types that can follow a specific rule
*  reference given a specific call chain.  You get the set of
*  viable tokens that can possibly come next (lookahead depth 1)
*  given the current call chain.  Contrast this with the
*  definition of plain FOLLOW for rule r:
*
*   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
*
*  where x in T* and alpha, beta in V*; T is set of terminals and
*  V is the set of terminals and nonterminals.  In other words,
*  FOLLOW(r) is the set of all tokens that can possibly follow
*  references to r in *any* sentential form (context).  At
*  runtime, however, we know precisely which context applies as
*  we have the call chain.  We may compute the exact (rather
*  than covering superset) set of following tokens.
*
*  For example, consider grammar:
*
*  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
*       | "return" expr '.'
*       ;
*  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
*  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
*       | '(' expr ')'
*       ;
*
*  The FOLLOW sets are all inclusive whereas context-sensitive
*  FOLLOW sets are precisely what could follow a rule reference.
*  For input input "i=(3);", here is the derivation:
*
*  stat => ID '=' expr ';'
*       => ID '=' atom ('+' atom)* ';'
*       => ID '=' '(' expr ')' ('+' atom)* ';'
*       => ID '=' '(' atom ')' ('+' atom)* ';'
*       => ID '=' '(' INT ')' ('+' atom)* ';'
*       => ID '=' '(' INT ')' ';'
*
*  At the "3" token, you'd have a call chain of
*
*    stat -> expr -> atom -> expr -> atom
*
*  What can follow that specific nested ref to atom?  Exactly ')'
*  as you can see by looking at the derivation of this specific
*  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
*
*  You want the exact viable token set when recovering from a
*  token mismatch.  Upon token mismatch, if LA(1) is member of
*  the viable next token set, then you know there is most likely
*  a missing token in the input stream.  "Insert" one by just not
*  throwing an exception.
*/
computeContextSensitiveRuleFOLLOW: function() {
return this.combineFollows(true);
},
combineFollows: function(exact) {
var top = this.state._fsp,
i,
localFollowSet,
followSet = new org.antlr.runtime.BitSet();
for (i=top; i>=0; i--) {
localFollowSet = this.state.following[i];
followSet.orInPlace(localFollowSet);
if ( exact ) {
// can we see end of rule?
if ( localFollowSet.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
{
// Only leave EOR in set if at top (start rule); this lets
// us know if have to include follow(start rule); i.e., EOF
if ( i>0 ) {
followSet.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
}
}
else { // can't see end of rule, quit
break;
}
}
}
return followSet;
},
/** Attempt to recover from a single missing or extra token.
*
*  EXTRA TOKEN
*
*  LA(1) is not what we are looking for.  If LA(2) has the right token,
*  however, then assume LA(1) is some extra spurious token.  Delete it
*  and LA(2) as if we were doing a normal match(), which advances the
*  input.
*
*  MISSING TOKEN
*
*  If current token is consistent with what could come after
*  ttype then it is ok to "insert" the missing token, else throw
*  exception For example, Input "i=(3;" is clearly missing the
*  ')'.  When the parser returns from the nested call to expr, it
*  will have call chain:
*
*    stat -> expr -> atom
*
*  and it will be trying to match the ')' at this point in the
*  derivation:
*
*       => ID '=' '(' INT ')' ('+' atom)* ';'
*                          ^
*  match() will see that ';' doesn't match ')' and report a
*  mismatched token error.  To recover, it sees that LA(1)==';'
*  is in the set of tokens that can follow the ')' token
*  reference in rule atom.  It can assume that you forgot the ')'.
*/
recoverFromMismatchedToken: function(input,
ttype,
follow)
{
var e = null;
// if next token is what we are looking for then "delete" this token
if ( this.mismatchIsUnwantedToken(input, ttype) ) {
e = new org.antlr.runtime.UnwantedTokenException(ttype, input);
this.beginResync();
input.consume(); // simply delete extra token
this.endResync();
this.reportError(e);  // report after consuming so AW sees the token in the exception
// we want to return the token we're actually matching
var matchedSymbol = this.getCurrentInputSymbol(input);
input.consume(); // move past ttype token as if all were ok
return matchedSymbol;
}
// can't recover with single token deletion, try insertion
if ( this.mismatchIsMissingToken(input, follow) ) {
var inserted = this.getMissingSymbol(input, e, ttype, follow);
e = new org.antlr.runtime.MissingTokenException(ttype, input, inserted);
this.reportError(e);  // report after inserting so AW sees the token in the exception
return inserted;
}
// even that didn't work; must throw the exception
e = new org.antlr.runtime.MismatchedTokenException(ttype, input);
throw e;
},
recoverFromMismatchedSet: function(input,
e,
follow)
{
if ( this.mismatchIsMissingToken(input, follow) ) {
// System.out.println("missing token");
this.reportError(e);
// we don't know how to conjure up a token for sets yet
return this.getMissingSymbol(input, e, org.antlr.runtime.Token.INVALID_TOKEN_TYPE, follow);
}
throw e;
},
/** Match needs to return the current input symbol, which gets put
*  into the label for the associated token ref; e.g., x=ID.  Token
*  and tree parsers need to return different objects. Rather than test
*  for input stream type or change the IntStream interface, I use
*  a simple method to ask the recognizer to tell me what the current
*  input symbol is.
* 
*  This is ignored for lexers.
*/
getCurrentInputSymbol: function(input) { return null; },
/** Conjure up a missing token during error recovery.
*
*  The recognizer attempts to recover from single missing
*  symbols. But, actions might refer to that missing symbol.
*  For example, x=ID {f($x);}. The action clearly assumes
*  that there has been an identifier matched previously and that
*  $x points at that token. If that token is missing, but
*  the next token in the stream is what we want we assume that
*  this token is missing and we keep going. Because we
*  have to return some token to replace the missing token,
*  we have to conjure one up. This method gives the user control
*  over the tokens returned for missing tokens. Mostly,
*  you will want to create something special for identifier
*  tokens. For literals such as '{' and ',', the default
*  action in the parser or tree parser works. It simply creates
*  a CommonToken of the appropriate type. The text will be the token.
*  If you change what tokens must be created by the lexer,
*  override this method to create the appropriate tokens.
*/
getMissingSymbol: function(input,
e,
expectedTokenType,
follow)
{
return null;
},
/** Consume tokens until one matches the given token set */
consumeUntil: function(input, set) {
var ttype = input.LA(1);
while (ttype != org.antlr.runtime.Token.EOF && !set.member(ttype) ) {
input.consume();
ttype = input.LA(1);
}
},
/** Push a rule's follow set using our own hardcoded stack */
pushFollow: function(fset) {
if ( (this.state._fsp +1)>=this.state.following.length ) {
var f = [];
var i;
for (i=this.state.following.length-1; i>=0; i--) {
f[i] = this.state.following[i];
}
this.state.following = f;
}
this.state._fsp++;
this.state.following[this.state._fsp] = fset;
},
/** Return List<String> of the rules in your parser instance
*  leading up to a call to this method.  You could override if
*  you want more details such as the file/line info of where
*  in the parser java code a rule is invoked.
*
*  This is very useful for error messages and for context-sensitive
*  error recovery.
*
*  A more general version of getRuleInvocationStack where you can
*  pass in, for example, a RecognitionException to get it's rule
*  stack trace.  This routine is shared with all recognizers, hence,
*  static.
*
*  TODO: move to a utility class or something; weird having lexer call this
*
*  Most JS interpreters can't do real stack reflection.  See this
*  spidermonkey bug, for example:
*  https://bugzilla.mozilla.org/show_bug.cgi?id=332104
*
*  JS is supposed to get real stack traces in v4, at which time it would
*  be easy to implement this function.
*
*  Until then I'll leave this unimplemented.  If there is enough clamor
*  it would be possible to keep track of the invocation stack using an
*  auxillary array, but that will definitely be a performance hit.
*/
getRuleInvocationStack: function(e, recognizerClassName)
{
throw new Error("Not implemented.");
},
getBacktrackingLevel: function() {
return this.state.backtracking;
},
/** Used to print out token names like ID during debugging and
*  error reporting.  The generated parsers implement a method
*  that overrides this to point to their String[] tokenNames.
*/
getTokenNames: function() {
return null;
},
/** For debugging and other purposes, might want the grammar name.
*  Have ANTLR generate an implementation for this method.
*/
getGrammarFileName: function() {
return null;
},
/** A convenience method for use most often with template rewrites.
*  Convert a List<Token> to List<String>
*/
toStrings: function(tokens) {
if ( !tokens ) {
return null;
}
var strings = [];
var i;
for (i=0; i<tokens.length; i++) {
strings.push(tokens[i].getText());
}
return strings;
},
/** Given a rule number and a start token index number, return
*  MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
*  start index.  If this rule has parsed input starting from the
*  start index before, then return where the rule stopped parsing.
*  It returns the index of the last token matched by the rule.
*
*  For now we use a hashtable and just the slow Object-based one.
*  Later, we can make a special one for ints and also one that
*  tosses out data after we commit past input position i.
*/
getRuleMemoization: function(ruleIndex, ruleStartIndex) {
if ( !this.state.ruleMemo[ruleIndex] ) {
this.state.ruleMemo[ruleIndex] = {};
}
var stopIndexI =
this.state.ruleMemo[ruleIndex][ruleStartIndex];
if ( !org.antlr.lang.isNumber(stopIndexI) ) {
return org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN;
}
return stopIndexI;
},
/** Has this rule already parsed input at the current index in the
*  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
*  If we attempted but failed to parse properly before, return
*  MEMO_RULE_FAILED.
*
*  This method has a side-effect: if we have seen this input for
*  this rule and successfully parsed before, then seek ahead to
*  1 past the stop token matched for this rule last time.
*/
alreadyParsedRule: function(input, ruleIndex) {
var stopIndex = this.getRuleMemoization(ruleIndex, input.index());
if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN ) {
return false;
}
if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED ) {
//System.out.println("rule "+ruleIndex+" will never succeed");
this.state.failed=true;
}
else {
input.seek(stopIndex+1); // jump to one past stop token
}
return true;
},
/** Record whether or not this rule parsed the input at this position
*  successfully.  Use a standard java hashtable for now.
*/
memoize: function(input,
ruleIndex,
ruleStartIndex)
{
var stopTokenIndex = this.state.failed ? 
org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED : input.index()-1;
if ( !org.antlr.lang.isValue(this.state.ruleMemo) ) {
throw new Error("!!!!!!!!! memo array is null for "+ this.getGrammarFileName());
}
if ( ruleIndex >= this.state.ruleMemo.length ) {
throw new Error("!!!!!!!!! memo size is "+this.state.ruleMemo.length+", but rule index is "+ruleIndex);
}
if ( org.antlr.lang.isValue(this.state.ruleMemo[ruleIndex]) ) {
this.state.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex;
}
},
/** return how many rule/input-index pairs there are in total.
*  TODO: this includes synpreds.
*/
getRuleMemoizationCacheSize: function() {
var n = 0, i;
for (i = 0; this.state.ruleMemo && i < this.state.ruleMemo.length; i++) {
var ruleMap = this.state.ruleMemo[i];
if ( ruleMap ) {
// @todo need to get size of rulemap?
n += ruleMap.length; // how many input indexes are recorded?
}
}
return n;
},
traceIn: function(ruleName, ruleIndex, inputSymbol)  {
this.emitErrorMessage("enter "+ruleName+" "+inputSymbol);
if ( this.state.failed ) {
this.emitErrorMessage(" failed="+this.failed);
}
if ( this.state.backtracking>0 ) {
this.emitErrorMessage(" backtracking="+this.state.backtracking);
}
// System.out.println();
},
traceOut: function(ruleName, ruleIndex, inputSymbol) {
this.emitErrorMessage("exit "+ruleName+" "+inputSymbol);
if ( this.state.failed ) {
this.emitErrorMessage(" failed="+this.state.failed);
}
if ( this.state.backtracking>0 ) {
this.emitErrorMessage(" backtracking="+this.state.backtracking);
}
}
};
/** A lexer is recognizer that draws input symbols from a character stream.
*  lexer grammars result in a subclass of this object. A Lexer object
*  uses simplified match() and error recovery mechanisms in the interest
*  of speed.
*/
org.antlr.runtime.Lexer = function(input, state) {
if (state) {
org.antlr.runtime.Lexer.superclass.constructor.call(this, state);
}
if (input) {
this.input = input;
}
};
org.antlr.lang.extend(org.antlr.runtime.Lexer, org.antlr.runtime.BaseRecognizer, {
reset: function() {
// reset all recognizer state variables
org.antlr.runtime.Lexer.superclass.reset.call(this);
if ( org.antlr.lang.isValue(this.input) ) {
this.input.seek(0); // rewind the input
}
if ( !org.antlr.lang.isValue(this.state) ) {
return; // no shared state work to do
}
this.state.token = null;
this.state.type = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
this.state.tokenStartCharIndex = -1;
this.state.tokenStartCharPositionInLine = -1;
this.state.tokenStartLine = -1;
this.state.text = null;
},
/** Return a token from this source; i.e., match a token on the char
*  stream.
*/
nextToken: function() {
while (true) {
this.state.token = null;
this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
this.state.tokenStartCharIndex = this.input.index();
this.state.tokenStartCharPositionInLine = this.input.getCharPositionInLine();
this.state.tokenStartLine = this.input.getLine();
this.state.text = null;
if ( this.input.LA(1)===org.antlr.runtime.CharStream.EOF ) {
return org.antlr.runtime.Token.EOF_TOKEN;
}
try {
this.mTokens();
if ( !org.antlr.lang.isValue(this.state.token) ) {
this.emit();
}
else if ( this.state.token==org.antlr.runtime.Token.SKIP_TOKEN ) {
continue;
}
return this.state.token;
}
catch (re) {
if ( re instanceof org.antlr.runtime.RecognitionException ) {
this.reportError(re);
} else if (re instanceof org.antlr.runtime.NoViableAltException) {
this.reportError(re);
this.recover(re);
} else {
throw re;
}
}
}
},
/** Instruct the lexer to skip creating a token for current lexer rule
*  and look for another token.  nextToken() knows to keep looking when
*  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
*  if token==null at end of any token rule, it creates one for you
*  and emits it.
*/
skip: function() {
this.state.token = org.antlr.runtime.Token.SKIP_TOKEN;
},
/** Set the char stream and reset the lexer */
setCharStream: function(input) {
this.input = null;
this.reset();
this.input = input;
},
getCharStream: function() {
return this.input;
},
getSourceName: function() {
return this.input.getSourceName();
},
/** Currently does not support multiple emits per nextToken invocation
*  for efficiency reasons.  Subclass and override this method and
*  nextToken (to push tokens into a list and pull from that list rather
*  than a single variable as this implementation does).
*
*  The standard method called to automatically emit a token at the
*  outermost lexical rule.  The token object should point into the
*  char buffer start..stop.  If there is a text override in 'text',
*  use that to set the token's text.  Override this method to emit
*  custom Token objects.
*
*  If you are building trees, then you should also override
*  Parser or TreeParser.getMissingSymbol().
*/
emit: function() {
if (arguments.length===0) {
var t = new org.antlr.runtime.CommonToken(this.input, this.state.type, this.state.channel, this.state.tokenStartCharIndex, this.getCharIndex()-1);
t.setLine(this.state.tokenStartLine);
t.setText(this.state.text);
t.setCharPositionInLine(this.state.tokenStartCharPositionInLine);
this.state.token = t;
return t;
} else {
this.state.token = arguments[0];
}
},
match: function(s) {
var i = 0,
mte;
if (org.antlr.lang.isString(s)) {
while ( i<s.length ) {
if ( this.input.LA(1)!=s.charAt(i) ) {
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return;
}
mte = new org.antlr.runtime.MismatchedTokenException(s.charAt(i), this.input);
this.recover(mte);
throw mte;
}
i++;
this.input.consume();
this.state.failed = false;
}
} else if (org.antlr.lang.isNumber(s)) {
if ( this.input.LA(1)!=s ) {
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return;
}
mte = new org.antlr.runtime.MismatchedTokenException(s, this.input);
this.recover(mte);
throw mte;
}
this.input.consume();
this.state.failed = false;
}
},
matchAny: function() {
this.input.consume();
},
matchRange: function(a, b) {
if ( this.input.LA(1)<a || this.input.LA(1)>b ) {
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return;
}
mre = new org.antlr.runtime.MismatchedRangeException(a,b,this.input);
this.recover(mre);
throw mre;
}
this.input.consume();
this.state.failed = false;
},
getLine: function() {
return this.input.getLine();
},
getCharPositionInLine: function() {
return this.input.getCharPositionInLine();
},
/** What is the index of the current character of lookahead? */
getCharIndex: function() {
return this.input.index();
},
/** Return the text matched so far for the current token or any
*  text override.
*/
getText: function() {
if ( org.antlr.lang.isString(this.state.text) ) {
return this.state.text;
}
return this.input.substring(this.state.tokenStartCharIndex,this.getCharIndex()-1);
},
/** Set the complete text of this token; it wipes any previous
*  changes to the text.
*/
setText: function(text) {
this.state.text = text;
},
reportError: function(e) {
/** TODO: not thought about recovery in lexer yet.
*
// if we've already reported an error and have not matched a token
// yet successfully, don't report any errors.
if ( errorRecovery ) {
//System.err.print("[SPURIOUS] ");
return;
}
errorRecovery = true;
*/
this.displayRecognitionError(this.getTokenNames(), e);
},
getErrorMessage: function(e, tokenNames) {
var msg = null;
if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting "+this.getCharErrorDisplay(e.expecting);
}
else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
msg = "no viable alternative at character "+this.getCharErrorDisplay(e.c);
}
else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
msg = "required (...)+ loop did not match anything at character "+this.getCharErrorDisplay(e.c);
}
else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.MismatchedRangeException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+
this.getCharErrorDisplay(e.a)+".."+this.getCharErrorDisplay(e.b);
}
else {
msg = org.antlr.runtime.Lexer.superclass.getErrorMessage.call(this, e, tokenNames);
}
return msg;
},
getCharErrorDisplay: function(c) {
var s = c; //String.fromCharCode(c);
switch ( s ) {
case org.antlr.runtime.Token.EOF :
s = "<EOF>";
break;
case "\n" :
s = "\\n";
break;
case "\t" :
s = "\\t";
break;
case "\r" :
s = "\\r";
break;
}
return "'"+s+"'";
},
/** Lexers can normally match any char in it's vocabulary after matching
*  a token, so do the easy thing and just kill a character and hope
*  it all works out.  You can instead use the rule invocation stack
*  to do sophisticated error recovery if you are in a fragment rule.
*/
recover: function(re) {
this.input.consume();
},
traceIn: function(ruleName, ruleIndex)  {
var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
org.antlr.runtime.Lexer.superclass.traceIn.call(this, ruleName, ruleIndex, inputSymbol);
},
traceOut: function(ruleName, ruleIndex)  {
var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
org.antlr.runtime.Lexer.superclass.traceOut.call(this, ruleName, ruleIndex, inputSymbol);
}
});
/** Rules that return more than a single value must return an object
*  containing all the values.  Besides the properties defined in
*  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
*  return values.  This class simply defines the minimum properties that
*  are always defined and methods to access the others that might be
*  available depending on output option such as template and tree.
*
*  Note text is not an actual property of the return value, it is computed
*  from start and stop using the input stream's toString() method.  I
*  could add a ctor to this so that we can pass in and store the input
*  stream, but I'm not sure we want to do that.  It would seem to be undefined
*  to get the .text property anyway if the rule matches tokens from multiple
*  input streams.
*
*  I do not use getters for fields of objects that are used simply to
*  group values such as this aggregate.  The getters/setters are there to
*  satisfy the superclass interface.
*/
org.antlr.runtime.ParserRuleReturnScope = function() {};
org.antlr.runtime.ParserRuleReturnScope.prototype = {
getStart: function() { return this.start; },
getStop: function() { return this.stop; }
};
/** This is identical to the ParserRuleReturnScope except that
*  the start property is a tree nodes not Token object
*  when you are parsing trees.  To be generic the tree node types
*  have to be Object.
*/
org.antlr.runtime.tree.TreeRuleReturnScope = function(){};
org.antlr.runtime.tree.TreeRuleReturnScope.prototype = {
getStart: function() { return this.start; }
};
/** A parser for TokenStreams.  "parser grammars" result in a subclass
*  of this.
*/
org.antlr.runtime.Parser = function(input, state) {
org.antlr.runtime.Parser.superclass.constructor.call(this, state);
this.setTokenStream(input);
};
org.antlr.lang.extend(org.antlr.runtime.Parser, org.antlr.runtime.BaseRecognizer, {
reset: function() {
// reset all recognizer state variables
org.antlr.runtime.Parser.superclass.reset.call(this);
if ( org.antlr.lang.isValue(this.input) ) {
this.input.seek(0); // rewind the input
}
},
getCurrentInputSymbol: function(input) {
return input.LT(1);
},
getMissingSymbol: function(input,
e,
expectedTokenType,
follow)
{
var tokenText =
"<missing "+this.getTokenNames()[expectedTokenType]+">";
var t = new org.antlr.runtime.CommonToken(expectedTokenType, tokenText);
var current = input.LT(1);
var old_current;
if ( current.getType() === org.antlr.runtime.Token.EOF ) {
old_current = current;
current = input.LT(-1);
// handle edge case where there are no good tokens in the stream
if (!current) {
current = old_current;
}
}
t.line = current.getLine();
t.charPositionInLine = current.getCharPositionInLine();
t.channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
return t;
},
/** Set the token stream and reset the parser */
setTokenStream: function(input) {
this.input = null;
this.reset();
this.input = input;
},
getTokenStream: function() {
return this.input;
},
getSourceName: function() {
return this.input.getSourceName();
},
traceIn: function(ruleName, ruleIndex)  {
org.antlr.runtime.Parser.superclass.traceIn.call(
this, ruleName, ruleIndex, this.input.LT(1));
},
traceOut: function(ruleName, ruleIndex)  {
org.antlr.runtime.Parser.superclass.traceOut.call(
this, ruleName, ruleIndex, this.input.LT(1));
}
});
/** A DFA implemented as a set of transition tables.
*
*  Any state that has a semantic predicate edge is special; those states
*  are generated with if-then-else structures in a specialStateTransition()
*  which is generated by cyclicDFA template.
*
*  There are at most 32767 states (16-bit signed short).
*  Could get away with byte sometimes but would have to generate different
*  types and the simulation code too.  For a point of reference, the Java
*  lexer's Tokens rule DFA has 326 states roughly.
*/
org.antlr.runtime.DFA = function() {};
org.antlr.runtime.DFA.prototype = {
/** From the input stream, predict what alternative will succeed
*  using this DFA (representing the covering regular approximation
*  to the underlying CFL).  Return an alternative number 1..n.  Throw
*  an exception upon error.
*/
predict: function(input) {
var mark = input.mark(), // remember where decision started in input
s = 0, // we always start at s0
specialState,
c,
snext;
try {
while ( true ) {
specialState = this.special[s];
if ( specialState>=0 ) {
s = this.specialStateTransition(specialState,input);
if (s===-1) {
this.noViableAlt(s, input);
return 0;
}
input.consume();
continue;
}
if ( this.accept[s] >= 1 ) {
return this.accept[s];
}
// look for a normal char transition
c = input.LA(1); // -1 == \uFFFF, all tokens fit in 65000 space
if (c===org.antlr.runtime.Token.EOF) {
c = -1;
} else if (org.antlr.lang.isString(c)) {
c = c.charCodeAt(0);
}
if (c>=this.min[s] && c<=this.max[s]) {
snext = this.transition[s][c-this.min[s]]; // move to next state
if ( snext < 0 ) {
// was in range but not a normal transition
// must check EOT, which is like the else clause.
// eot[s]>=0 indicates that an EOT edge goes to another
// state.
if ( this.eot[s]>=0 ) {  // EOT Transition to accept state?
s = this.eot[s];
input.consume();
// TODO: I had this as return accept[eot[s]]
// which assumed here that the EOT edge always
// went to an accept...faster to do this, but
// what about predicated edges coming from EOT
// target?
continue;
}
this.noViableAlt(s,input);
return 0;
}
s = snext;
input.consume();
continue;
}
if ( this.eot[s]>=0 ) {  // EOT Transition?
s = this.eot[s];
input.consume();
continue;
}
if ( c==org.antlr.runtime.Token.EOF && this.eof[s]>=0 ) {  // EOF Transition to accept state?
return this.accept[this.eof[s]];
}
// not in range and not EOF/EOT, must be invalid symbol
this.noViableAlt(s,input);
return 0;
}
}
finally {
input.rewind(mark);
}
},
noViableAlt: function(s, input) {
if (this.recognizer.state.backtracking>0) {
this.recognizer.state.failed=true;
return;
}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(),
this.decisionNumber,
s,
input);
this.error(nvae);
throw nvae;
},
/** A hook for debugging interface */
error: function(nvae) { },
specialStateTransition: function(s, input) {
return -1;
},
getDescription: function() {
return "n/a";
}
};
org.antlr.lang.augmentObject(org.antlr.runtime.DFA, {
/** Given a String that has a run-length-encoding of some unsigned shorts
*  like "\1\2\3\9", convert to short[] {2,9,9,9}.
*/
unpackEncodedString: function(encodedString) {
// walk first to find how big it is.
var i,
data = [],
di = 0,
n,
v,
j;
for (i=0; i<encodedString.length; i+=2) {
n = encodedString.charCodeAt(i);
v = encodedString.charCodeAt(i+1);
if (v===0xffff) {
v = -1; // overflow at 16 bits
}
// add v n times to data
for (j=1; j<=n; j++) {
data[di++] = v;
}
}
return data;
},
// alias
unpackEncodedStringToUnsignedChars: function(encodedString) {
return org.antlr.runtime.DFA.unpackEncodedString(encodedString);
}
});
/** A parser for a stream of tree nodes.  "tree grammars" result in a subclass
*  of this.  All the error reporting and recovery is shared with Parser via
*  the BaseRecognizer superclass.
*/
org.antlr.runtime.tree.TreeParser = function(input) {
org.antlr.runtime.tree.TreeParser.superclass.constructor.call(this, arguments[1]);
this.setTreeNodeStream(input);
};
(function(){
var TP = org.antlr.runtime.tree.TreeParser;
org.antlr.lang.augmentObject(TP, {
DOWN: org.antlr.runtime.Token.DOWN,
UP: org.antlr.runtime.Token.UP
});
org.antlr.lang.extend(TP, org.antlr.runtime.BaseRecognizer, {
reset: function() {
TP.superclass.reset.call(this); // reset all recognizer state variables
if ( this.input ) {
this.input.seek(0); // rewind the input
}
},
/** Set the input stream */
setTreeNodeStream: function(input) {
this.input = input;
},
getTreeNodeStream: function() {
return this.input;
},
getSourceName: function() {
return this.input.getSourceName();
},
getCurrentInputSymbol: function(input) {
return input.LT(1);
},
getMissingSymbol: function(input, e, expectedTokenType, follow) {
var tokenText =
"<missing "+this.getTokenNames()[expectedTokenType]+">";
return new org.antlr.runtime.tree.CommonTree(new org.antlr.runtime.CommonToken(expectedTokenType, tokenText));
},
/** Match '.' in tree parser has special meaning.  Skip node or
*  entire tree if node has children.  If children, scan until
*  corresponding UP node.
*/
matchAny: function(ignore) { // ignore stream, copy of this.input
this.state.errorRecovery = false;
this.state.failed = false;
var look = this.input.LT(1);
if ( this.input.getTreeAdaptor().getChildCount(look)===0 ) {
this.input.consume(); // not subtree, consume 1 node and return
return;
}
// current node is a subtree, skip to corresponding UP.
// must count nesting level to get right UP
var level=0,
tokenType = this.input.getTreeAdaptor().getType(look);
while ( tokenType!==org.antlr.runtime.Token.EOF &&
!(tokenType===TP.UP && level===0) )
{
this.input.consume();
look = this.input.LT(1);
tokenType = this.input.getTreeAdaptor().getType(look);
if ( tokenType === TP.DOWN ) {
level++;
}
else if ( tokenType === TP.UP ) {
level--;
}
}
this.input.consume(); // consume UP
},
/** We have DOWN/UP nodes in the stream that have no line info; override.
*  plus we want to alter the exception type.  Don't try to recover
*       *  from tree parser errors inline...
*/
mismatch: function(input, ttype, follow) {
throw new org.antlr.runtime.MismatchedTreeNodeException(ttype, input);
},
/** Prefix error message with the grammar name because message is
*  always intended for the programmer because the parser built
*  the input tree not the user.
*/
getErrorHeader: function(e) {
return this.getGrammarFileName()+": node from "+
(e.approximateLineInfo?"after ":"")+"line "+e.line+":"+e.charPositionInLine;
},
/** Tree parsers parse nodes they usually have a token object as
*  payload. Set the exception token and do the default behavior.
*/
getErrorMessage: function(e, tokenNames) {
var adaptor;
if ( this instanceof TP ) {
adaptor = e.input.getTreeAdaptor();
e.token = adaptor.getToken(e.node);
if ( !org.antlr.lang.isValue(e.token) ) { // could be an UP/DOWN node
e.token = new org.antlr.runtime.CommonToken(
adaptor.getType(e.node),
adaptor.getText(e.node));
}
}
return TP.superclass.getErrorMessage.call(this, e, tokenNames);
},
traceIn: function(ruleName, ruleIndex) {
TP.superclass.traceIn.call(this, ruleName, ruleIndex, this.input.LT(1));
},
traceOut: function(ruleName, ruleIndex) {
TP.superclass.traceOut.call(this, ruleName, ruleIndex, this.input.LT(1));
}
});
})();
//-------- js/Ham4Parser.js --------
// $ANTLR 3.3 Nov 30, 2010 12:50:56 Ham4Parser.g 2017-05-06 19:33:41
// Parser header
var Ham4Parser = function(input, state) {
if (!state) {
state = new org.antlr.runtime.RecognizerSharedState();
}
(function(){
// Parser members
// /** Logger. */
// private static final Logger	logger = LogManager.getLogger();
// 
// private boolean eReportImmediate = false;
// 
// private static String EOL_4sp = StringUtils.EOL+"    ";
// private int errorCount = 0;
// private String errorString = "";
var errorCount = 0;
var errorString = "";
// /** Constructs a new HNS-4 sign parser, taking input from the given
//  * token stream, and using the given setting of the
//  * <q>Immediate Error Reporting</q> flag.
//  */
// public Ham4Parser(TokenStream lexer, boolean erimmed) {
//     this(lexer);
//     this.eReportImmediate = erimmed;
// }
// 
// /** Does nothing unless parse errors have occurred, in which case
//  * a new {@code RecognitionException} is thrown whose detail message
//  * is a complete parsing error log.
//  */
// public void checkForParseError() throws RecognitionException {
//     if (this.errorCount != 0) {
//         String emsgmid =
//             this.errorCount == 1 ? " error:  " : " errors:"+EOL_4sp;
//         String msg =
//             this.errorCount + emsgmid + this.errorString;
//         System.err.println(msg);
//         // Wrong argument type for ANTLR3
//         // throw new RecognitionException(msg);
//         throw new RecognitionException();
//     }
// }
// /** Reports the parsing error defined by the given exception: an error
//  * message is appended to the overall error text for this parse, and
//  * a message is also generated immediately on standard output
//  * if the parser's <q>Immediate Error Reporting</q> flag is set.
//  */
// public void reportError(RecognitionException ex) {
//     //super.reportError(ex);
//     if (this.eReportImmediate) {
//         System.out.println("#### PARSE-ERR:" + ex.toString() + " ####");
//     }
//     logger.log(LoggerConfig.LOGLevel, LoggerConfig.ANTLRMarker,"Parse: Error: "+ex.toString());
this.reportError = function(ex) {
if (this.logLev >= 300) {
console.warn ("Parsing Error: " + ex);
}
var pfx = errorCount == 0 ? "" : "\n";
errorCount++;
errorString += pfx + "[" + ex + "]";
}
var logLev = 0;
this.setLogLevel = function(lev) {
this.logLev = lev;
};
this.trace = function(str) {
if (this.logLev >= 440) {
console.log(str);
}
};
this.checkErrors = function() {
if (errorCount == 0)
return null
else
return { errCount: errorCount, errText: errorString };
}
// //########  BEGIN GENERATED CODE  ########
}).call(this);
Ham4Parser.superclass.constructor.call(this, input, state);
this.dfa13 = new Ham4Parser.DFA13(this);
this.dfa14 = new Ham4Parser.DFA14(this);
this.dfa16 = new Ham4Parser.DFA16(this);
this.dfa15 = new Ham4Parser.DFA15(this);
this.dfa18 = new Ham4Parser.DFA18(this);
this.dfa21 = new Ham4Parser.DFA21(this);
this.dfa25 = new Ham4Parser.DFA25(this);
this.dfa23 = new Ham4Parser.DFA23(this);
this.dfa26 = new Ham4Parser.DFA26(this);
this.dfa33 = new Ham4Parser.DFA33(this);
this.dfa34 = new Ham4Parser.DFA34(this);
this.dfa35 = new Ham4Parser.DFA35(this);
this.dfa36 = new Ham4Parser.DFA36(this);
this.dfa49 = new Ham4Parser.DFA49(this);
this.dfa54 = new Ham4Parser.DFA54(this);
this.dfa56 = new Ham4Parser.DFA56(this);
this.dfa57 = new Ham4Parser.DFA57(this);
this.dfa58 = new Ham4Parser.DFA58(this);
this.dfa59 = new Ham4Parser.DFA59(this);
this.dfa60 = new Ham4Parser.DFA60(this);
this.dfa61 = new Ham4Parser.DFA61(this);
this.dfa92 = new Ham4Parser.DFA92(this);
this.dfa93 = new Ham4Parser.DFA93(this);
this.dfa95 = new Ham4Parser.DFA95(this);
this.dfa98 = new Ham4Parser.DFA98(this);
this.dfa97 = new Ham4Parser.DFA97(this);
this.dfa96 = new Ham4Parser.DFA96(this);
this.dfa102 = new Ham4Parser.DFA102(this);
this.dfa103 = new Ham4Parser.DFA103(this);
this.dfa104 = new Ham4Parser.DFA104(this);
this.dfa105 = new Ham4Parser.DFA105(this);
this.dfa106 = new Ham4Parser.DFA106(this);
this.dfa107 = new Ham4Parser.DFA107(this);
this.dfa108 = new Ham4Parser.DFA108(this);
this.dfa111 = new Ham4Parser.DFA111(this);
this.dfa109 = new Ham4Parser.DFA109(this);
this.dfa110 = new Ham4Parser.DFA110(this);
this.dfa112 = new Ham4Parser.DFA112(this);
this.dfa113 = new Ham4Parser.DFA113(this);
this.dfa114 = new Ham4Parser.DFA114(this);
this.dfa115 = new Ham4Parser.DFA115(this);
this.dfa116 = new Ham4Parser.DFA116(this);
this.dfa127 = new Ham4Parser.DFA127(this);
this.dfa128 = new Ham4Parser.DFA128(this);
this.dfa129 = new Ham4Parser.DFA129(this);
this.dfa130 = new Ham4Parser.DFA130(this);
this.dfa131 = new Ham4Parser.DFA131(this);
this.dfa132 = new Ham4Parser.DFA132(this);
this.dfa133 = new Ham4Parser.DFA133(this);
this.dfa134 = new Ham4Parser.DFA134(this);
this.dfa136 = new Ham4Parser.DFA136(this);
this.dfa137 = new Ham4Parser.DFA137(this);
this.dfa157 = new Ham4Parser.DFA157(this);
this.dfa171 = new Ham4Parser.DFA171(this);
this.dfa173 = new Ham4Parser.DFA173(this);
this.dfa180 = new Ham4Parser.DFA180(this);
this.dfa181 = new Ham4Parser.DFA181(this);
this.dfa182 = new Ham4Parser.DFA182(this);
/* @todo only create adaptor if output=AST */
this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
};
org.antlr.lang.augmentObject(Ham4Parser, {
EOF: -1,
WS: 4,
HamTab: 5,
HamLinefeed: 6,
HamPagebreak: 7,
HamReturn: 8,
HamVersion40: 9,
HamSpace: 10,
HamExclaim: 11,
HamQuery: 12,
HamFullstop: 13,
HamComma: 14,
HamPlus: 15,
HamMetaalt: 16,
HamClocku: 17,
HamClockul: 18,
HamClockl: 19,
HamClockdl: 20,
HamClockd: 21,
HamClockdr: 22,
HamClockr: 23,
HamClockur: 24,
HamClockfull: 25,
HamSymmpar: 26,
HamSymmlr: 27,
HamFist: 28,
HamFlathand: 29,
HamFinger2: 30,
HamFinger23: 31,
HamFinger23spread: 32,
HamFinger2345: 33,
HamThumboutmod: 34,
HamThumbacrossmod: 35,
HamPinch12: 36,
HamPinchall: 37,
HamPinch12open: 38,
HamCee12: 39,
HamCeeall: 40,
HamCee12open: 41,
HamThumbopenmod: 42,
HamFingerstraightmod: 43,
HamFingerbendmod: 44,
HamFingerhookedmod: 45,
HamNondominant: 46,
HamDoublebent: 47,
HamDoublehooked: 48,
HamExtfingeru: 49,
HamExtfingerur: 50,
HamExtfingerr: 51,
HamExtfingerdr: 52,
HamExtfingerd: 53,
HamExtfingerdl: 54,
HamExtfingerl: 55,
HamExtfingerul: 56,
HamExtfingerol: 57,
HamExtfingero: 58,
HamExtfingeror: 59,
HamExtfingeril: 60,
HamExtfingeri: 61,
HamExtfingerir: 62,
HamExtfingerui: 63,
HamExtfingerdi: 64,
HamExtfingerdo: 65,
HamExtfingeruo: 66,
HamEarlobe: 67,
HamNostrils: 68,
HamShouldertop: 69,
HamPalmu: 70,
HamPalmur: 71,
HamPalmr: 72,
HamPalmdr: 73,
HamPalmd: 74,
HamPalmdl: 75,
HamPalml: 76,
HamPalmul: 77,
HamReplace: 78,
HamArmextended: 79,
HamBehind: 80,
HamEtc: 81,
HamOrirelative: 82,
HamTongue: 83,
HamTeeth: 84,
HamStomach: 85,
HamNeutralspace: 86,
HamHead: 87,
HamHeadtop: 88,
HamForehead: 89,
HamEyebrows: 90,
HamEyes: 91,
HamNose: 92,
HamEar: 93,
HamCheek: 94,
HamLips: 95,
HamChin: 96,
HamUnderchin: 97,
HamNeck: 98,
HamShoulders: 99,
HamChest: 100,
HamBelowstomach: 101,
HamLrbeside: 102,
HamLrat: 103,
HamUpperarm: 104,
HamElbow: 105,
HamElbowinside: 106,
HamLowerarm: 107,
HamWristback: 108,
HamWristpulse: 109,
HamThumbball: 110,
HamPalm: 111,
HamHandback: 112,
HamThumb: 113,
HamIndexfinger: 114,
HamMiddlefinger: 115,
HamRingfinger: 116,
HamPinky: 117,
HamThumbside: 118,
HamPinkyside: 119,
HamBetween: 120,
HamFingertip: 121,
HamFingernail: 122,
HamFingerpad: 123,
HamFingermidjoint: 124,
HamFingerbase: 125,
HamFingerside: 126,
HamWristtopulse: 127,
HamWristtoback: 128,
HamWristtothumb: 129,
HamWristtopinky: 130,
HamCoreftag: 131,
HamCorefref: 132,
HamNomotion: 133,
HamMoveu: 134,
HamMoveur: 135,
HamMover: 136,
HamMovedr: 137,
HamMoved: 138,
HamMovedl: 139,
HamMovel: 140,
HamMoveul: 141,
HamMoveol: 142,
HamMoveo: 143,
HamMoveor: 144,
HamMoveil: 145,
HamMovei: 146,
HamMoveir: 147,
HamMoveui: 148,
HamMovedi: 149,
HamMovedo: 150,
HamMoveuo: 151,
HamMovecross: 152,
HamMovex: 153,
HamSmallmod: 154,
HamLargemod: 155,
HamArcl: 156,
HamArcu: 157,
HamArcr: 158,
HamArcd: 159,
HamWavy: 160,
HamZigzag: 161,
HamFingerplay: 162,
HamParbegin: 163,
HamParend: 164,
HamCircleo: 165,
HamCirclei: 166,
HamCircled: 167,
HamCircleu: 168,
HamCirclel: 169,
HamCircler: 170,
HamIncreasing: 171,
HamDecreasing: 172,
HamClose: 173,
HamTouch: 174,
HamInterlock: 175,
HamCross: 176,
HamFast: 177,
HamSlow: 178,
HamTense: 179,
HamRest: 180,
HamHalt: 181,
HamRepeatfromstart: 182,
HamRepeatfromstartseveral: 183,
HamRepeatcontinue: 184,
HamRepeatcontinueseveral: 185,
HamSeqbegin: 186,
HamSeqend: 187,
HamAlternatingmotion: 188,
HamRepeatreverse: 189,
HamBrushing: 190,
HamNonipsi: 191,
HamEllipseh: 192,
HamEllipseur: 193,
HamEllipsev: 194,
HamEllipseul: 195,
HamMime: 196,
HamAltbegin: 197,
HamAltend: 198,
HamNodding: 199,
HamSwinging: 200,
HamTwisting: 201,
HamStircw: 202,
HamStirccw: 203,
HamFusionbegin: 204,
HamFusionend: 205,
HamCircleul: 206,
HamCircledr: 207,
HamCircleur: 208,
HamCircledl: 209,
HamCircleol: 210,
HamCircleir: 211,
HamCircleor: 212,
HamCircleil: 213,
HamCircledo: 214,
HamCircleui: 215,
HamCircledi: 216,
HamCircleuo: 217,
HamNbs: 218,
HAMSIGNS: 219,
SIGN2: 220,
SIGN1: 221,
ICFG2: 222,
ICFG1: 223,
NMICLIST: 224,
NMICUNIT: 225,
MICFG2: 226,
MICFG1: 227,
HDCONFIG2: 228,
HDCONFIG1: 229,
SPLITHDCFG2: 230,
HDCFGTAIL2: 231,
HSHAPE2: 232,
HSHAPE1: 233,
BASICHDSHP1: 234,
BASICHDSHP: 235,
HSCLASS: 236,
FIBENDING: 237,
THUMBPOS: 238,
FINGERLIST: 239,
FISHPLIST: 240,
FICRSSLIST: 241,
FSHAPE: 242,
FCROSSING: 243,
THSPECIAL: 244,
EXTFIDIR2: 245,
EXTFIDIR1: 246,
EXTFIDIR: 247,
PALMOR2: 248,
PALMOR1: 249,
LOC2: 250,
LOC1: 251,
LOCTNBODYARM: 252,
LOCTNBODY: 253,
LOCTNHAND: 254,
LOCTNARM: 255,
LEVBODY: 256,
LEVHAND: 257,
LEVARM: 258,
HCONSTLLN: 259,
CNTCTBODY: 260,
CNTCTHAND: 261,
CNTCTOFHAND: 262,
A2TLIST: 263,
A1TLIST: 264,
A1LIST: 265,
ACTION2T: 266,
ACTION1T: 267,
ACTION2: 268,
ACTION1: 269,
PARACT2T: 270,
SEQACT2T: 271,
SPLITACT2LOC2: 272,
SPLITACT2T: 273,
PARACT1T: 274,
SEQACT1T: 275,
NMACT1T: 276,
PARACT1: 277,
REPETITIONS: 278,
SIMPLEMVMT: 279,
STRGHTMVMT: 280,
CRCLRMVMT: 281,
REPLACE: 282,
SPLITREPLACETL: 283,
REPLACETAIL1: 284,
HSFINGERITEM: 285,
LOCBODY: 286,
MOVINGREPETITION: 287,
SEQACT1: 288,
SEQFUSEDACT2T: 289,
SEQFUSEDACT1T: 290,
SEQFUSEDACT1: 291,
CNTCTOHHAND: 292,
CNTCTOHARM: 293
});
(function(){
// public class variables
var EOF= -1,
WS= 4,
HamTab= 5,
HamLinefeed= 6,
HamPagebreak= 7,
HamReturn= 8,
HamVersion40= 9,
HamSpace= 10,
HamExclaim= 11,
HamQuery= 12,
HamFullstop= 13,
HamComma= 14,
HamPlus= 15,
HamMetaalt= 16,
HamClocku= 17,
HamClockul= 18,
HamClockl= 19,
HamClockdl= 20,
HamClockd= 21,
HamClockdr= 22,
HamClockr= 23,
HamClockur= 24,
HamClockfull= 25,
HamSymmpar= 26,
HamSymmlr= 27,
HamFist= 28,
HamFlathand= 29,
HamFinger2= 30,
HamFinger23= 31,
HamFinger23spread= 32,
HamFinger2345= 33,
HamThumboutmod= 34,
HamThumbacrossmod= 35,
HamPinch12= 36,
HamPinchall= 37,
HamPinch12open= 38,
HamCee12= 39,
HamCeeall= 40,
HamCee12open= 41,
HamThumbopenmod= 42,
HamFingerstraightmod= 43,
HamFingerbendmod= 44,
HamFingerhookedmod= 45,
HamNondominant= 46,
HamDoublebent= 47,
HamDoublehooked= 48,
HamExtfingeru= 49,
HamExtfingerur= 50,
HamExtfingerr= 51,
HamExtfingerdr= 52,
HamExtfingerd= 53,
HamExtfingerdl= 54,
HamExtfingerl= 55,
HamExtfingerul= 56,
HamExtfingerol= 57,
HamExtfingero= 58,
HamExtfingeror= 59,
HamExtfingeril= 60,
HamExtfingeri= 61,
HamExtfingerir= 62,
HamExtfingerui= 63,
HamExtfingerdi= 64,
HamExtfingerdo= 65,
HamExtfingeruo= 66,
HamEarlobe= 67,
HamNostrils= 68,
HamShouldertop= 69,
HamPalmu= 70,
HamPalmur= 71,
HamPalmr= 72,
HamPalmdr= 73,
HamPalmd= 74,
HamPalmdl= 75,
HamPalml= 76,
HamPalmul= 77,
HamReplace= 78,
HamArmextended= 79,
HamBehind= 80,
HamEtc= 81,
HamOrirelative= 82,
HamTongue= 83,
HamTeeth= 84,
HamStomach= 85,
HamNeutralspace= 86,
HamHead= 87,
HamHeadtop= 88,
HamForehead= 89,
HamEyebrows= 90,
HamEyes= 91,
HamNose= 92,
HamEar= 93,
HamCheek= 94,
HamLips= 95,
HamChin= 96,
HamUnderchin= 97,
HamNeck= 98,
HamShoulders= 99,
HamChest= 100,
HamBelowstomach= 101,
HamLrbeside= 102,
HamLrat= 103,
HamUpperarm= 104,
HamElbow= 105,
HamElbowinside= 106,
HamLowerarm= 107,
HamWristback= 108,
HamWristpulse= 109,
HamThumbball= 110,
HamPalm= 111,
HamHandback= 112,
HamThumb= 113,
HamIndexfinger= 114,
HamMiddlefinger= 115,
HamRingfinger= 116,
HamPinky= 117,
HamThumbside= 118,
HamPinkyside= 119,
HamBetween= 120,
HamFingertip= 121,
HamFingernail= 122,
HamFingerpad= 123,
HamFingermidjoint= 124,
HamFingerbase= 125,
HamFingerside= 126,
HamWristtopulse= 127,
HamWristtoback= 128,
HamWristtothumb= 129,
HamWristtopinky= 130,
HamCoreftag= 131,
HamCorefref= 132,
HamNomotion= 133,
HamMoveu= 134,
HamMoveur= 135,
HamMover= 136,
HamMovedr= 137,
HamMoved= 138,
HamMovedl= 139,
HamMovel= 140,
HamMoveul= 141,
HamMoveol= 142,
HamMoveo= 143,
HamMoveor= 144,
HamMoveil= 145,
HamMovei= 146,
HamMoveir= 147,
HamMoveui= 148,
HamMovedi= 149,
HamMovedo= 150,
HamMoveuo= 151,
HamMovecross= 152,
HamMovex= 153,
HamSmallmod= 154,
HamLargemod= 155,
HamArcl= 156,
HamArcu= 157,
HamArcr= 158,
HamArcd= 159,
HamWavy= 160,
HamZigzag= 161,
HamFingerplay= 162,
HamParbegin= 163,
HamParend= 164,
HamCircleo= 165,
HamCirclei= 166,
HamCircled= 167,
HamCircleu= 168,
HamCirclel= 169,
HamCircler= 170,
HamIncreasing= 171,
HamDecreasing= 172,
HamClose= 173,
HamTouch= 174,
HamInterlock= 175,
HamCross= 176,
HamFast= 177,
HamSlow= 178,
HamTense= 179,
HamRest= 180,
HamHalt= 181,
HamRepeatfromstart= 182,
HamRepeatfromstartseveral= 183,
HamRepeatcontinue= 184,
HamRepeatcontinueseveral= 185,
HamSeqbegin= 186,
HamSeqend= 187,
HamAlternatingmotion= 188,
HamRepeatreverse= 189,
HamBrushing= 190,
HamNonipsi= 191,
HamEllipseh= 192,
HamEllipseur= 193,
HamEllipsev= 194,
HamEllipseul= 195,
HamMime= 196,
HamAltbegin= 197,
HamAltend= 198,
HamNodding= 199,
HamSwinging= 200,
HamTwisting= 201,
HamStircw= 202,
HamStirccw= 203,
HamFusionbegin= 204,
HamFusionend= 205,
HamCircleul= 206,
HamCircledr= 207,
HamCircleur= 208,
HamCircledl= 209,
HamCircleol= 210,
HamCircleir= 211,
HamCircleor= 212,
HamCircleil= 213,
HamCircledo= 214,
HamCircleui= 215,
HamCircledi= 216,
HamCircleuo= 217,
HamNbs= 218,
HAMSIGNS= 219,
SIGN2= 220,
SIGN1= 221,
ICFG2= 222,
ICFG1= 223,
NMICLIST= 224,
NMICUNIT= 225,
MICFG2= 226,
MICFG1= 227,
HDCONFIG2= 228,
HDCONFIG1= 229,
SPLITHDCFG2= 230,
HDCFGTAIL2= 231,
HSHAPE2= 232,
HSHAPE1= 233,
BASICHDSHP1= 234,
BASICHDSHP= 235,
HSCLASS= 236,
FIBENDING= 237,
THUMBPOS= 238,
FINGERLIST= 239,
FISHPLIST= 240,
FICRSSLIST= 241,
FSHAPE= 242,
FCROSSING= 243,
THSPECIAL= 244,
EXTFIDIR2= 245,
EXTFIDIR1= 246,
EXTFIDIR= 247,
PALMOR2= 248,
PALMOR1= 249,
LOC2= 250,
LOC1= 251,
LOCTNBODYARM= 252,
LOCTNBODY= 253,
LOCTNHAND= 254,
LOCTNARM= 255,
LEVBODY= 256,
LEVHAND= 257,
LEVARM= 258,
HCONSTLLN= 259,
CNTCTBODY= 260,
CNTCTHAND= 261,
CNTCTOFHAND= 262,
A2TLIST= 263,
A1TLIST= 264,
A1LIST= 265,
ACTION2T= 266,
ACTION1T= 267,
ACTION2= 268,
ACTION1= 269,
PARACT2T= 270,
SEQACT2T= 271,
SPLITACT2LOC2= 272,
SPLITACT2T= 273,
PARACT1T= 274,
SEQACT1T= 275,
NMACT1T= 276,
PARACT1= 277,
REPETITIONS= 278,
SIMPLEMVMT= 279,
STRGHTMVMT= 280,
CRCLRMVMT= 281,
REPLACE= 282,
SPLITREPLACETL= 283,
REPLACETAIL1= 284,
HSFINGERITEM= 285,
LOCBODY= 286,
MOVINGREPETITION= 287,
SEQACT1= 288,
SEQFUSEDACT2T= 289,
SEQFUSEDACT1T= 290,
SEQFUSEDACT1= 291,
CNTCTOHHAND= 292,
CNTCTOHARM= 293;
// public instance methods/vars
org.antlr.lang.extend(Ham4Parser, org.antlr.runtime.Parser, {
setTreeAdaptor: function(adaptor) {
this.adaptor = adaptor;
},
getTreeAdaptor: function() {
return this.adaptor;
},
getTokenNames: function() { return Ham4Parser.tokenNames; },
getGrammarFileName: function() { return "Ham4Parser.g"; }
});
org.antlr.lang.augmentObject(Ham4Parser.prototype, {
// inline static return class
hamsinglesign_return: (function() {
Ham4Parser.hamsinglesign_return = function(){};
org.antlr.lang.extend(Ham4Parser.hamsinglesign_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:192:1: hamsinglesign : hamsignseq EOF -> ^( HAMSIGNS ( hamsignseq )? ) ;
// $ANTLR start "hamsinglesign"
hamsinglesign: function() {
var retval = new Ham4Parser.hamsinglesign_return();
retval.start = this.input.LT(1);
var root_0 = null;
var EOF2 = null;
var hamsignseq1 = null;
var EOF2_tree=null;
var stream_EOF=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EOF");
var stream_hamsignseq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule hamsignseq");
try {
// Ham4Parser.g:193:2: ( hamsignseq EOF -> ^( HAMSIGNS ( hamsignseq )? ) )
// Ham4Parser.g:193:6: hamsignseq EOF
this.pushFollow(Ham4Parser.FOLLOW_hamsignseq_in_hamsinglesign735);
hamsignseq1=this.hamsignseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_hamsignseq.add(hamsignseq1.getTree());
EOF2=this.match(this.input,EOF,Ham4Parser.FOLLOW_EOF_in_hamsinglesign745); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_EOF.add(EOF2);
// AST REWRITE
// elements: hamsignseq
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 196:2: -> ^( HAMSIGNS ( hamsignseq )? )
{
// Ham4Parser.g:196:5: ^( HAMSIGNS ( hamsignseq )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HAMSIGNS, "HAMSIGNS"), root_1);
// Ham4Parser.g:196:16: ( hamsignseq )?
if ( stream_hamsignseq.hasNext() ) {
this.adaptor.addChild(root_1, stream_hamsignseq.nextTree());
}
stream_hamsignseq.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hamsignseq_return: (function() {
Ham4Parser.hamsignseq_return = function(){};
org.antlr.lang.extend(Ham4Parser.hamsignseq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:202:1: hamsignseq : ( sign2or1 ( HamPlus sign2or1 )* )? ;
// $ANTLR start "hamsignseq"
hamsignseq: function() {
var retval = new Ham4Parser.hamsignseq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamPlus4 = null;
var sign2or13 = null;
var sign2or15 = null;
var HamPlus4_tree=null;
this.trace("ANTLR Parse: hamsignseq starts "+this.state.backtracking);
try {
// Ham4Parser.g:223:5: ( ( sign2or1 ( HamPlus sign2or1 )* )? )
// Ham4Parser.g:224:9: ( sign2or1 ( HamPlus sign2or1 )* )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:224:9: ( sign2or1 ( HamPlus sign2or1 )* )?
var alt2=2;
var LA2_0 = this.input.LA(1);
if ( ((LA2_0>=HamSymmpar && LA2_0<=HamFinger2345)||(LA2_0>=HamPinch12 && LA2_0<=HamCee12open)||LA2_0==HamNondominant||LA2_0==HamNomotion||LA2_0==HamParbegin||LA2_0==HamSeqbegin) ) {
alt2=1;
}
switch (alt2) {
case 1 :
// Ham4Parser.g:225:13: sign2or1 ( HamPlus sign2or1 )*
this.pushFollow(Ham4Parser.FOLLOW_sign2or1_in_hamsignseq813);
sign2or13=this.sign2or1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign2or13.getTree());
// Ham4Parser.g:226:13: ( HamPlus sign2or1 )*
loop1:
do {
var alt1=2;
var LA1_0 = this.input.LA(1);
if ( (LA1_0==HamPlus) ) {
alt1=1;
}
switch (alt1) {
case 1 :
// Ham4Parser.g:227:17: HamPlus sign2or1
HamPlus4=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_hamsignseq845); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_sign2or1_in_hamsignseq865);
sign2or15=this.sign2or1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign2or15.getTree());
break;
default :
break loop1;
}
} while (true);
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hamsignseq finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sign2or1_return: (function() {
Ham4Parser.sign2or1_return = function(){};
org.antlr.lang.extend(Ham4Parser.sign2or1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:233:1: sign2or1 : ( ( HamNondominant initialconfig1 )=> nondomsign1 | sign2 );
// $ANTLR start "sign2or1"
sign2or1: function() {
var retval = new Ham4Parser.sign2or1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nondomsign16 = null;
var sign27 = null;
this.trace("ANTLR Parse: sign2or1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:252:5: ( ( HamNondominant initialconfig1 )=> nondomsign1 | sign2 )
var alt3=2;
var LA3_0 = this.input.LA(1);
if ( (LA3_0==HamNondominant) ) {
var LA3_1 = this.input.LA(2);
if ( (this.synpred1_Ham4Parser()) ) {
alt3=1;
}
else if ( (true) ) {
alt3=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 3, 1, this.input);
throw nvae;
}
}
else if ( ((LA3_0>=HamSymmpar && LA3_0<=HamFinger2345)||(LA3_0>=HamPinch12 && LA3_0<=HamCee12open)||LA3_0==HamNomotion||LA3_0==HamParbegin||LA3_0==HamSeqbegin) ) {
alt3=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 3, 0, this.input);
throw nvae;
}
switch (alt3) {
case 1 :
// Ham4Parser.g:253:9: ( HamNondominant initialconfig1 )=> nondomsign1
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_nondomsign1_in_sign2or1952);
nondomsign16=this.nondomsign1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, nondomsign16.getTree());
break;
case 2 :
// Ham4Parser.g:257:9: sign2
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_sign2_in_sign2or1968);
sign27=this.sign2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign27.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sign2or1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sign2_return: (function() {
Ham4Parser.sign2_return = function(){};
org.antlr.lang.extend(Ham4Parser.sign2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:260:1: sign2 : ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) ) ;
// $ANTLR start "sign2"
sign2: function() {
var retval = new Ham4Parser.sign2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNomotion13 = null;
var HamNondominant14 = null;
var HamNomotion17 = null;
var symmoperator8 = null;
var initialconfig29 = null;
var a2tstar10 = null;
var initialconfig211 = null;
var a1tstar12 = null;
var initialconfig115 = null;
var a1tstar16 = null;
var initialconfig118 = null;
var a1tstar19 = null;
var HamNomotion13_tree=null;
var HamNondominant14_tree=null;
var HamNomotion17_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_symmoperator=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule symmoperator");
var stream_a2tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a2tstar");
var stream_initialconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig2");
var stream_a1tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tstar");
var stream_initialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig1");
this.trace("ANTLR Parse: sign2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:304:5: ( ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) ) )
// Ham4Parser.g:305:5: ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) )
// Ham4Parser.g:305:5: ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) )
var alt4=4;
switch ( this.input.LA(1) ) {
case HamSymmpar:
case HamSymmlr:
alt4=1;
break;
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
case HamNondominant:
case HamParbegin:
case HamSeqbegin:
alt4=2;
break;
case HamNomotion:
var LA4_6 = this.input.LA(2);
if ( (this.synpred2_Ham4Parser()) ) {
alt4=3;
}
else if ( (true) ) {
alt4=4;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 6, this.input);
throw nvae;
}
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);
throw nvae;
}
switch (alt4) {
case 1 :
// Ham4Parser.g:306:9: symmoperator initialconfig2 a2tstar
this.pushFollow(Ham4Parser.FOLLOW_symmoperator_in_sign21009);
symmoperator8=this.symmoperator();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_symmoperator.add(symmoperator8.getTree());
this.pushFollow(Ham4Parser.FOLLOW_initialconfig2_in_sign21019);
initialconfig29=this.initialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig2.add(initialconfig29.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a2tstar_in_sign21029);
a2tstar10=this.a2tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a2tstar.add(a2tstar10.getTree());
// AST REWRITE
// elements: initialconfig2, symmoperator, a2tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 309:6: -> ^( SIGN2 symmoperator initialconfig2 a2tstar )
{
// Ham4Parser.g:309:9: ^( SIGN2 symmoperator initialconfig2 a2tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_symmoperator.nextTree());
this.adaptor.addChild(root_1, stream_initialconfig2.nextTree());
this.adaptor.addChild(root_1, stream_a2tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:311:9: initialconfig2 a1tstar
this.pushFollow(Ham4Parser.FOLLOW_initialconfig2_in_sign21062);
initialconfig211=this.initialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig2.add(initialconfig211.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21072);
a1tstar12=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar12.getTree());
// AST REWRITE
// elements: initialconfig2, a1tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 313:6: -> ^( SIGN2 initialconfig2 a1tstar )
{
// Ham4Parser.g:313:9: ^( SIGN2 initialconfig2 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_initialconfig2.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:322:9: ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar
HamNomotion13=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_sign21138); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion13);
HamNondominant14=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_sign21148); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant14);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_sign21158);
initialconfig115=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig115.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21168);
a1tstar16=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar16.getTree());
// AST REWRITE
// elements: a1tstar, HamNomotion, HamNondominant, initialconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 328:6: -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar )
{
// Ham4Parser.g:328:9: ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:330:9: HamNomotion initialconfig1 a1tstar
HamNomotion17=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_sign21203); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion17);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_sign21213);
initialconfig118=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig118.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21223);
a1tstar19=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar19.getTree());
// AST REWRITE
// elements: initialconfig1, a1tstar, HamNomotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 333:6: -> ^( SIGN2 HamNomotion initialconfig1 a1tstar )
{
// Ham4Parser.g:333:9: ^( SIGN2 HamNomotion initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sign2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nondomsign1_return: (function() {
Ham4Parser.nondomsign1_return = function(){};
org.antlr.lang.extend(Ham4Parser.nondomsign1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:337:1: nondomsign1 : HamNondominant initialconfig1 a1tstar -> ^( SIGN1 HamNondominant initialconfig1 a1tstar ) ;
// $ANTLR start "nondomsign1"
nondomsign1: function() {
var retval = new Ham4Parser.nondomsign1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNondominant20 = null;
var initialconfig121 = null;
var a1tstar22 = null;
var HamNondominant20_tree=null;
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_initialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig1");
var stream_a1tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tstar");
this.trace("ANTLR Parse: nondomsign1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:355:5: ( HamNondominant initialconfig1 a1tstar -> ^( SIGN1 HamNondominant initialconfig1 a1tstar ) )
// Ham4Parser.g:355:9: HamNondominant initialconfig1 a1tstar
HamNondominant20=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_nondomsign11275); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant20);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_nondomsign11285);
initialconfig121=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig121.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_nondomsign11295);
a1tstar22=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar22.getTree());
// AST REWRITE
// elements: HamNondominant, initialconfig1, a1tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 359:9: -> ^( SIGN1 HamNondominant initialconfig1 a1tstar )
{
// Ham4Parser.g:359:12: ^( SIGN1 HamNondominant initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN1, "SIGN1"), root_1);
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nondomsign1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
symmoperator_return: (function() {
Ham4Parser.symmoperator_return = function(){};
org.antlr.lang.extend(Ham4Parser.symmoperator_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:362:1: symmoperator : ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ;
// $ANTLR start "symmoperator"
symmoperator: function() {
var retval = new Ham4Parser.symmoperator_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set23 = null;
var HamFingerstraightmod24 = null;
var HamLargemod25 = null;
var HamLargemod26 = null;
var HamFingerstraightmod27 = null;
var HamAlternatingmotion28 = null;
var HamNonipsi29 = null;
var set23_tree=null;
var HamFingerstraightmod24_tree=null;
var HamLargemod25_tree=null;
var HamLargemod26_tree=null;
var HamFingerstraightmod27_tree=null;
var HamAlternatingmotion28_tree=null;
var HamNonipsi29_tree=null;
this.trace("ANTLR Parse: symmoperator starts "+this.state.backtracking);
try {
// Ham4Parser.g:389:5: ( ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4Parser.g:389:9: ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )?
root_0 = this.adaptor.nil();
set23=this.input.LT(1);
if ( (this.input.LA(1)>=HamSymmpar && this.input.LA(1)<=HamSymmlr) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set23));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:394:9: ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )?
var alt7=3;
var LA7_0 = this.input.LA(1);
if ( (LA7_0==HamFingerstraightmod) ) {
alt7=1;
}
else if ( (LA7_0==HamLargemod) ) {
alt7=2;
}
switch (alt7) {
case 1 :
// Ham4Parser.g:395:13: HamFingerstraightmod ( HamLargemod )?
HamFingerstraightmod24=this.match(this.input,HamFingerstraightmod,Ham4Parser.FOLLOW_HamFingerstraightmod_in_symmoperator1425); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamFingerstraightmod24_tree = this.adaptor.create(HamFingerstraightmod24);
this.adaptor.addChild(root_0, HamFingerstraightmod24_tree);
}
// Ham4Parser.g:396:13: ( HamLargemod )?
var alt5=2;
var LA5_0 = this.input.LA(1);
if ( (LA5_0==HamLargemod) ) {
alt5=1;
}
switch (alt5) {
case 1 :
// Ham4Parser.g:396:15: HamLargemod
HamLargemod25=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_symmoperator1441); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamLargemod25_tree = this.adaptor.create(HamLargemod25);
this.adaptor.addChild(root_0, HamLargemod25_tree);
}
break;
}
break;
case 2 :
// Ham4Parser.g:398:13: HamLargemod ( HamFingerstraightmod )?
HamLargemod26=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_symmoperator1468); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamLargemod26_tree = this.adaptor.create(HamLargemod26);
this.adaptor.addChild(root_0, HamLargemod26_tree);
}
// Ham4Parser.g:399:13: ( HamFingerstraightmod )?
var alt6=2;
var LA6_0 = this.input.LA(1);
if ( (LA6_0==HamFingerstraightmod) ) {
alt6=1;
}
switch (alt6) {
case 1 :
// Ham4Parser.g:399:15: HamFingerstraightmod
HamFingerstraightmod27=this.match(this.input,HamFingerstraightmod,Ham4Parser.FOLLOW_HamFingerstraightmod_in_symmoperator1484); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamFingerstraightmod27_tree = this.adaptor.create(HamFingerstraightmod27);
this.adaptor.addChild(root_0, HamFingerstraightmod27_tree);
}
break;
}
break;
}
// Ham4Parser.g:401:9: ( HamAlternatingmotion )?
var alt8=2;
var LA8_0 = this.input.LA(1);
if ( (LA8_0==HamAlternatingmotion) ) {
alt8=1;
}
switch (alt8) {
case 1 :
// Ham4Parser.g:401:11: HamAlternatingmotion
HamAlternatingmotion28=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_symmoperator1510); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion28_tree = this.adaptor.create(HamAlternatingmotion28);
this.adaptor.addChild(root_0, HamAlternatingmotion28_tree);
}
break;
}
// Ham4Parser.g:402:9: ( HamNonipsi )?
var alt9=2;
var LA9_0 = this.input.LA(1);
if ( (LA9_0==HamNonipsi) ) {
alt9=1;
}
switch (alt9) {
case 1 :
// Ham4Parser.g:402:11: HamNonipsi
HamNonipsi29=this.match(this.input,HamNonipsi,Ham4Parser.FOLLOW_HamNonipsi_in_symmoperator1525); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNonipsi29_tree = this.adaptor.create(HamNonipsi29);
this.adaptor.addChild(root_0, HamNonipsi29_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: symmoperator finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
initialconfig2_return: (function() {
Ham4Parser.initialconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.initialconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:408:1: initialconfig2 : ( nminitialconfig )? minitialconfig2 -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 ) ;
// $ANTLR start "initialconfig2"
initialconfig2: function() {
var retval = new Ham4Parser.initialconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nminitialconfig30 = null;
var minitialconfig231 = null;
var stream_minitialconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minitialconfig2");
var stream_nminitialconfig=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nminitialconfig");
this.trace("ANTLR Parse: initialconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:425:5: ( ( nminitialconfig )? minitialconfig2 -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 ) )
// Ham4Parser.g:425:9: ( nminitialconfig )? minitialconfig2
// Ham4Parser.g:425:9: ( nminitialconfig )?
var alt10=2;
var LA10_0 = this.input.LA(1);
if ( (LA10_0==HamSeqbegin) ) {
alt10=1;
}
switch (alt10) {
case 1 :
// Ham4Parser.g:425:11: nminitialconfig
this.pushFollow(Ham4Parser.FOLLOW_nminitialconfig_in_initialconfig21562);
nminitialconfig30=this.nminitialconfig();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nminitialconfig.add(nminitialconfig30.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_minitialconfig2_in_initialconfig21575);
minitialconfig231=this.minitialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_minitialconfig2.add(minitialconfig231.getTree());
// AST REWRITE
// elements: minitialconfig2, nminitialconfig
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 428:9: -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 )
{
// Ham4Parser.g:428:12: ^( ICFG2 ( nminitialconfig )? minitialconfig2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ICFG2, "ICFG2"), root_1);
// Ham4Parser.g:428:20: ( nminitialconfig )?
if ( stream_nminitialconfig.hasNext() ) {
this.adaptor.addChild(root_1, stream_nminitialconfig.nextTree());
}
stream_nminitialconfig.reset();
this.adaptor.addChild(root_1, stream_minitialconfig2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: initialconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
initialconfig1_return: (function() {
Ham4Parser.initialconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.initialconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:431:1: initialconfig1 : ( nminitialconfig )? minitialconfig1 -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 ) ;
// $ANTLR start "initialconfig1"
initialconfig1: function() {
var retval = new Ham4Parser.initialconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nminitialconfig32 = null;
var minitialconfig133 = null;
var stream_minitialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minitialconfig1");
var stream_nminitialconfig=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nminitialconfig");
this.trace("ANTLR Parse: initialconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:448:5: ( ( nminitialconfig )? minitialconfig1 -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 ) )
// Ham4Parser.g:448:9: ( nminitialconfig )? minitialconfig1
// Ham4Parser.g:448:9: ( nminitialconfig )?
var alt11=2;
var LA11_0 = this.input.LA(1);
if ( (LA11_0==HamSeqbegin) ) {
alt11=1;
}
switch (alt11) {
case 1 :
// Ham4Parser.g:448:11: nminitialconfig
this.pushFollow(Ham4Parser.FOLLOW_nminitialconfig_in_initialconfig11634);
nminitialconfig32=this.nminitialconfig();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nminitialconfig.add(nminitialconfig32.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_minitialconfig1_in_initialconfig11647);
minitialconfig133=this.minitialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_minitialconfig1.add(minitialconfig133.getTree());
// AST REWRITE
// elements: minitialconfig1, nminitialconfig
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 451:9: -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 )
{
// Ham4Parser.g:451:12: ^( ICFG1 ( nminitialconfig )? minitialconfig1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ICFG1, "ICFG1"), root_1);
// Ham4Parser.g:451:20: ( nminitialconfig )?
if ( stream_nminitialconfig.hasNext() ) {
this.adaptor.addChild(root_1, stream_nminitialconfig.nextTree());
}
stream_nminitialconfig.reset();
this.adaptor.addChild(root_1, stream_minitialconfig1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: initialconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nminitialconfig_return: (function() {
Ham4Parser.nminitialconfig_return = function(){};
org.antlr.lang.extend(Ham4Parser.nminitialconfig_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:454:1: nminitialconfig : ( nmicunit )+ -> ^( NMICLIST ( nmicunit )* ) ;
// $ANTLR start "nminitialconfig"
nminitialconfig: function() {
var retval = new Ham4Parser.nminitialconfig_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nmicunit34 = null;
var stream_nmicunit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nmicunit");
this.trace("ANTLR Parse: nminitialconfig starts "+this.state.backtracking);
try {
// Ham4Parser.g:471:5: ( ( nmicunit )+ -> ^( NMICLIST ( nmicunit )* ) )
// Ham4Parser.g:471:9: ( nmicunit )+
// Ham4Parser.g:471:9: ( nmicunit )+
var cnt12=0;
loop12:
do {
var alt12=2;
var LA12_0 = this.input.LA(1);
if ( (LA12_0==HamSeqbegin) ) {
alt12=1;
}
switch (alt12) {
case 1 :
// Ham4Parser.g:472:13: nmicunit
this.pushFollow(Ham4Parser.FOLLOW_nmicunit_in_nminitialconfig1718);
nmicunit34=this.nmicunit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nmicunit.add(nmicunit34.getTree());
break;
default :
if ( cnt12 >= 1 ) {
break loop12;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(12, this.input);
throw eee;
}
cnt12++;
} while (true);
// AST REWRITE
// elements: nmicunit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 474:9: -> ^( NMICLIST ( nmicunit )* )
{
// Ham4Parser.g:474:12: ^( NMICLIST ( nmicunit )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMICLIST, "NMICLIST"), root_1);
// Ham4Parser.g:474:23: ( nmicunit )*
while ( stream_nmicunit.hasNext() ) {
this.adaptor.addChild(root_1, stream_nmicunit.nextTree());
}
stream_nmicunit.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nminitialconfig finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nmicunit_return: (function() {
Ham4Parser.nmicunit_return = function(){};
org.antlr.lang.extend(Ham4Parser.nmicunit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:477:1: nmicunit : HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 ) ;
// $ANTLR start "nmicunit"
nmicunit: function() {
var retval = new Ham4Parser.nmicunit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin35 = null;
var HamSeqend39 = null;
var levelbody36 = null;
var levelarm37 = null;
var action138 = null;
var HamSeqbegin35_tree=null;
var HamSeqend39_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_levelbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelbody");
var stream_levelarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelarm");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: nmicunit starts "+this.state.backtracking);
try {
// Ham4Parser.g:501:5: ( HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 ) )
// Ham4Parser.g:502:9: HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend
HamSeqbegin35=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_nmicunit1781); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin35);
// Ham4Parser.g:503:9: ( ( levelbody )=> levelbody | levelarm )
var alt13=2;
alt13 = this.dfa13.predict(this.input);
switch (alt13) {
case 1 :
// Ham4Parser.g:504:11: ( levelbody )=> levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_nmicunit1812);
levelbody36=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelbody.add(levelbody36.getTree());
break;
case 2 :
// Ham4Parser.g:506:11: levelarm
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_nmicunit1834);
levelarm37=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelarm.add(levelarm37.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_action1_in_nmicunit1854);
action138=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action138.getTree());
HamSeqend39=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_nmicunit1864); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend39);
// AST REWRITE
// elements: levelbody, action1, levelarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 511:9: -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 )
{
// Ham4Parser.g:511:12: ^( NMICUNIT ( levelbody )? ( levelarm )? action1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMICUNIT, "NMICUNIT"), root_1);
// Ham4Parser.g:511:23: ( levelbody )?
if ( stream_levelbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelbody.nextTree());
}
stream_levelbody.reset();
// Ham4Parser.g:511:34: ( levelarm )?
if ( stream_levelarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelarm.nextTree());
}
stream_levelarm.reset();
this.adaptor.addChild(root_1, stream_action1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nmicunit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
minitialconfig2_return: (function() {
Ham4Parser.minitialconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.minitialconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:515:1: minitialconfig2 : ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) ) ;
// $ANTLR start "minitialconfig2"
minitialconfig2: function() {
var retval = new Ham4Parser.minitialconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin42 = null;
var HamPlus44 = null;
var HamParend46 = null;
var HamPlus47 = null;
var HamParend48 = null;
var loc = null;
var ploc = null;
var handconfig240 = null;
var location241 = null;
var handconfig143 = null;
var location145 = null;
var HamParbegin42_tree=null;
var HamPlus44_tree=null;
var HamParend46_tree=null;
var HamPlus47_tree=null;
var HamParend48_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_location2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
var stream_handconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig2");
this.trace("ANTLR Parse: minitialconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:559:5: ( ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) ) )
// Ham4Parser.g:560:5: ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) )
// Ham4Parser.g:560:5: ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) )
var alt17=2;
var LA17_0 = this.input.LA(1);
if ( ((LA17_0>=HamFist && LA17_0<=HamFinger2345)||(LA17_0>=HamPinch12 && LA17_0<=HamCee12open)) && (this.synpred4_Ham4Parser())) {
alt17=1;
}
else if ( (LA17_0==HamNondominant) && (this.synpred4_Ham4Parser())) {
alt17=1;
}
else if ( (LA17_0==HamParbegin) ) {
var LA17_3 = this.input.LA(2);
if ( (this.synpred4_Ham4Parser()) ) {
alt17=1;
}
else if ( (true) ) {
alt17=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 17, 3, this.input);
throw nvae;
}
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 17, 0, this.input);
throw nvae;
}
switch (alt17) {
case 1 :
// Ham4Parser.g:561:9: ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )?
this.pushFollow(Ham4Parser.FOLLOW_handconfig2_in_minitialconfig21965);
handconfig240=this.handconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig2.add(handconfig240.getTree());
// Ham4Parser.g:564:9: ( ( location2 )=> location2 )?
var alt14=2;
alt14 = this.dfa14.predict(this.input);
switch (alt14) {
case 1 :
// Ham4Parser.g:565:13: ( location2 )=> location2
this.pushFollow(Ham4Parser.FOLLOW_location2_in_minitialconfig22021);
location241=this.location2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2.add(location241.getTree());
break;
}
// AST REWRITE
// elements: location2, handconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 569:6: -> ^( MICFG2 handconfig2 ( location2 )? )
{
// Ham4Parser.g:569:9: ^( MICFG2 handconfig2 ( location2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig2.nextTree());
// Ham4Parser.g:569:30: ( location2 )?
if ( stream_location2.hasNext() ) {
this.adaptor.addChild(root_1, stream_location2.nextTree());
}
stream_location2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:571:9: HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )
HamParbegin42=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_minitialconfig22064); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin42);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_minitialconfig22075);
handconfig143=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig143.getTree());
// Ham4Parser.g:573:9: ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )
var alt16=2;
alt16 = this.dfa16.predict(this.input);
switch (alt16) {
case 1 :
// Ham4Parser.g:574:13: ( HamPlus )=> HamPlus location1 HamParend
HamPlus44=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_minitialconfig22131); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus44);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22146);
location145=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location145.getTree());
HamParend46=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_minitialconfig22160); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend46);
// AST REWRITE
// elements: HamPlus, handconfig1, location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 580:6: -> ^( MICFG2 handconfig1 HamPlus location1 )
{
// Ham4Parser.g:580:9: ^( MICFG2 handconfig1 HamPlus location1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_location1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:582:13: loc= location1 HamPlus (ploc= location1 )? HamParend
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22204);
loc=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(loc.getTree());
HamPlus47=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_minitialconfig22218); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus47);
// Ham4Parser.g:585:13: (ploc= location1 )?
var alt15=2;
alt15 = this.dfa15.predict(this.input);
switch (alt15) {
case 1 :
// Ham4Parser.g:585:15: ploc= location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22237);
ploc=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(ploc.getTree());
break;
}
HamParend48=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_minitialconfig22254); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend48);
// AST REWRITE
// elements: handconfig1, loc, HamPlus, ploc
// token labels: 
// rule labels: loc, ploc, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_loc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token loc",loc!=null?loc.tree:null);
var stream_ploc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token ploc",ploc!=null?ploc.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 587:6: -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? )
{
// Ham4Parser.g:587:9: ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
this.adaptor.addChild(root_1, stream_loc.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
// Ham4Parser.g:587:43: ( $ploc)?
if ( stream_ploc.hasNext() ) {
this.adaptor.addChild(root_1, stream_ploc.nextTree());
}
stream_ploc.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: minitialconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
minitialconfig1_return: (function() {
Ham4Parser.minitialconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.minitialconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:592:1: minitialconfig1 : handconfig1 ( location1 )? -> ^( MICFG1 handconfig1 ( location1 )? ) ;
// $ANTLR start "minitialconfig1"
minitialconfig1: function() {
var retval = new Ham4Parser.minitialconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handconfig149 = null;
var location150 = null;
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
this.trace("ANTLR Parse: minitialconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:610:5: ( handconfig1 ( location1 )? -> ^( MICFG1 handconfig1 ( location1 )? ) )
// Ham4Parser.g:611:9: handconfig1 ( location1 )?
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_minitialconfig12328);
handconfig149=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig149.getTree());
// Ham4Parser.g:612:9: ( location1 )?
var alt18=2;
alt18 = this.dfa18.predict(this.input);
switch (alt18) {
case 1 :
// Ham4Parser.g:612:11: location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig12340);
location150=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location150.getTree());
break;
}
// AST REWRITE
// elements: handconfig1, location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 614:6: -> ^( MICFG1 handconfig1 ( location1 )? )
{
// Ham4Parser.g:614:9: ^( MICFG1 handconfig1 ( location1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG1, "MICFG1"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
// Ham4Parser.g:614:30: ( location1 )?
if ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: minitialconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfig2_return: (function() {
Ham4Parser.handconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:620:1: handconfig2 : ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) ) ;
// $ANTLR start "handconfig2"
handconfig2: function() {
var retval = new Ham4Parser.handconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshape251 = null;
var handconfigtail252 = null;
var handshape253 = null;
var splithandconfig254 = null;
var stream_handshape2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape2");
var stream_handconfigtail2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfigtail2");
var stream_splithandconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splithandconfig2");
this.trace("ANTLR Parse: handconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:649:5: ( ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) ) )
// Ham4Parser.g:650:5: ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) )
// Ham4Parser.g:650:5: ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) )
var alt19=3;
switch ( this.input.LA(1) ) {
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
var LA19_1 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 1, this.input);
throw nvae;
}
break;
case HamNondominant:
var LA19_2 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 2, this.input);
throw nvae;
}
break;
case HamParbegin:
var LA19_3 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else if ( (true) ) {
alt19=3;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 3, this.input);
throw nvae;
}
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 0, this.input);
throw nvae;
}
switch (alt19) {
case 1 :
// Ham4Parser.g:651:9: ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_handconfig22445);
handshape251=this.handshape2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape2.add(handshape251.getTree());
this.pushFollow(Ham4Parser.FOLLOW_handconfigtail2_in_handconfig22455);
handconfigtail252=this.handconfigtail2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfigtail2.add(handconfigtail252.getTree());
// AST REWRITE
// elements: handshape2, handconfigtail2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 655:6: -> ^( HDCONFIG2 handshape2 handconfigtail2 )
{
// Ham4Parser.g:655:9: ^( HDCONFIG2 handshape2 handconfigtail2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_handshape2.nextTree());
this.adaptor.addChild(root_1, stream_handconfigtail2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:657:9: ( handshape2 )=> handshape2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_handconfig22510);
handshape253=this.handshape2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape2.add(handshape253.getTree());
// AST REWRITE
// elements: handshape2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 660:6: -> ^( HDCONFIG2 handshape2 )
{
// Ham4Parser.g:660:9: ^( HDCONFIG2 handshape2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_handshape2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:662:9: splithandconfig2
this.pushFollow(Ham4Parser.FOLLOW_splithandconfig2_in_handconfig22539);
splithandconfig254=this.splithandconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splithandconfig2.add(splithandconfig254.getTree());
// AST REWRITE
// elements: splithandconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 663:6: -> ^( HDCONFIG2 splithandconfig2 )
{
// Ham4Parser.g:663:9: ^( HDCONFIG2 splithandconfig2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_splithandconfig2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfig1_return: (function() {
Ham4Parser.handconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:668:1: handconfig1 : handshape1 ( extfidir1 palmor1 )? -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? ) ;
// $ANTLR start "handconfig1"
handconfig1: function() {
var retval = new Ham4Parser.handconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshape155 = null;
var extfidir156 = null;
var palmor157 = null;
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: handconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:688:5: ( handshape1 ( extfidir1 palmor1 )? -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? ) )
// Ham4Parser.g:688:9: handshape1 ( extfidir1 palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handconfig12588);
handshape155=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape155.getTree());
// Ham4Parser.g:689:9: ( extfidir1 palmor1 )?
var alt20=2;
var LA20_0 = this.input.LA(1);
if ( ((LA20_0>=HamExtfingeru && LA20_0<=HamExtfingeruo)) ) {
alt20=1;
}
switch (alt20) {
case 1 :
// Ham4Parser.g:690:13: extfidir1 palmor1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfig12612);
extfidir156=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir156.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfig12626);
palmor157=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor157.getTree());
break;
}
// AST REWRITE
// elements: handshape1, palmor1, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 694:6: -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? )
{
// Ham4Parser.g:694:9: ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG1, "HDCONFIG1"), root_1);
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
// Ham4Parser.g:694:32: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:694:43: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splithandconfig2_return: (function() {
Ham4Parser.splithandconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splithandconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:699:1: splithandconfig2 : HamParbegin handconfig1 HamPlus handconfig1 HamParend -> ^( SPLITHDCFG2 ( handconfig1 )* ) ;
// $ANTLR start "splithandconfig2"
splithandconfig2: function() {
var retval = new Ham4Parser.splithandconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin58 = null;
var HamPlus60 = null;
var HamParend62 = null;
var handconfig159 = null;
var handconfig161 = null;
var HamParbegin58_tree=null;
var HamPlus60_tree=null;
var HamParend62_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
this.trace("ANTLR Parse: splithandconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:719:5: ( HamParbegin handconfig1 HamPlus handconfig1 HamParend -> ^( SPLITHDCFG2 ( handconfig1 )* ) )
// Ham4Parser.g:719:9: HamParbegin handconfig1 HamPlus handconfig1 HamParend
HamParbegin58=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splithandconfig22696); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin58);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_splithandconfig22707);
handconfig159=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig159.getTree());
HamPlus60=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splithandconfig22717); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus60);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_splithandconfig22728);
handconfig161=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig161.getTree());
HamParend62=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splithandconfig22738); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend62);
// AST REWRITE
// elements: handconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 725:6: -> ^( SPLITHDCFG2 ( handconfig1 )* )
{
// Ham4Parser.g:725:9: ^( SPLITHDCFG2 ( handconfig1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITHDCFG2, "SPLITHDCFG2"), root_1);
// Ham4Parser.g:725:23: ( handconfig1 )*
while ( stream_handconfig1.hasNext() ) {
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
}
stream_handconfig1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splithandconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfigtail2_return: (function() {
Ham4Parser.handconfigtail2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfigtail2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:728:1: handconfigtail2 : ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) ) ;
// $ANTLR start "handconfigtail2"
handconfigtail2: function() {
var retval = new Ham4Parser.handconfigtail2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin65 = null;
var HamPlus66 = null;
var HamParend67 = null;
var efd1 = null;
var por1 = null;
var efd2 = null;
var por2 = null;
var extfidir263 = null;
var palmor264 = null;
var HamParbegin65_tree=null;
var HamPlus66_tree=null;
var HamParend67_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_palmor2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor2");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
var stream_extfidir2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir2");
this.trace("ANTLR Parse: handconfigtail2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:758:5: ( ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) ) )
// Ham4Parser.g:759:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )
// Ham4Parser.g:759:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )
var alt21=2;
alt21 = this.dfa21.predict(this.input);
switch (alt21) {
case 1 :
// Ham4Parser.g:760:9: ( extfidir2 )=> extfidir2 palmor2
this.pushFollow(Ham4Parser.FOLLOW_extfidir2_in_handconfigtail22827);
extfidir263=this.extfidir2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir2.add(extfidir263.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor2_in_handconfigtail22837);
palmor264=this.palmor2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor2.add(palmor264.getTree());
// AST REWRITE
// elements: palmor2, extfidir2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 764:5: -> ^( HDCFGTAIL2 extfidir2 palmor2 )
{
// Ham4Parser.g:764:8: ^( HDCFGTAIL2 extfidir2 palmor2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCFGTAIL2, "HDCFGTAIL2"), root_1);
this.adaptor.addChild(root_1, stream_extfidir2.nextTree());
this.adaptor.addChild(root_1, stream_palmor2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:766:9: HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend
HamParbegin65=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handconfigtail22867); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin65);
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfigtail22880);
efd1=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(efd1.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfigtail22892);
por1=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(por1.getTree());
HamPlus66=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handconfigtail22902); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus66);
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfigtail22915);
efd2=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(efd2.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfigtail22927);
por2=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(por2.getTree());
HamParend67=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handconfigtail22937); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend67);
// AST REWRITE
// elements: efd2, por2, efd1, por1
// token labels: 
// rule labels: efd2, efd1, por1, por2, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_efd2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token efd2",efd2!=null?efd2.tree:null);
var stream_efd1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token efd1",efd1!=null?efd1.tree:null);
var stream_por1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token por1",por1!=null?por1.tree:null);
var stream_por2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token por2",por2!=null?por2.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 773:5: -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2)
{
// Ham4Parser.g:773:8: ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCFGTAIL2, "HDCFGTAIL2"), root_1);
this.adaptor.addChild(root_1, stream_efd1.nextTree());
this.adaptor.addChild(root_1, stream_por1.nextTree());
this.adaptor.addChild(root_1, stream_efd2.nextTree());
this.adaptor.addChild(root_1, stream_por2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfigtail2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshape2_return: (function() {
Ham4Parser.handshape2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshape2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:780:1: handshape2 : ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) ) ;
// $ANTLR start "handshape2"
handshape2: function() {
var retval = new Ham4Parser.handshape2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin69 = null;
var HamPlus70 = null;
var HamParend71 = null;
var hs1 = null;
var hs2 = null;
var handshape168 = null;
var HamParbegin69_tree=null;
var HamPlus70_tree=null;
var HamParend71_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
this.trace("ANTLR Parse: handshape2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:805:5: ( ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) ) )
// Ham4Parser.g:806:5: ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) )
// Ham4Parser.g:806:5: ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) )
var alt22=2;
var LA22_0 = this.input.LA(1);
if ( ((LA22_0>=HamFist && LA22_0<=HamFinger2345)||(LA22_0>=HamPinch12 && LA22_0<=HamCee12open)||LA22_0==HamNondominant) ) {
alt22=1;
}
else if ( (LA22_0==HamParbegin) ) {
alt22=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 22, 0, this.input);
throw nvae;
}
switch (alt22) {
case 1 :
// Ham4Parser.g:807:9: handshape1
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23010);
handshape168=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape168.getTree());
// AST REWRITE
// elements: handshape1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 808:6: -> ^( HSHAPE2 handshape1 )
{
// Ham4Parser.g:808:9: ^( HSHAPE2 handshape1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE2, "HSHAPE2"), root_1);
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:810:9: HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend
HamParbegin69=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handshape23039); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin69);
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23054);
hs1=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(hs1.getTree());
HamPlus70=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handshape23064); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus70);
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23079);
hs2=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(hs2.getTree());
HamParend71=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handshape23089); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend71);
// AST REWRITE
// elements: hs2, hs1
// token labels: 
// rule labels: hs2, hs1, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_hs2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token hs2",hs2!=null?hs2.tree:null);
var stream_hs1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token hs1",hs1!=null?hs1.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 815:6: -> ^( HSHAPE2 $hs1 $hs2)
{
// Ham4Parser.g:815:9: ^( HSHAPE2 $hs1 $hs2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE2, "HSHAPE2"), root_1);
this.adaptor.addChild(root_1, stream_hs1.nextTree());
this.adaptor.addChild(root_1, stream_hs2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshape2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshape1_return: (function() {
Ham4Parser.handshape1_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshape1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:819:1: handshape1 : basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist ) -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? ) ;
// $ANTLR start "handshape1"
handshape1: function() {
var retval = new Ham4Parser.handshape1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var basichandshape172 = null;
var cautiousfingerlist73 = null;
var fingershapelist74 = null;
var fingercrossinglist75 = null;
var thumbbetweenexplicit76 = null;
var cautiousfingerlist77 = null;
var fingershapelist78 = null;
var fingercrossinglist79 = null;
var thumbspecial80 = null;
var fingerlist81 = null;
var fingershapelist82 = null;
var fingercrossinglist83 = null;
var thumbbetweendefault84 = null;
var thumbextra85 = null;
var fingerlist86 = null;
var fingershapelist87 = null;
var fingercrossinglist88 = null;
var stream_thumbbetweenexplicit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbbetweenexplicit");
var stream_cautiousfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule cautiousfingerlist");
var stream_thumbspecial=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbspecial");
var stream_thumbbetweendefault=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbbetweendefault");
var stream_basichandshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule basichandshape1");
var stream_fingershapelist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingershapelist");
var stream_fingercrossinglist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingercrossinglist");
var stream_fingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerlist");
var stream_thumbextra=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbextra");
this.trace("ANTLR Parse: handshape1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:867:5: ( basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist ) -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? ) )
// Ham4Parser.g:867:7: basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )
this.pushFollow(Ham4Parser.FOLLOW_basichandshape1_in_handshape13140);
basichandshape172=this.basichandshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape1.add(basichandshape172.getTree());
// Ham4Parser.g:868:9: ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )
var alt25=4;
alt25 = this.dfa25.predict(this.input);
switch (alt25) {
case 1 :
// Ham4Parser.g:869:13: ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit
this.pushFollow(Ham4Parser.FOLLOW_cautiousfingerlist_in_handshape13205);
cautiousfingerlist73=this.cautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_cautiousfingerlist.add(cautiousfingerlist73.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13219);
fingershapelist74=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist74.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13233);
fingercrossinglist75=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist75.getTree());
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweenexplicit_in_handshape13247);
thumbbetweenexplicit76=this.thumbbetweenexplicit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbbetweenexplicit.add(thumbbetweenexplicit76.getTree());
break;
case 2 :
// Ham4Parser.g:877:13: ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )?
this.pushFollow(Ham4Parser.FOLLOW_cautiousfingerlist_in_handshape13325);
cautiousfingerlist77=this.cautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_cautiousfingerlist.add(cautiousfingerlist77.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13339);
fingershapelist78=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist78.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13353);
fingercrossinglist79=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist79.getTree());
// Ham4Parser.g:882:13: ( ( thumbspecial )=> thumbspecial )?
var alt23=2;
alt23 = this.dfa23.predict(this.input);
switch (alt23) {
case 1 :
// Ham4Parser.g:882:15: ( thumbspecial )=> thumbspecial
this.pushFollow(Ham4Parser.FOLLOW_thumbspecial_in_handshape13377);
thumbspecial80=this.thumbspecial();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbspecial.add(thumbspecial80.getTree());
break;
}
break;
case 3 :
// Ham4Parser.g:885:13: ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra )
this.pushFollow(Ham4Parser.FOLLOW_fingerlist_in_handshape13458);
fingerlist81=this.fingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerlist.add(fingerlist81.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13472);
fingershapelist82=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist82.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13486);
fingercrossinglist83=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist83.getTree());
// Ham4Parser.g:890:13: ( thumbbetweendefault | thumbextra )
var alt24=2;
var LA24_0 = this.input.LA(1);
if ( (LA24_0==HamBetween) ) {
alt24=1;
}
else if ( (LA24_0==HamThumb||(LA24_0>=HamFingertip && LA24_0<=HamFingerside)) ) {
alt24=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);
throw nvae;
}
switch (alt24) {
case 1 :
// Ham4Parser.g:890:15: thumbbetweendefault
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_handshape13502);
thumbbetweendefault84=this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbbetweendefault.add(thumbbetweendefault84.getTree());
break;
case 2 :
// Ham4Parser.g:890:37: thumbextra
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_handshape13506);
thumbextra85=this.thumbextra();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbextra.add(thumbextra85.getTree());
break;
}
break;
case 4 :
// Ham4Parser.g:893:13: fingerlist fingershapelist fingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_fingerlist_in_handshape13539);
fingerlist86=this.fingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerlist.add(fingerlist86.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13553);
fingershapelist87=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist87.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13567);
fingercrossinglist88=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist88.getTree());
break;
}
// AST REWRITE
// elements: thumbextra, fingerlist, thumbbetweenexplicit, thumbspecial, fingercrossinglist, thumbbetweendefault, cautiousfingerlist, basichandshape1, fingershapelist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 900:2: -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? )
{
// Ham4Parser.g:900:5: ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE1, "HSHAPE1"), root_1);
this.adaptor.addChild(root_1, stream_basichandshape1.nextTree());
// Ham4Parser.g:900:31: ( cautiousfingerlist )?
if ( stream_cautiousfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_cautiousfingerlist.nextTree());
}
stream_cautiousfingerlist.reset();
// Ham4Parser.g:900:51: ( fingerlist )?
if ( stream_fingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingerlist.nextTree());
}
stream_fingerlist.reset();
// Ham4Parser.g:900:63: ( fingershapelist )?
if ( stream_fingershapelist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingershapelist.nextTree());
}
stream_fingershapelist.reset();
// Ham4Parser.g:900:80: ( fingercrossinglist )?
if ( stream_fingercrossinglist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingercrossinglist.nextTree());
}
stream_fingercrossinglist.reset();
// Ham4Parser.g:901:4: ( thumbbetweenexplicit )?
if ( stream_thumbbetweenexplicit.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbbetweenexplicit.nextTree());
}
stream_thumbbetweenexplicit.reset();
// Ham4Parser.g:901:26: ( thumbspecial )?
if ( stream_thumbspecial.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbspecial.nextTree());
}
stream_thumbspecial.reset();
// Ham4Parser.g:901:40: ( thumbbetweendefault )?
if ( stream_thumbbetweendefault.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbbetweendefault.nextTree());
}
stream_thumbbetweendefault.reset();
// Ham4Parser.g:901:61: ( thumbextra )?
if ( stream_thumbextra.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbextra.nextTree());
}
stream_thumbextra.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshape1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
basichandshape1_return: (function() {
Ham4Parser.basichandshape1_return = function(){};
org.antlr.lang.extend(Ham4Parser.basichandshape1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:904:1: basichandshape1 : basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )? -> ^( BASICHDSHP1 ( basichandshape )* ) ;
// $ANTLR start "basichandshape1"
basichandshape1: function() {
var retval = new Ham4Parser.basichandshape1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween90 = null;
var basichandshape89 = null;
var basichandshape91 = null;
var HamBetween90_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_basichandshape=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule basichandshape");
this.trace("ANTLR Parse: basichandshape1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:925:5: ( basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )? -> ^( BASICHDSHP1 ( basichandshape )* ) )
// Ham4Parser.g:925:9: basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?
this.pushFollow(Ham4Parser.FOLLOW_basichandshape_in_basichandshape13654);
basichandshape89=this.basichandshape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape.add(basichandshape89.getTree());
// Ham4Parser.g:926:9: ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?
var alt26=2;
alt26 = this.dfa26.predict(this.input);
switch (alt26) {
case 1 :
// Ham4Parser.g:927:13: ( HamBetween handshapeclass )=> HamBetween basichandshape
HamBetween90=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_basichandshape13719); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween90);
this.pushFollow(Ham4Parser.FOLLOW_basichandshape_in_basichandshape13734);
basichandshape91=this.basichandshape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape.add(basichandshape91.getTree());
break;
}
// AST REWRITE
// elements: basichandshape
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 932:6: -> ^( BASICHDSHP1 ( basichandshape )* )
{
// Ham4Parser.g:932:9: ^( BASICHDSHP1 ( basichandshape )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(BASICHDSHP1, "BASICHDSHP1"), root_1);
// Ham4Parser.g:932:23: ( basichandshape )*
while ( stream_basichandshape.hasNext() ) {
this.adaptor.addChild(root_1, stream_basichandshape.nextTree());
}
stream_basichandshape.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: basichandshape1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
basichandshape_return: (function() {
Ham4Parser.basichandshape_return = function(){};
org.antlr.lang.extend(Ham4Parser.basichandshape_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:935:1: basichandshape : ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )? -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? ) ;
// $ANTLR start "basichandshape"
basichandshape: function() {
var retval = new Ham4Parser.basichandshape_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNondominant93 = null;
var HamEtc94 = null;
var handshapeclass92 = null;
var handbendandthumb95 = null;
var HamNondominant93_tree=null;
var HamEtc94_tree=null;
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_handshapeclass=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshapeclass");
var stream_handbendandthumb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handbendandthumb");
this.trace("ANTLR Parse: basichandshape starts "+this.state.backtracking);
try {
// Ham4Parser.g:957:5: ( ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )? -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? ) )
// Ham4Parser.g:957:9: ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )?
// Ham4Parser.g:957:9: ( handshapeclass | HamNondominant )
var alt27=2;
var LA27_0 = this.input.LA(1);
if ( ((LA27_0>=HamFist && LA27_0<=HamFinger2345)||(LA27_0>=HamPinch12 && LA27_0<=HamCee12open)) ) {
alt27=1;
}
else if ( (LA27_0==HamNondominant) ) {
alt27=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 27, 0, this.input);
throw nvae;
}
switch (alt27) {
case 1 :
// Ham4Parser.g:958:13: handshapeclass
this.pushFollow(Ham4Parser.FOLLOW_handshapeclass_in_basichandshape3802);
handshapeclass92=this.handshapeclass();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshapeclass.add(handshapeclass92.getTree());
break;
case 2 :
// Ham4Parser.g:960:13: HamNondominant
HamNondominant93=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_basichandshape3826); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant93);
break;
}
// Ham4Parser.g:962:9: ( HamEtc )?
var alt28=2;
var LA28_0 = this.input.LA(1);
if ( (LA28_0==HamEtc) ) {
alt28=1;
}
switch (alt28) {
case 1 :
// Ham4Parser.g:962:11: HamEtc
HamEtc94=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_basichandshape3848); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc94);
break;
}
// Ham4Parser.g:963:9: ( handbendandthumb )?
var alt29=2;
var LA29_0 = this.input.LA(1);
if ( ((LA29_0>=HamThumboutmod && LA29_0<=HamThumbacrossmod)||(LA29_0>=HamThumbopenmod && LA29_0<=HamFingerhookedmod)||(LA29_0>=HamDoublebent && LA29_0<=HamDoublehooked)) ) {
alt29=1;
}
switch (alt29) {
case 1 :
// Ham4Parser.g:963:9: handbendandthumb
this.pushFollow(Ham4Parser.FOLLOW_handbendandthumb_in_basichandshape3861);
handbendandthumb95=this.handbendandthumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handbendandthumb.add(handbendandthumb95.getTree());
break;
}
// AST REWRITE
// elements: HamNondominant, handbendandthumb, handshapeclass, HamEtc
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 965:9: -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? )
{
// Ham4Parser.g:965:12: ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(BASICHDSHP, "BASICHDSHP"), root_1);
// Ham4Parser.g:965:25: ( handshapeclass )?
if ( stream_handshapeclass.hasNext() ) {
this.adaptor.addChild(root_1, stream_handshapeclass.nextTree());
}
stream_handshapeclass.reset();
// Ham4Parser.g:965:41: ( HamNondominant )?
if ( stream_HamNondominant.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
}
stream_HamNondominant.reset();
// Ham4Parser.g:965:57: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:965:65: ( handbendandthumb )?
if ( stream_handbendandthumb.hasNext() ) {
this.adaptor.addChild(root_1, stream_handbendandthumb.nextTree());
}
stream_handbendandthumb.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: basichandshape finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handbendandthumb_return: (function() {
Ham4Parser.handbendandthumb_return = function(){};
org.antlr.lang.extend(Ham4Parser.handbendandthumb_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:968:1: handbendandthumb : ( thumbpos ( fingerbending )? | fingerbending ( thumbpos )? );
// $ANTLR start "handbendandthumb"
handbendandthumb: function() {
var retval = new Ham4Parser.handbendandthumb_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbpos96 = null;
var fingerbending97 = null;
var fingerbending98 = null;
var thumbpos99 = null;
this.trace("ANTLR Parse: handbendandthumb starts "+this.state.backtracking);
try {
// Ham4Parser.g:987:5: ( thumbpos ( fingerbending )? | fingerbending ( thumbpos )? )
var alt32=2;
var LA32_0 = this.input.LA(1);
if ( ((LA32_0>=HamThumboutmod && LA32_0<=HamThumbacrossmod)||LA32_0==HamThumbopenmod) ) {
alt32=1;
}
else if ( ((LA32_0>=HamFingerstraightmod && LA32_0<=HamFingerhookedmod)||(LA32_0>=HamDoublebent && LA32_0<=HamDoublehooked)) ) {
alt32=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 32, 0, this.input);
throw nvae;
}
switch (alt32) {
case 1 :
// Ham4Parser.g:988:9: thumbpos ( fingerbending )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbpos_in_handbendandthumb3932);
thumbpos96=this.thumbpos();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbpos96.getTree());
// Ham4Parser.g:989:9: ( fingerbending )?
var alt30=2;
var LA30_0 = this.input.LA(1);
if ( ((LA30_0>=HamFingerstraightmod && LA30_0<=HamFingerhookedmod)||(LA30_0>=HamDoublebent && LA30_0<=HamDoublehooked)) ) {
alt30=1;
}
switch (alt30) {
case 1 :
// Ham4Parser.g:989:11: fingerbending
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_handbendandthumb3944);
fingerbending97=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerbending97.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:991:9: fingerbending ( thumbpos )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_handbendandthumb3963);
fingerbending98=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerbending98.getTree());
// Ham4Parser.g:992:9: ( thumbpos )?
var alt31=2;
var LA31_0 = this.input.LA(1);
if ( ((LA31_0>=HamThumboutmod && LA31_0<=HamThumbacrossmod)||LA31_0==HamThumbopenmod) ) {
alt31=1;
}
switch (alt31) {
case 1 :
// Ham4Parser.g:992:11: thumbpos
this.pushFollow(Ham4Parser.FOLLOW_thumbpos_in_handbendandthumb3975);
thumbpos99=this.thumbpos();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbpos99.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handbendandthumb finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerlist_return: (function() {
Ham4Parser.fingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:995:1: fingerlist : recfingerlist -> ^( FINGERLIST ( recfingerlist )? ) ;
// $ANTLR start "fingerlist"
fingerlist: function() {
var retval = new Ham4Parser.fingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingerlist100 = null;
var stream_recfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingerlist");
this.trace("ANTLR Parse: fingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1010:5: ( recfingerlist -> ^( FINGERLIST ( recfingerlist )? ) )
// Ham4Parser.g:1010:9: recfingerlist
this.pushFollow(Ham4Parser.FOLLOW_recfingerlist_in_fingerlist4007);
recfingerlist100=this.recfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingerlist.add(recfingerlist100.getTree());
// AST REWRITE
// elements: recfingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1011:5: -> ^( FINGERLIST ( recfingerlist )? )
{
// Ham4Parser.g:1011:8: ^( FINGERLIST ( recfingerlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FINGERLIST, "FINGERLIST"), root_1);
// Ham4Parser.g:1011:21: ( recfingerlist )?
if ( stream_recfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingerlist.nextTree());
}
stream_recfingerlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingerlist_return: (function() {
Ham4Parser.recfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1014:1: recfingerlist : ( ( hsfingeritem )=> hsfingeritem recfingerlist )? ;
// $ANTLR start "recfingerlist"
recfingerlist: function() {
var retval = new Ham4Parser.recfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var hsfingeritem101 = null;
var recfingerlist102 = null;
this.trace("ANTLR Parse: recfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1034:5: ( ( ( hsfingeritem )=> hsfingeritem recfingerlist )? )
// Ham4Parser.g:1035:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1035:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?
var alt33=2;
alt33 = this.dfa33.predict(this.input);
switch (alt33) {
case 1 :
// Ham4Parser.g:1036:13: ( hsfingeritem )=> hsfingeritem recfingerlist
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_recfingerlist4116);
hsfingeritem101=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem101.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingerlist_in_recfingerlist4130);
recfingerlist102=this.recfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingerlist102.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
cautiousfingerlist_return: (function() {
Ham4Parser.cautiousfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.cautiousfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1043:1: cautiousfingerlist : reccautiousfingerlist -> ^( FINGERLIST ( reccautiousfingerlist )? ) ;
// $ANTLR start "cautiousfingerlist"
cautiousfingerlist: function() {
var retval = new Ham4Parser.cautiousfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var reccautiousfingerlist103 = null;
var stream_reccautiousfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule reccautiousfingerlist");
this.trace("ANTLR Parse: cautiousfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1058:5: ( reccautiousfingerlist -> ^( FINGERLIST ( reccautiousfingerlist )? ) )
// Ham4Parser.g:1058:9: reccautiousfingerlist
this.pushFollow(Ham4Parser.FOLLOW_reccautiousfingerlist_in_cautiousfingerlist4170);
reccautiousfingerlist103=this.reccautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_reccautiousfingerlist.add(reccautiousfingerlist103.getTree());
// AST REWRITE
// elements: reccautiousfingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1059:5: -> ^( FINGERLIST ( reccautiousfingerlist )? )
{
// Ham4Parser.g:1059:8: ^( FINGERLIST ( reccautiousfingerlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FINGERLIST, "FINGERLIST"), root_1);
// Ham4Parser.g:1059:21: ( reccautiousfingerlist )?
if ( stream_reccautiousfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_reccautiousfingerlist.nextTree());
}
stream_reccautiousfingerlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: cautiousfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
reccautiousfingerlist_return: (function() {
Ham4Parser.reccautiousfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.reccautiousfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1062:1: reccautiousfingerlist : ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )? ;
// $ANTLR start "reccautiousfingerlist"
reccautiousfingerlist: function() {
var retval = new Ham4Parser.reccautiousfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var hsfingeritem104 = null;
var reccautiousfingerlist105 = null;
this.trace("ANTLR Parse: reccautiousfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1082:5: ( ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )? )
// Ham4Parser.g:1083:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1083:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?
var alt34=2;
alt34 = this.dfa34.predict(this.input);
switch (alt34) {
case 1 :
// Ham4Parser.g:1084:13: ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_reccautiousfingerlist4273);
hsfingeritem104=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem104.getTree());
this.pushFollow(Ham4Parser.FOLLOW_reccautiousfingerlist_in_reccautiousfingerlist4287);
reccautiousfingerlist105=this.reccautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, reccautiousfingerlist105.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: reccautiousfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingershapelist_return: (function() {
Ham4Parser.fingershapelist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingershapelist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1091:1: fingershapelist : recfingershapelist -> ^( FISHPLIST ( recfingershapelist )? ) ;
// $ANTLR start "fingershapelist"
fingershapelist: function() {
var retval = new Ham4Parser.fingershapelist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingershapelist106 = null;
var stream_recfingershapelist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingershapelist");
this.trace("ANTLR Parse: fingershapelist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1106:5: ( recfingershapelist -> ^( FISHPLIST ( recfingershapelist )? ) )
// Ham4Parser.g:1106:9: recfingershapelist
this.pushFollow(Ham4Parser.FOLLOW_recfingershapelist_in_fingershapelist4327);
recfingershapelist106=this.recfingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingershapelist.add(recfingershapelist106.getTree());
// AST REWRITE
// elements: recfingershapelist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1107:5: -> ^( FISHPLIST ( recfingershapelist )? )
{
// Ham4Parser.g:1107:8: ^( FISHPLIST ( recfingershapelist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FISHPLIST, "FISHPLIST"), root_1);
// Ham4Parser.g:1107:20: ( recfingershapelist )?
if ( stream_recfingershapelist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingershapelist.nextTree());
}
stream_recfingershapelist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingershapelist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingershapelist_return: (function() {
Ham4Parser.recfingershapelist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingershapelist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1110:1: recfingershapelist : ( ( fingershape )=> fingershape recfingershapelist )? ;
// $ANTLR start "recfingershapelist"
recfingershapelist: function() {
var retval = new Ham4Parser.recfingershapelist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingershape107 = null;
var recfingershapelist108 = null;
this.trace("ANTLR Parse: recfingershapelist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1130:5: ( ( ( fingershape )=> fingershape recfingershapelist )? )
// Ham4Parser.g:1131:9: ( ( fingershape )=> fingershape recfingershapelist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1131:9: ( ( fingershape )=> fingershape recfingershapelist )?
var alt35=2;
alt35 = this.dfa35.predict(this.input);
switch (alt35) {
case 1 :
// Ham4Parser.g:1132:13: ( fingershape )=> fingershape recfingershapelist
this.pushFollow(Ham4Parser.FOLLOW_fingershape_in_recfingershapelist4431);
fingershape107=this.fingershape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingershape107.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingershapelist_in_recfingershapelist4445);
recfingershapelist108=this.recfingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingershapelist108.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingershapelist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingercrossinglist_return: (function() {
Ham4Parser.fingercrossinglist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingercrossinglist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1139:1: fingercrossinglist : recfingercrossinglist -> ^( FICRSSLIST ( recfingercrossinglist )? ) ;
// $ANTLR start "fingercrossinglist"
fingercrossinglist: function() {
var retval = new Ham4Parser.fingercrossinglist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingercrossinglist109 = null;
var stream_recfingercrossinglist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingercrossinglist");
this.trace("ANTLR Parse: fingercrossinglist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1154:5: ( recfingercrossinglist -> ^( FICRSSLIST ( recfingercrossinglist )? ) )
// Ham4Parser.g:1154:9: recfingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_recfingercrossinglist_in_fingercrossinglist4485);
recfingercrossinglist109=this.recfingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingercrossinglist.add(recfingercrossinglist109.getTree());
// AST REWRITE
// elements: recfingercrossinglist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1155:5: -> ^( FICRSSLIST ( recfingercrossinglist )? )
{
// Ham4Parser.g:1155:8: ^( FICRSSLIST ( recfingercrossinglist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FICRSSLIST, "FICRSSLIST"), root_1);
// Ham4Parser.g:1155:21: ( recfingercrossinglist )?
if ( stream_recfingercrossinglist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingercrossinglist.nextTree());
}
stream_recfingercrossinglist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingercrossinglist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingercrossinglist_return: (function() {
Ham4Parser.recfingercrossinglist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingercrossinglist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1158:1: recfingercrossinglist : ( ( fingercrossing )=> fingercrossing recfingercrossinglist )? ;
// $ANTLR start "recfingercrossinglist"
recfingercrossinglist: function() {
var retval = new Ham4Parser.recfingercrossinglist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingercrossing110 = null;
var recfingercrossinglist111 = null;
this.trace("ANTLR Parse: recfingercrossinglist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1178:5: ( ( ( fingercrossing )=> fingercrossing recfingercrossinglist )? )
// Ham4Parser.g:1179:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1179:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?
var alt36=2;
alt36 = this.dfa36.predict(this.input);
switch (alt36) {
case 1 :
// Ham4Parser.g:1180:13: ( fingercrossing )=> fingercrossing recfingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_fingercrossing_in_recfingercrossinglist4586);
fingercrossing110=this.fingercrossing();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingercrossing110.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingercrossinglist_in_recfingercrossinglist4600);
recfingercrossinglist111=this.recfingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingercrossinglist111.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingercrossinglist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hsfingeritem_return: (function() {
Ham4Parser.hsfingeritem_return = function(){};
org.antlr.lang.extend(Ham4Parser.hsfingeritem_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1187:1: hsfingeritem : finger ( HamLargemod )? -> ^( HSFINGERITEM finger ( HamLargemod )? ) ;
// $ANTLR start "hsfingeritem"
hsfingeritem: function() {
var retval = new Ham4Parser.hsfingeritem_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamLargemod113 = null;
var finger112 = null;
var HamLargemod113_tree=null;
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_finger=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule finger");
this.trace("ANTLR Parse: hsfingeritem starts "+this.state.backtracking);
try {
// Ham4Parser.g:1204:5: ( finger ( HamLargemod )? -> ^( HSFINGERITEM finger ( HamLargemod )? ) )
// Ham4Parser.g:1204:9: finger ( HamLargemod )?
this.pushFollow(Ham4Parser.FOLLOW_finger_in_hsfingeritem4656);
finger112=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger112.getTree());
// Ham4Parser.g:1205:9: ( HamLargemod )?
var alt37=2;
var LA37_0 = this.input.LA(1);
if ( (LA37_0==HamLargemod) ) {
alt37=1;
}
switch (alt37) {
case 1 :
// Ham4Parser.g:1205:11: HamLargemod
HamLargemod113=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_hsfingeritem4668); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod113);
break;
}
// AST REWRITE
// elements: finger, HamLargemod
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1207:9: -> ^( HSFINGERITEM finger ( HamLargemod )? )
{
// Ham4Parser.g:1207:12: ^( HSFINGERITEM finger ( HamLargemod )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSFINGERITEM, "HSFINGERITEM"), root_1);
this.adaptor.addChild(root_1, stream_finger.nextTree());
// Ham4Parser.g:1207:34: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hsfingeritem finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
digit_return: (function() {
Ham4Parser.digit_return = function(){};
org.antlr.lang.extend(Ham4Parser.digit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1210:1: digit : ( thumb | finger );
// $ANTLR start "digit"
digit: function() {
var retval = new Ham4Parser.digit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb114 = null;
var finger115 = null;
this.trace("ANTLR Parse: digit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1225:5: ( thumb | finger )
var alt38=2;
var LA38_0 = this.input.LA(1);
if ( (LA38_0==HamThumb) ) {
alt38=1;
}
else if ( ((LA38_0>=HamIndexfinger && LA38_0<=HamPinky)) ) {
alt38=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 38, 0, this.input);
throw nvae;
}
switch (alt38) {
case 1 :
// Ham4Parser.g:1225:9: thumb
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_digit4728);
thumb114=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumb114.getTree());
break;
case 2 :
// Ham4Parser.g:1226:9: finger
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_finger_in_digit4738);
finger115=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, finger115.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: digit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hsdigit_return: (function() {
Ham4Parser.hsdigit_return = function(){};
org.antlr.lang.extend(Ham4Parser.hsdigit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1229:1: hsdigit : ( thumb | hsfingeritem );
// $ANTLR start "hsdigit"
hsdigit: function() {
var retval = new Ham4Parser.hsdigit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb116 = null;
var hsfingeritem117 = null;
this.trace("ANTLR Parse: hsdigit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1244:5: ( thumb | hsfingeritem )
var alt39=2;
var LA39_0 = this.input.LA(1);
if ( (LA39_0==HamThumb) ) {
alt39=1;
}
else if ( ((LA39_0>=HamIndexfinger && LA39_0<=HamPinky)) ) {
alt39=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 39, 0, this.input);
throw nvae;
}
switch (alt39) {
case 1 :
// Ham4Parser.g:1244:9: thumb
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_hsdigit4788);
thumb116=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumb116.getTree());
break;
case 2 :
// Ham4Parser.g:1245:9: hsfingeritem
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_hsdigit4798);
hsfingeritem117=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem117.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hsdigit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingershape_return: (function() {
Ham4Parser.fingershape_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingershape_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1248:1: fingershape : digit fingerbending -> ^( FSHAPE digit fingerbending ) ;
// $ANTLR start "fingershape"
fingershape: function() {
var retval = new Ham4Parser.fingershape_return();
retval.start = this.input.LT(1);
var root_0 = null;
var digit118 = null;
var fingerbending119 = null;
var stream_fingerbending=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerbending");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: fingershape starts "+this.state.backtracking);
try {
// Ham4Parser.g:1265:5: ( digit fingerbending -> ^( FSHAPE digit fingerbending ) )
// Ham4Parser.g:1265:9: digit fingerbending
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingershape4827);
digit118=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(digit118.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_fingershape4837);
fingerbending119=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerbending.add(fingerbending119.getTree());
// AST REWRITE
// elements: fingerbending, digit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1268:9: -> ^( FSHAPE digit fingerbending )
{
// Ham4Parser.g:1268:12: ^( FSHAPE digit fingerbending )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FSHAPE, "FSHAPE"), root_1);
this.adaptor.addChild(root_1, stream_digit.nextTree());
this.adaptor.addChild(root_1, stream_fingerbending.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingershape finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingercrossing_return: (function() {
Ham4Parser.fingercrossing_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingercrossing_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1271:1: fingercrossing : d1= digit fingerpart d2= digit -> ^( FCROSSING $d1 fingerpart $d2) ;
// $ANTLR start "fingercrossing"
fingercrossing: function() {
var retval = new Ham4Parser.fingercrossing_return();
retval.start = this.input.LT(1);
var root_0 = null;
var d1 = null;
var d2 = null;
var fingerpart120 = null;
var stream_fingerpart=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerpart");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: fingercrossing starts "+this.state.backtracking);
try {
// Ham4Parser.g:1289:5: (d1= digit fingerpart d2= digit -> ^( FCROSSING $d1 fingerpart $d2) )
// Ham4Parser.g:1289:9: d1= digit fingerpart d2= digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingercrossing4897);
d1=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(d1.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_fingercrossing4907);
fingerpart120=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerpart.add(fingerpart120.getTree());
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingercrossing4921);
d2=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(d2.getTree());
// AST REWRITE
// elements: d2, d1, fingerpart
// token labels: 
// rule labels: d1, d2, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_d1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token d1",d1!=null?d1.tree:null);
var stream_d2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token d2",d2!=null?d2.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1293:9: -> ^( FCROSSING $d1 fingerpart $d2)
{
// Ham4Parser.g:1293:12: ^( FCROSSING $d1 fingerpart $d2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FCROSSING, "FCROSSING"), root_1);
this.adaptor.addChild(root_1, stream_d1.nextTree());
this.adaptor.addChild(root_1, stream_fingerpart.nextTree());
this.adaptor.addChild(root_1, stream_d2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingercrossing finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbspecial_return: (function() {
Ham4Parser.thumbspecial_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbspecial_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1296:1: thumbspecial : ( thumbbetween | thumbextra );
// $ANTLR start "thumbspecial"
thumbspecial: function() {
var retval = new Ham4Parser.thumbspecial_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbbetween121 = null;
var thumbextra122 = null;
this.trace("ANTLR Parse: thumbspecial starts "+this.state.backtracking);
try {
// Ham4Parser.g:1311:5: ( thumbbetween | thumbextra )
var alt40=2;
var LA40_0 = this.input.LA(1);
if ( ((LA40_0>=HamIndexfinger && LA40_0<=HamPinky)||LA40_0==HamBetween) ) {
alt40=1;
}
else if ( (LA40_0==HamThumb||(LA40_0>=HamFingertip && LA40_0<=HamFingerside)) ) {
alt40=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 40, 0, this.input);
throw nvae;
}
switch (alt40) {
case 1 :
// Ham4Parser.g:1311:9: thumbbetween
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetween_in_thumbspecial4981);
thumbbetween121=this.thumbbetween();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetween121.getTree());
break;
case 2 :
// Ham4Parser.g:1312:9: thumbextra
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_thumbspecial4991);
thumbextra122=this.thumbextra();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbextra122.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbspecial finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetween_return: (function() {
Ham4Parser.thumbbetween_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetween_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1315:1: thumbbetween : ( thumbbetweenexplicit | thumbbetweendefault );
// $ANTLR start "thumbbetween"
thumbbetween: function() {
var retval = new Ham4Parser.thumbbetween_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbbetweenexplicit123 = null;
var thumbbetweendefault124 = null;
this.trace("ANTLR Parse: thumbbetween starts "+this.state.backtracking);
try {
// Ham4Parser.g:1330:5: ( thumbbetweenexplicit | thumbbetweendefault )
var alt41=2;
var LA41_0 = this.input.LA(1);
if ( ((LA41_0>=HamIndexfinger && LA41_0<=HamPinky)) ) {
alt41=1;
}
else if ( (LA41_0==HamBetween) ) {
alt41=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);
throw nvae;
}
switch (alt41) {
case 1 :
// Ham4Parser.g:1330:9: thumbbetweenexplicit
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweenexplicit_in_thumbbetween5020);
thumbbetweenexplicit123=this.thumbbetweenexplicit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetweenexplicit123.getTree());
break;
case 2 :
// Ham4Parser.g:1331:9: thumbbetweendefault
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_thumbbetween5030);
thumbbetweendefault124=this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetweendefault124.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetween finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetweenexplicit_return: (function() {
Ham4Parser.thumbbetweenexplicit_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetweenexplicit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1334:1: thumbbetweenexplicit : finger HamBetween finger -> ^( THSPECIAL ^( HamBetween ( finger )* ) ) ;
// $ANTLR start "thumbbetweenexplicit"
thumbbetweenexplicit: function() {
var retval = new Ham4Parser.thumbbetweenexplicit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween126 = null;
var finger125 = null;
var finger127 = null;
var HamBetween126_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_finger=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule finger");
this.trace("ANTLR Parse: thumbbetweenexplicit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1352:5: ( finger HamBetween finger -> ^( THSPECIAL ^( HamBetween ( finger )* ) ) )
// Ham4Parser.g:1352:9: finger HamBetween finger
this.pushFollow(Ham4Parser.FOLLOW_finger_in_thumbbetweenexplicit5059);
finger125=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger125.getTree());
HamBetween126=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_thumbbetweenexplicit5069); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween126);
this.pushFollow(Ham4Parser.FOLLOW_finger_in_thumbbetweenexplicit5080);
finger127=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger127.getTree());
// AST REWRITE
// elements: HamBetween, finger
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1356:9: -> ^( THSPECIAL ^( HamBetween ( finger )* ) )
{
// Ham4Parser.g:1356:12: ^( THSPECIAL ^( HamBetween ( finger )* ) )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
// Ham4Parser.g:1356:24: ^( HamBetween ( finger )* )
{
var root_2 = this.adaptor.nil();
root_2 = this.adaptor.becomeRoot(stream_HamBetween.nextNode(), root_2);
// Ham4Parser.g:1356:37: ( finger )*
while ( stream_finger.hasNext() ) {
this.adaptor.addChild(root_2, stream_finger.nextTree());
}
stream_finger.reset();
this.adaptor.addChild(root_1, root_2);
}
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetweenexplicit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetweendefault_return: (function() {
Ham4Parser.thumbbetweendefault_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetweendefault_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1359:1: thumbbetweendefault : HamBetween -> ^( THSPECIAL HamBetween ) ;
// $ANTLR start "thumbbetweendefault"
thumbbetweendefault: function() {
var retval = new Ham4Parser.thumbbetweendefault_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween128 = null;
var HamBetween128_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
this.trace("ANTLR Parse: thumbbetweendefault starts "+this.state.backtracking);
try {
// Ham4Parser.g:1375:5: ( HamBetween -> ^( THSPECIAL HamBetween ) )
// Ham4Parser.g:1375:9: HamBetween
HamBetween128=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_thumbbetweendefault5139); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween128);
// AST REWRITE
// elements: HamBetween
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1377:9: -> ^( THSPECIAL HamBetween )
{
// Ham4Parser.g:1377:12: ^( THSPECIAL HamBetween )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
this.adaptor.addChild(root_1, stream_HamBetween.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetweendefault finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbextra_return: (function() {
Ham4Parser.thumbextra_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbextra_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1380:1: thumbextra : ( thumb | fingerpart ) -> ^( THSPECIAL ( thumb )? ( fingerpart )? ) ;
// $ANTLR start "thumbextra"
thumbextra: function() {
var retval = new Ham4Parser.thumbextra_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb129 = null;
var fingerpart130 = null;
var stream_fingerpart=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerpart");
var stream_thumb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumb");
this.trace("ANTLR Parse: thumbextra starts "+this.state.backtracking);
try {
// Ham4Parser.g:1400:5: ( ( thumb | fingerpart ) -> ^( THSPECIAL ( thumb )? ( fingerpart )? ) )
// Ham4Parser.g:1401:5: ( thumb | fingerpart )
// Ham4Parser.g:1401:5: ( thumb | fingerpart )
var alt42=2;
var LA42_0 = this.input.LA(1);
if ( (LA42_0==HamThumb) ) {
alt42=1;
}
else if ( ((LA42_0>=HamFingertip && LA42_0<=HamFingerside)) ) {
alt42=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 42, 0, this.input);
throw nvae;
}
switch (alt42) {
case 1 :
// Ham4Parser.g:1402:9: thumb
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_thumbextra5205);
thumb129=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumb.add(thumb129.getTree());
break;
case 2 :
// Ham4Parser.g:1404:9: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_thumbextra5221);
fingerpart130=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerpart.add(fingerpart130.getTree());
break;
}
// AST REWRITE
// elements: fingerpart, thumb
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1406:5: -> ^( THSPECIAL ( thumb )? ( fingerpart )? )
{
// Ham4Parser.g:1406:8: ^( THSPECIAL ( thumb )? ( fingerpart )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
// Ham4Parser.g:1406:20: ( thumb )?
if ( stream_thumb.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumb.nextTree());
}
stream_thumb.reset();
// Ham4Parser.g:1406:27: ( fingerpart )?
if ( stream_fingerpart.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingerpart.nextTree());
}
stream_fingerpart.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbextra finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir2_return: (function() {
Ham4Parser.extfidir2_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1412:1: extfidir2 : ( extfidir1 | splitextfidir2 ) -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? ) ;
// $ANTLR start "extfidir2"
extfidir2: function() {
var retval = new Ham4Parser.extfidir2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidir1131 = null;
var splitextfidir2132 = null;
var stream_splitextfidir2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitextfidir2");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: extfidir2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1432:5: ( ( extfidir1 | splitextfidir2 ) -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? ) )
// Ham4Parser.g:1433:5: ( extfidir1 | splitextfidir2 )
// Ham4Parser.g:1433:5: ( extfidir1 | splitextfidir2 )
var alt43=2;
var LA43_0 = this.input.LA(1);
if ( ((LA43_0>=HamExtfingeru && LA43_0<=HamExtfingeruo)) ) {
alt43=1;
}
else if ( (LA43_0==HamParbegin) ) {
alt43=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 43, 0, this.input);
throw nvae;
}
switch (alt43) {
case 1 :
// Ham4Parser.g:1434:9: extfidir1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_extfidir25287);
extfidir1131=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1131.getTree());
break;
case 2 :
// Ham4Parser.g:1436:9: splitextfidir2
this.pushFollow(Ham4Parser.FOLLOW_splitextfidir2_in_extfidir25303);
splitextfidir2132=this.splitextfidir2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitextfidir2.add(splitextfidir2132.getTree());
break;
}
// AST REWRITE
// elements: splitextfidir2, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1438:5: -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? )
{
// Ham4Parser.g:1438:8: ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR2, "EXTFIDIR2"), root_1);
// Ham4Parser.g:1438:20: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:1438:31: ( splitextfidir2 )?
if ( stream_splitextfidir2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitextfidir2.nextTree());
}
stream_splitextfidir2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidir2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitextfidir2_return: (function() {
Ham4Parser.splitextfidir2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitextfidir2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1441:1: splitextfidir2 : HamParbegin extfidir1 HamPlus extfidir1 HamParend ;
// $ANTLR start "splitextfidir2"
splitextfidir2: function() {
var retval = new Ham4Parser.splitextfidir2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin133 = null;
var HamPlus135 = null;
var HamParend137 = null;
var extfidir1134 = null;
var extfidir1136 = null;
var HamParbegin133_tree=null;
var HamPlus135_tree=null;
var HamParend137_tree=null;
this.trace("ANTLR Parse: splitextfidir2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1459:5: ( HamParbegin extfidir1 HamPlus extfidir1 HamParend )
// Ham4Parser.g:1459:9: HamParbegin extfidir1 HamPlus extfidir1 HamParend
root_0 = this.adaptor.nil();
HamParbegin133=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitextfidir25354); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_splitextfidir25366);
extfidir1134=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, extfidir1134.getTree());
HamPlus135=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitextfidir25376); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_splitextfidir25388);
extfidir1136=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, extfidir1136.getTree());
HamParend137=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitextfidir25398); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitextfidir2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir1_return: (function() {
Ham4Parser.extfidir1_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1466:1: extfidir1 : extfidir ( HamBetween extfidir )? ( HamOrirelative )? -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* ) ;
// $ANTLR start "extfidir1"
extfidir1: function() {
var retval = new Ham4Parser.extfidir1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween139 = null;
var HamOrirelative141 = null;
var extfidir138 = null;
var extfidir140 = null;
var HamBetween139_tree=null;
var HamOrirelative141_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_HamOrirelative=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamOrirelative");
var stream_extfidir=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir");
this.trace("ANTLR Parse: extfidir1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1488:5: ( extfidir ( HamBetween extfidir )? ( HamOrirelative )? -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* ) )
// Ham4Parser.g:1488:9: extfidir ( HamBetween extfidir )? ( HamOrirelative )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir_in_extfidir15429);
extfidir138=this.extfidir();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir.add(extfidir138.getTree());
// Ham4Parser.g:1489:9: ( HamBetween extfidir )?
var alt44=2;
var LA44_0 = this.input.LA(1);
if ( (LA44_0==HamBetween) ) {
alt44=1;
}
switch (alt44) {
case 1 :
// Ham4Parser.g:1490:13: HamBetween extfidir
HamBetween139=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_extfidir15453); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween139);
this.pushFollow(Ham4Parser.FOLLOW_extfidir_in_extfidir15467);
extfidir140=this.extfidir();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir.add(extfidir140.getTree());
break;
}
// Ham4Parser.g:1493:9: ( HamOrirelative )?
var alt45=2;
var LA45_0 = this.input.LA(1);
if ( (LA45_0==HamOrirelative) ) {
alt45=1;
}
switch (alt45) {
case 1 :
// Ham4Parser.g:1494:13: HamOrirelative
HamOrirelative141=this.match(this.input,HamOrirelative,Ham4Parser.FOLLOW_HamOrirelative_in_extfidir15502); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamOrirelative.add(HamOrirelative141);
break;
}
// AST REWRITE
// elements: extfidir, HamOrirelative
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1496:6: -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* )
{
// Ham4Parser.g:1496:9: ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR1, "EXTFIDIR1"), root_1);
// Ham4Parser.g:1496:21: ( extfidir )*
while ( stream_extfidir.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir.nextTree());
}
stream_extfidir.reset();
// Ham4Parser.g:1496:31: ( HamOrirelative )*
while ( stream_HamOrirelative.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamOrirelative.nextNode());
}
stream_HamOrirelative.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidir1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor2_return: (function() {
Ham4Parser.palmor2_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1502:1: palmor2 : ( palmor1 | splitpalmor2 ) -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? ) ;
// $ANTLR start "palmor2"
palmor2: function() {
var retval = new Ham4Parser.palmor2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var palmor1142 = null;
var splitpalmor2143 = null;
var stream_splitpalmor2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitpalmor2");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
this.trace("ANTLR Parse: palmor2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1522:5: ( ( palmor1 | splitpalmor2 ) -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? ) )
// Ham4Parser.g:1523:5: ( palmor1 | splitpalmor2 )
// Ham4Parser.g:1523:5: ( palmor1 | splitpalmor2 )
var alt46=2;
var LA46_0 = this.input.LA(1);
if ( ((LA46_0>=HamPalmu && LA46_0<=HamPalmul)) ) {
alt46=1;
}
else if ( (LA46_0==HamParbegin) ) {
alt46=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 46, 0, this.input);
throw nvae;
}
switch (alt46) {
case 1 :
// Ham4Parser.g:1524:9: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_palmor25574);
palmor1142=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1142.getTree());
break;
case 2 :
// Ham4Parser.g:1526:9: splitpalmor2
this.pushFollow(Ham4Parser.FOLLOW_splitpalmor2_in_palmor25590);
splitpalmor2143=this.splitpalmor2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitpalmor2.add(splitpalmor2143.getTree());
break;
}
// AST REWRITE
// elements: palmor1, splitpalmor2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1528:5: -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? )
{
// Ham4Parser.g:1528:8: ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PALMOR2, "PALMOR2"), root_1);
// Ham4Parser.g:1528:18: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
// Ham4Parser.g:1528:27: ( splitpalmor2 )?
if ( stream_splitpalmor2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitpalmor2.nextTree());
}
stream_splitpalmor2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitpalmor2_return: (function() {
Ham4Parser.splitpalmor2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitpalmor2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1531:1: splitpalmor2 : HamParbegin palmor1 HamPlus palmor1 HamParend ;
// $ANTLR start "splitpalmor2"
splitpalmor2: function() {
var retval = new Ham4Parser.splitpalmor2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin144 = null;
var HamPlus146 = null;
var HamParend148 = null;
var palmor1145 = null;
var palmor1147 = null;
var HamParbegin144_tree=null;
var HamPlus146_tree=null;
var HamParend148_tree=null;
this.trace("ANTLR Parse: splitpalmor2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1549:5: ( HamParbegin palmor1 HamPlus palmor1 HamParend )
// Ham4Parser.g:1549:9: HamParbegin palmor1 HamPlus palmor1 HamParend
root_0 = this.adaptor.nil();
HamParbegin144=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitpalmor25641); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_splitpalmor25653);
palmor1145=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, palmor1145.getTree());
HamPlus146=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitpalmor25663); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_splitpalmor25675);
palmor1147=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, palmor1147.getTree());
HamParend148=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitpalmor25685); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitpalmor2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor1_return: (function() {
Ham4Parser.palmor1_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1556:1: palmor1 : palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )? -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* ) ;
// $ANTLR start "palmor1"
palmor1: function() {
var retval = new Ham4Parser.palmor1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween150 = null;
var HamEtc152 = null;
var HamOrirelative153 = null;
var palmor149 = null;
var palmor151 = null;
var HamBetween150_tree=null;
var HamEtc152_tree=null;
var HamOrirelative153_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_HamOrirelative=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamOrirelative");
var stream_palmor=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor");
this.trace("ANTLR Parse: palmor1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1580:5: ( palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )? -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* ) )
// Ham4Parser.g:1580:9: palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )?
this.pushFollow(Ham4Parser.FOLLOW_palmor_in_palmor15716);
palmor149=this.palmor();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor.add(palmor149.getTree());
// Ham4Parser.g:1581:9: ( HamBetween palmor | HamEtc )?
var alt47=3;
var LA47_0 = this.input.LA(1);
if ( (LA47_0==HamBetween) ) {
alt47=1;
}
else if ( (LA47_0==HamEtc) ) {
alt47=2;
}
switch (alt47) {
case 1 :
// Ham4Parser.g:1582:13: HamBetween palmor
HamBetween150=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_palmor15740); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween150);
this.pushFollow(Ham4Parser.FOLLOW_palmor_in_palmor15754);
palmor151=this.palmor();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor.add(palmor151.getTree());
break;
case 2 :
// Ham4Parser.g:1585:7: HamEtc
HamEtc152=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_palmor15772); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc152);
break;
}
// Ham4Parser.g:1587:9: ( HamOrirelative )?
var alt48=2;
var LA48_0 = this.input.LA(1);
if ( (LA48_0==HamOrirelative) ) {
alt48=1;
}
switch (alt48) {
case 1 :
// Ham4Parser.g:1588:13: HamOrirelative
HamOrirelative153=this.match(this.input,HamOrirelative,Ham4Parser.FOLLOW_HamOrirelative_in_palmor15807); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamOrirelative.add(HamOrirelative153);
break;
}
// AST REWRITE
// elements: palmor, HamOrirelative, HamEtc
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1590:6: -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* )
{
// Ham4Parser.g:1590:9: ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PALMOR1, "PALMOR1"), root_1);
// Ham4Parser.g:1590:19: ( palmor )*
while ( stream_palmor.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor.nextTree());
}
stream_palmor.reset();
// Ham4Parser.g:1590:27: ( HamEtc )*
while ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:1590:35: ( HamOrirelative )*
while ( stream_HamOrirelative.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamOrirelative.nextNode());
}
stream_HamOrirelative.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location2_return: (function() {
Ham4Parser.location2_return = function(){};
org.antlr.lang.extend(Ham4Parser.location2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1596:1: location2 : ( location1as2 | location2not1 ) ;
// $ANTLR start "location2"
location2: function() {
var retval = new Ham4Parser.location2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var location1as2154 = null;
var location2not1155 = null;
this.trace("ANTLR Parse: location2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1615:5: ( ( location1as2 | location2not1 ) )
// Ham4Parser.g:1616:5: ( location1as2 | location2not1 )
root_0 = this.adaptor.nil();
// Ham4Parser.g:1616:5: ( location1as2 | location2not1 )
var alt49=2;
alt49 = this.dfa49.predict(this.input);
switch (alt49) {
case 1 :
// Ham4Parser.g:1617:9: location1as2
this.pushFollow(Ham4Parser.FOLLOW_location1as2_in_location25882);
location1as2154=this.location1as2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location1as2154.getTree());
break;
case 2 :
// Ham4Parser.g:1619:9: location2not1
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_location25898);
location2not1155=this.location2not1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location2not1155.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location1as2_return: (function() {
Ham4Parser.location1as2_return = function(){};
org.antlr.lang.extend(Ham4Parser.location1as2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1623:1: location1as2 : location1 -> ^( LOC2 location1 ) ;
// $ANTLR start "location1as2"
location1as2: function() {
var retval = new Ham4Parser.location1as2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var location1156 = null;
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
this.trace("ANTLR Parse: location1as2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1638:5: ( location1 -> ^( LOC2 location1 ) )
// Ham4Parser.g:1638:9: location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location1as25933);
location1156=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1156.getTree());
// AST REWRITE
// elements: location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1639:6: -> ^( LOC2 location1 )
{
// Ham4Parser.g:1639:9: ^( LOC2 location1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
this.adaptor.addChild(root_1, stream_location1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location1as2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location2not1_return: (function() {
Ham4Parser.location2not1_return = function(){};
org.antlr.lang.extend(Ham4Parser.location2not1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1642:1: location2not1 : ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) ) ;
// $ANTLR start "location2not1"
location2not1: function() {
var retval = new Ham4Parser.location2not1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNeutralspace158 = null;
var HamArmextended159 = null;
var HamParbegin161 = null;
var HamPlus163 = null;
var HamParend165 = null;
var handconstellation157 = null;
var locationbody160 = null;
var location1162 = null;
var location1164 = null;
var HamNeutralspace158_tree=null;
var HamArmextended159_tree=null;
var HamParbegin161_tree=null;
var HamPlus163_tree=null;
var HamParend165_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_HamNeutralspace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNeutralspace");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_locationbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbody");
var stream_handconstellation=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconstellation");
this.trace("ANTLR Parse: location2not1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1675:5: ( ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) ) )
// Ham4Parser.g:1676:5: ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) )
// Ham4Parser.g:1676:5: ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) )
var alt53=2;
var LA53_0 = this.input.LA(1);
if ( (LA53_0==HamParbegin) ) {
var LA53_1 = this.input.LA(2);
if ( (this.synpred19_Ham4Parser()) ) {
alt53=1;
}
else if ( (true) ) {
alt53=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 53, 1, this.input);
throw nvae;
}
}
else if ( ((LA53_0>=HamClose && LA53_0<=HamTouch)) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else if ( ((LA53_0>=HamInterlock && LA53_0<=HamCross)) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else if ( (LA53_0==HamSeqbegin) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 53, 0, this.input);
throw nvae;
}
switch (alt53) {
case 1 :
// Ham4Parser.g:1677:9: ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? )
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_location2not16011);
handconstellation157=this.handconstellation();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconstellation.add(handconstellation157.getTree());
// Ham4Parser.g:1680:9: ( HamNeutralspace ( HamArmextended )? | ( locationbody )? )
var alt52=2;
var LA52_0 = this.input.LA(1);
if ( (LA52_0==HamNeutralspace) ) {
alt52=1;
}
else if ( (LA52_0==EOF||LA52_0==HamPlus||(LA52_0>=HamEarlobe && LA52_0<=HamShouldertop)||LA52_0==HamReplace||(LA52_0>=HamTongue && LA52_0<=HamStomach)||(LA52_0>=HamHead && LA52_0<=HamLrat)||(LA52_0>=HamNomotion && LA52_0<=HamMovex)||(LA52_0>=HamFingerplay && LA52_0<=HamCircler)||(LA52_0>=HamRepeatfromstart && LA52_0<=HamRepeatreverse)||(LA52_0>=HamNodding && LA52_0<=HamCircleuo)) ) {
alt52=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 52, 0, this.input);
throw nvae;
}
switch (alt52) {
case 1 :
// Ham4Parser.g:1681:13: HamNeutralspace ( HamArmextended )?
HamNeutralspace158=this.match(this.input,HamNeutralspace,Ham4Parser.FOLLOW_HamNeutralspace_in_location2not16035); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNeutralspace.add(HamNeutralspace158);
// Ham4Parser.g:1682:13: ( HamArmextended )?
var alt50=2;
var LA50_0 = this.input.LA(1);
if ( (LA50_0==HamArmextended) ) {
alt50=1;
}
switch (alt50) {
case 1 :
// Ham4Parser.g:1682:15: HamArmextended
HamArmextended159=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_location2not16051); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended159);
break;
}
break;
case 2 :
// Ham4Parser.g:1684:13: ( locationbody )?
// Ham4Parser.g:1684:13: ( locationbody )?
var alt51=2;
var LA51_0 = this.input.LA(1);
if ( ((LA51_0>=HamEarlobe && LA51_0<=HamShouldertop)||(LA51_0>=HamTongue && LA51_0<=HamStomach)||(LA51_0>=HamHead && LA51_0<=HamLrat)) ) {
alt51=1;
}
switch (alt51) {
case 1 :
// Ham4Parser.g:1684:15: locationbody
this.pushFollow(Ham4Parser.FOLLOW_locationbody_in_location2not16080);
locationbody160=this.locationbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbody.add(locationbody160.getTree());
break;
}
break;
}
// AST REWRITE
// elements: HamArmextended, locationbody, handconstellation
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1686:6: -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? )
{
// Ham4Parser.g:1686:9: ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
this.adaptor.addChild(root_1, stream_handconstellation.nextTree());
// Ham4Parser.g:1686:34: ( HamArmextended )?
if ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:1686:50: ( locationbody )?
if ( stream_locationbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbody.nextTree());
}
stream_locationbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:1688:9: HamParbegin location1 HamPlus location1 HamParend
HamParbegin161=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_location2not16128); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin161);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location2not16138);
location1162=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1162.getTree());
HamPlus163=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_location2not16148); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus163);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location2not16158);
location1164=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1164.getTree());
HamParend165=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_location2not16168); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend165);
// AST REWRITE
// elements: location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1693:6: -> ^( LOC2 ( location1 )* )
{
// Ham4Parser.g:1693:9: ^( LOC2 ( location1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
// Ham4Parser.g:1693:16: ( location1 )*
while ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location2not1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location1_return: (function() {
Ham4Parser.location1_return = function(){};
org.antlr.lang.extend(Ham4Parser.location1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1697:1: location1 : ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm ) -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? ) ;
// $ANTLR start "location1"
location1: function() {
var retval = new Ham4Parser.location1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var locationindexuse166 = null;
var locationhand167 = null;
var locationbodyarm168 = null;
var stream_locationindexuse=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationindexuse");
var stream_locationhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationhand");
var stream_locationbodyarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbodyarm");
this.trace("ANTLR Parse: location1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1723:5: ( ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm ) -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? ) )
// Ham4Parser.g:1724:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )
// Ham4Parser.g:1724:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )
var alt54=3;
alt54 = this.dfa54.predict(this.input);
switch (alt54) {
case 1 :
// Ham4Parser.g:1725:9: ( locationindexuse )=> locationindexuse
this.pushFollow(Ham4Parser.FOLLOW_locationindexuse_in_location16273);
locationindexuse166=this.locationindexuse();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationindexuse.add(locationindexuse166.getTree());
break;
case 2 :
// Ham4Parser.g:1729:9: ( levelhand )=> locationhand
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_location16313);
locationhand167=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand167.getTree());
break;
case 3 :
// Ham4Parser.g:1733:9: locationbodyarm
this.pushFollow(Ham4Parser.FOLLOW_locationbodyarm_in_location16329);
locationbodyarm168=this.locationbodyarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbodyarm.add(locationbodyarm168.getTree());
break;
}
// AST REWRITE
// elements: locationindexuse, locationbodyarm, locationhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1735:5: -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? )
{
// Ham4Parser.g:1735:8: ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC1, "LOC1"), root_1);
// Ham4Parser.g:1735:15: ( locationindexuse )?
if ( stream_locationindexuse.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationindexuse.nextTree());
}
stream_locationindexuse.reset();
// Ham4Parser.g:1735:33: ( locationhand )?
if ( stream_locationhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationhand.nextTree());
}
stream_locationhand.reset();
// Ham4Parser.g:1735:47: ( locationbodyarm )?
if ( stream_locationbodyarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbodyarm.nextTree());
}
stream_locationbodyarm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationindexdefine_return: (function() {
Ham4Parser.locationindexdefine_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationindexdefine_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1738:1: locationindexdefine : digit HamCoreftag ;
// $ANTLR start "locationindexdefine"
locationindexdefine: function() {
var retval = new Ham4Parser.locationindexdefine_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamCoreftag170 = null;
var digit169 = null;
var HamCoreftag170_tree=null;
this.trace("ANTLR Parse: locationindexdefine starts "+this.state.backtracking);
try {
// Ham4Parser.g:1754:5: ( digit HamCoreftag )
// Ham4Parser.g:1755:9: digit HamCoreftag
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_digit_in_locationindexdefine6389);
digit169=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit169.getTree());
HamCoreftag170=this.match(this.input,HamCoreftag,Ham4Parser.FOLLOW_HamCoreftag_in_locationindexdefine6399); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationindexdefine finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationindexuse_return: (function() {
Ham4Parser.locationindexuse_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationindexuse_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1759:1: locationindexuse : digit HamCorefref ;
// $ANTLR start "locationindexuse"
locationindexuse: function() {
var retval = new Ham4Parser.locationindexuse_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamCorefref172 = null;
var digit171 = null;
var HamCorefref172_tree=null;
this.trace("ANTLR Parse: locationindexuse starts "+this.state.backtracking);
try {
// Ham4Parser.g:1775:5: ( digit HamCorefref )
// Ham4Parser.g:1776:9: digit HamCorefref
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_digit_in_locationindexuse6436);
digit171=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit171.getTree());
HamCorefref172=this.match(this.input,HamCorefref,Ham4Parser.FOLLOW_HamCorefref_in_locationindexuse6446); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationindexuse finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationbodyarm_return: (function() {
Ham4Parser.locationbodyarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationbodyarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1780:1: locationbodyarm : ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm ) -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* ) ;
// $ANTLR start "locationbodyarm"
locationbodyarm: function() {
var retval = new Ham4Parser.locationbodyarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNeutralspace173 = null;
var HamArmextended174 = null;
var locationbody175 = null;
var locationarm176 = null;
var HamNeutralspace173_tree=null;
var HamArmextended174_tree=null;
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_HamNeutralspace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNeutralspace");
var stream_locationbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbody");
var stream_locationarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationarm");
this.trace("ANTLR Parse: locationbodyarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1805:5: ( ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm ) -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* ) )
// Ham4Parser.g:1806:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )
// Ham4Parser.g:1806:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )
var alt56=3;
alt56 = this.dfa56.predict(this.input);
switch (alt56) {
case 1 :
// Ham4Parser.g:1807:9: HamNeutralspace ( HamArmextended )?
HamNeutralspace173=this.match(this.input,HamNeutralspace,Ham4Parser.FOLLOW_HamNeutralspace_in_locationbodyarm6489); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNeutralspace.add(HamNeutralspace173);
// Ham4Parser.g:1808:9: ( HamArmextended )?
var alt55=2;
var LA55_0 = this.input.LA(1);
if ( (LA55_0==HamArmextended) ) {
alt55=1;
}
switch (alt55) {
case 1 :
// Ham4Parser.g:1808:11: HamArmextended
HamArmextended174=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_locationbodyarm6501); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended174);
break;
}
break;
case 2 :
// Ham4Parser.g:1810:9: ( levelbody )=> locationbody
this.pushFollow(Ham4Parser.FOLLOW_locationbody_in_locationbodyarm6544);
locationbody175=this.locationbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbody.add(locationbody175.getTree());
break;
case 3 :
// Ham4Parser.g:1814:9: locationarm
this.pushFollow(Ham4Parser.FOLLOW_locationarm_in_locationbodyarm6560);
locationarm176=this.locationarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationarm.add(locationarm176.getTree());
break;
}
// AST REWRITE
// elements: HamArmextended, locationarm, locationbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1816:5: -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* )
{
// Ham4Parser.g:1816:8: ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNBODYARM, "LOCTNBODYARM"), root_1);
// Ham4Parser.g:1816:23: ( HamArmextended )*
while ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:1816:39: ( locationbody )*
while ( stream_locationbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbody.nextTree());
}
stream_locationbody.reset();
// Ham4Parser.g:1816:53: ( locationarm )*
while ( stream_locationarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationarm.nextTree());
}
stream_locationarm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationbodyarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationbody_return: (function() {
Ham4Parser.locationbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1819:1: locationbody : levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? ) ;
// $ANTLR start "locationbody"
locationbody: function() {
var retval = new Ham4Parser.locationbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBehind178 = null;
var levelcomplexbody177 = null;
var contactbody179 = null;
var HamBehind178_tree=null;
var stream_HamBehind=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBehind");
var stream_levelcomplexbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexbody");
var stream_contactbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactbody");
this.trace("ANTLR Parse: locationbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1837:5: ( levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? ) )
// Ham4Parser.g:1837:9: levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexbody_in_locationbody6614);
levelcomplexbody177=this.levelcomplexbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexbody.add(levelcomplexbody177.getTree());
// Ham4Parser.g:1838:9: ( HamBehind )?
var alt57=2;
alt57 = this.dfa57.predict(this.input);
switch (alt57) {
case 1 :
// Ham4Parser.g:1838:11: HamBehind
HamBehind178=this.match(this.input,HamBehind,Ham4Parser.FOLLOW_HamBehind_in_locationbody6626); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBehind.add(HamBehind178);
break;
}
// Ham4Parser.g:1839:9: ( ( contactbody )=> contactbody )?
var alt58=2;
alt58 = this.dfa58.predict(this.input);
switch (alt58) {
case 1 :
// Ham4Parser.g:1839:11: ( contactbody )=> contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_locationbody6649);
contactbody179=this.contactbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactbody.add(contactbody179.getTree());
break;
}
// AST REWRITE
// elements: HamBehind, levelcomplexbody, contactbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1841:7: -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? )
{
// Ham4Parser.g:1841:10: ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNBODY, "LOCTNBODY"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexbody.nextTree());
// Ham4Parser.g:1841:39: ( HamBehind )?
if ( stream_HamBehind.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamBehind.nextNode());
}
stream_HamBehind.reset();
// Ham4Parser.g:1841:50: ( contactbody )?
if ( stream_contactbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactbody.nextTree());
}
stream_contactbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationhand_return: (function() {
Ham4Parser.locationhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1844:1: locationhand : levelcomplexhand ( ( contacthand )=> contacthand )? -> ^( LOCTNHAND levelcomplexhand ( contacthand )? ) ;
// $ANTLR start "locationhand"
locationhand: function() {
var retval = new Ham4Parser.locationhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexhand180 = null;
var contacthand181 = null;
var stream_levelcomplexhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexhand");
var stream_contacthand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contacthand");
this.trace("ANTLR Parse: locationhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:1861:5: ( levelcomplexhand ( ( contacthand )=> contacthand )? -> ^( LOCTNHAND levelcomplexhand ( contacthand )? ) )
// Ham4Parser.g:1861:9: levelcomplexhand ( ( contacthand )=> contacthand )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexhand_in_locationhand6710);
levelcomplexhand180=this.levelcomplexhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexhand.add(levelcomplexhand180.getTree());
// Ham4Parser.g:1862:9: ( ( contacthand )=> contacthand )?
var alt59=2;
alt59 = this.dfa59.predict(this.input);
switch (alt59) {
case 1 :
// Ham4Parser.g:1862:11: ( contacthand )=> contacthand
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_locationhand6728);
contacthand181=this.contacthand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contacthand.add(contacthand181.getTree());
break;
}
// AST REWRITE
// elements: levelcomplexhand, contacthand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1864:7: -> ^( LOCTNHAND levelcomplexhand ( contacthand )? )
{
// Ham4Parser.g:1864:10: ^( LOCTNHAND levelcomplexhand ( contacthand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNHAND, "LOCTNHAND"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexhand.nextTree());
// Ham4Parser.g:1864:39: ( contacthand )?
if ( stream_contacthand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contacthand.nextTree());
}
stream_contacthand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationarm_return: (function() {
Ham4Parser.locationarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1867:1: locationarm : levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? ) ;
// $ANTLR start "locationarm"
locationarm: function() {
var retval = new Ham4Parser.locationarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBehind183 = null;
var levelcomplexarm182 = null;
var contactbody184 = null;
var HamBehind183_tree=null;
var stream_HamBehind=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBehind");
var stream_contactbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactbody");
var stream_levelcomplexarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexarm");
this.trace("ANTLR Parse: locationarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1885:5: ( levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? ) )
// Ham4Parser.g:1885:9: levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexarm_in_locationarm6786);
levelcomplexarm182=this.levelcomplexarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexarm.add(levelcomplexarm182.getTree());
// Ham4Parser.g:1886:9: ( HamBehind )?
var alt60=2;
alt60 = this.dfa60.predict(this.input);
switch (alt60) {
case 1 :
// Ham4Parser.g:1886:11: HamBehind
HamBehind183=this.match(this.input,HamBehind,Ham4Parser.FOLLOW_HamBehind_in_locationarm6798); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBehind.add(HamBehind183);
break;
}
// Ham4Parser.g:1887:9: ( ( contactbody )=> contactbody )?
var alt61=2;
alt61 = this.dfa61.predict(this.input);
switch (alt61) {
case 1 :
// Ham4Parser.g:1887:11: ( contactbody )=> contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_locationarm6821);
contactbody184=this.contactbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactbody.add(contactbody184.getTree());
break;
}
// AST REWRITE
// elements: levelcomplexarm, contactbody, HamBehind
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1889:7: -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? )
{
// Ham4Parser.g:1889:10: ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNARM, "LOCTNARM"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexarm.nextTree());
// Ham4Parser.g:1889:37: ( HamBehind )?
if ( stream_HamBehind.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamBehind.nextNode());
}
stream_HamBehind.reset();
// Ham4Parser.g:1889:48: ( contactbody )?
if ( stream_contactbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactbody.nextTree());
}
stream_contactbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexbody_return: (function() {
Ham4Parser.levelcomplexbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1892:1: levelcomplexbody : levelbody ( HamBetween levelbody )? ;
// $ANTLR start "levelcomplexbody"
levelcomplexbody: function() {
var retval = new Ham4Parser.levelcomplexbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween186 = null;
var levelbody185 = null;
var levelbody187 = null;
var HamBetween186_tree=null;
this.trace("ANTLR Parse: levelcomplexbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1910:5: ( levelbody ( HamBetween levelbody )? )
// Ham4Parser.g:1910:9: levelbody ( HamBetween levelbody )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_levelcomplexbody6882);
levelbody185=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelbody185.getTree());
// Ham4Parser.g:1911:9: ( HamBetween levelbody )?
var alt62=2;
var LA62_0 = this.input.LA(1);
if ( (LA62_0==HamBetween) ) {
alt62=1;
}
switch (alt62) {
case 1 :
// Ham4Parser.g:1912:13: HamBetween levelbody
HamBetween186=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexbody6906); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_levelcomplexbody6922);
levelbody187=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelbody187.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexhand_return: (function() {
Ham4Parser.levelcomplexhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1917:1: levelcomplexhand : levelhand ( HamBetween levelhand )? ;
// $ANTLR start "levelcomplexhand"
levelcomplexhand: function() {
var retval = new Ham4Parser.levelcomplexhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween189 = null;
var levelhand188 = null;
var levelhand190 = null;
var HamBetween189_tree=null;
this.trace("ANTLR Parse: levelcomplexhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:1935:5: ( levelhand ( HamBetween levelhand )? )
// Ham4Parser.g:1935:9: levelhand ( HamBetween levelhand )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_levelcomplexhand6962);
levelhand188=this.levelhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelhand188.getTree());
// Ham4Parser.g:1936:9: ( HamBetween levelhand )?
var alt63=2;
var LA63_0 = this.input.LA(1);
if ( (LA63_0==HamBetween) ) {
alt63=1;
}
switch (alt63) {
case 1 :
// Ham4Parser.g:1937:13: HamBetween levelhand
HamBetween189=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexhand6986); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_levelcomplexhand7002);
levelhand190=this.levelhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelhand190.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexarm_return: (function() {
Ham4Parser.levelcomplexarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1942:1: levelcomplexarm : levelarm ( HamBetween levelarm )? ;
// $ANTLR start "levelcomplexarm"
levelcomplexarm: function() {
var retval = new Ham4Parser.levelcomplexarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween192 = null;
var levelarm191 = null;
var levelarm193 = null;
var HamBetween192_tree=null;
this.trace("ANTLR Parse: levelcomplexarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1960:5: ( levelarm ( HamBetween levelarm )? )
// Ham4Parser.g:1960:9: levelarm ( HamBetween levelarm )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_levelcomplexarm7042);
levelarm191=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelarm191.getTree());
// Ham4Parser.g:1961:9: ( HamBetween levelarm )?
var alt64=2;
var LA64_0 = this.input.LA(1);
if ( (LA64_0==HamBetween) ) {
alt64=1;
}
switch (alt64) {
case 1 :
// Ham4Parser.g:1962:13: HamBetween levelarm
HamBetween192=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexarm7066); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_levelcomplexarm7082);
levelarm193=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelarm193.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelbody_return: (function() {
Ham4Parser.levelbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1967:1: levelbody : ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) ) ;
// $ANTLR start "levelbody"
levelbody: function() {
var retval = new Ham4Parser.levelbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamEtc195 = null;
var HamEtc198 = null;
var HamEtc202 = null;
var HamEtc204 = null;
var locbody194 = null;
var side196 = null;
var locsided197 = null;
var side199 = null;
var side200 = null;
var locbody201 = null;
var locsided203 = null;
var HamEtc195_tree=null;
var HamEtc198_tree=null;
var HamEtc202_tree=null;
var HamEtc204_tree=null;
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_locsided=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locsided");
var stream_locbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locbody");
this.trace("ANTLR Parse: levelbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:2002:5: ( ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) ) )
// Ham4Parser.g:2003:5: ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) )
// Ham4Parser.g:2003:5: ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) )
var alt72=3;
switch ( this.input.LA(1) ) {
case HamNostrils:
case HamShouldertop:
case HamTongue:
case HamTeeth:
case HamStomach:
case HamHead:
case HamHeadtop:
case HamForehead:
case HamEyebrows:
case HamEyes:
case HamNose:
case HamLips:
case HamChin:
case HamUnderchin:
case HamNeck:
case HamShoulders:
case HamChest:
case HamBelowstomach:
alt72=1;
break;
case HamEarlobe:
case HamEar:
case HamCheek:
alt72=2;
break;
case HamLrbeside:
case HamLrat:
alt72=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 72, 0, this.input);
throw nvae;
}
switch (alt72) {
case 1 :
// Ham4Parser.g:2004:9: locbody ( HamEtc )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locbody_in_levelbody7134);
locbody194=this.locbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbody.add(locbody194.getTree());
// Ham4Parser.g:2005:9: ( HamEtc )?
var alt65=2;
var LA65_0 = this.input.LA(1);
if ( (LA65_0==HamEtc) ) {
alt65=1;
}
switch (alt65) {
case 1 :
// Ham4Parser.g:2005:11: HamEtc
HamEtc195=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7146); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc195);
break;
}
// Ham4Parser.g:2006:9: ( side )?
var alt66=2;
var LA66_0 = this.input.LA(1);
if ( ((LA66_0>=HamLrbeside && LA66_0<=HamLrat)) ) {
alt66=1;
}
switch (alt66) {
case 1 :
// Ham4Parser.g:2006:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7161);
side196=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side196.getTree());
break;
}
// AST REWRITE
// elements: locbody, HamEtc, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2007:6: -> ^( LEVBODY locbody ( HamEtc )? ( side )? )
{
// Ham4Parser.g:2007:9: ^( LEVBODY locbody ( HamEtc )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_locbody.nextTree());
// Ham4Parser.g:2007:27: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2007:35: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2009:9: locsided ( HamEtc )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locsided_in_levelbody7199);
locsided197=this.locsided();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locsided.add(locsided197.getTree());
// Ham4Parser.g:2010:9: ( HamEtc )?
var alt67=2;
var LA67_0 = this.input.LA(1);
if ( (LA67_0==HamEtc) ) {
alt67=1;
}
switch (alt67) {
case 1 :
// Ham4Parser.g:2010:11: HamEtc
HamEtc198=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7211); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc198);
break;
}
// Ham4Parser.g:2011:9: ( side )?
var alt68=2;
var LA68_0 = this.input.LA(1);
if ( ((LA68_0>=HamLrbeside && LA68_0<=HamLrat)) ) {
alt68=1;
}
switch (alt68) {
case 1 :
// Ham4Parser.g:2011:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7226);
side199=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side199.getTree());
break;
}
// AST REWRITE
// elements: locsided, HamEtc, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2012:6: -> ^( LEVBODY locsided ( HamEtc )? ( side )? )
{
// Ham4Parser.g:2012:9: ^( LEVBODY locsided ( HamEtc )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_locsided.nextTree());
// Ham4Parser.g:2012:28: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2012:36: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2014:9: side ( locbody ( HamEtc )? | locsided ( HamEtc )? )
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7264);
side200=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side200.getTree());
// Ham4Parser.g:2015:9: ( locbody ( HamEtc )? | locsided ( HamEtc )? )
var alt71=2;
var LA71_0 = this.input.LA(1);
if ( ((LA71_0>=HamNostrils && LA71_0<=HamShouldertop)||(LA71_0>=HamTongue && LA71_0<=HamStomach)||(LA71_0>=HamHead && LA71_0<=HamNose)||(LA71_0>=HamLips && LA71_0<=HamBelowstomach)) ) {
alt71=1;
}
else if ( (LA71_0==HamEarlobe||(LA71_0>=HamEar && LA71_0<=HamCheek)) ) {
alt71=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 71, 0, this.input);
throw nvae;
}
switch (alt71) {
case 1 :
// Ham4Parser.g:2016:13: locbody ( HamEtc )?
this.pushFollow(Ham4Parser.FOLLOW_locbody_in_levelbody7288);
locbody201=this.locbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbody.add(locbody201.getTree());
// Ham4Parser.g:2017:13: ( HamEtc )?
var alt69=2;
var LA69_0 = this.input.LA(1);
if ( (LA69_0==HamEtc) ) {
alt69=1;
}
switch (alt69) {
case 1 :
// Ham4Parser.g:2017:15: HamEtc
HamEtc202=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7304); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc202);
break;
}
break;
case 2 :
// Ham4Parser.g:2019:13: locsided ( HamEtc )?
this.pushFollow(Ham4Parser.FOLLOW_locsided_in_levelbody7331);
locsided203=this.locsided();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locsided.add(locsided203.getTree());
// Ham4Parser.g:2020:13: ( HamEtc )?
var alt70=2;
var LA70_0 = this.input.LA(1);
if ( (LA70_0==HamEtc) ) {
alt70=1;
}
switch (alt70) {
case 1 :
// Ham4Parser.g:2020:15: HamEtc
HamEtc204=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7347); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc204);
break;
}
break;
}
// AST REWRITE
// elements: locbody, side, HamEtc, locsided
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2022:6: -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? )
{
// Ham4Parser.g:2022:9: ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
// Ham4Parser.g:2022:24: ( locbody )?
if ( stream_locbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locbody.nextTree());
}
stream_locbody.reset();
// Ham4Parser.g:2022:33: ( locsided )?
if ( stream_locsided.hasNext() ) {
this.adaptor.addChild(root_1, stream_locsided.nextTree());
}
stream_locsided.reset();
// Ham4Parser.g:2022:43: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelhand_return: (function() {
Ham4Parser.levelhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2026:1: levelhand : ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) ) ;
// $ANTLR start "levelhand"
levelhand: function() {
var retval = new Ham4Parser.levelhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var lochand205 = null;
var dorsalorpalmar206 = null;
var side207 = null;
var side208 = null;
var lochand209 = null;
var dorsalorpalmar210 = null;
var stream_lochand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule lochand");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_dorsalorpalmar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dorsalorpalmar");
this.trace("ANTLR Parse: levelhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2051:5: ( ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) ) )
// Ham4Parser.g:2052:5: ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) )
// Ham4Parser.g:2052:5: ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) )
var alt76=2;
var LA76_0 = this.input.LA(1);
if ( ((LA76_0>=HamWristback && LA76_0<=HamPinkyside)||(LA76_0>=HamFingertip && LA76_0<=HamFingerside)) ) {
alt76=1;
}
else if ( ((LA76_0>=HamLrbeside && LA76_0<=HamLrat)) ) {
alt76=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 76, 0, this.input);
throw nvae;
}
switch (alt76) {
case 1 :
// Ham4Parser.g:2053:9: lochand ( dorsalorpalmar )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_lochand_in_levelhand7429);
lochand205=this.lochand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_lochand.add(lochand205.getTree());
// Ham4Parser.g:2054:9: ( dorsalorpalmar )?
var alt73=2;
var LA73_0 = this.input.LA(1);
if ( ((LA73_0>=HamPalm && LA73_0<=HamHandback)) ) {
alt73=1;
}
switch (alt73) {
case 1 :
// Ham4Parser.g:2054:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelhand7441);
dorsalorpalmar206=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar206.getTree());
break;
}
// Ham4Parser.g:2055:9: ( side )?
var alt74=2;
var LA74_0 = this.input.LA(1);
if ( ((LA74_0>=HamLrbeside && LA74_0<=HamLrat)) ) {
alt74=1;
}
switch (alt74) {
case 1 :
// Ham4Parser.g:2055:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelhand7456);
side207=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side207.getTree());
break;
}
// AST REWRITE
// elements: dorsalorpalmar, lochand, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2056:5: -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? )
{
// Ham4Parser.g:2056:8: ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVHAND, "LEVHAND"), root_1);
this.adaptor.addChild(root_1, stream_lochand.nextTree());
// Ham4Parser.g:2056:26: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
// Ham4Parser.g:2056:42: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2058:9: side lochand ( dorsalorpalmar )?
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelhand7496);
side208=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side208.getTree());
this.pushFollow(Ham4Parser.FOLLOW_lochand_in_levelhand7506);
lochand209=this.lochand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_lochand.add(lochand209.getTree());
// Ham4Parser.g:2060:9: ( dorsalorpalmar )?
var alt75=2;
var LA75_0 = this.input.LA(1);
if ( ((LA75_0>=HamPalm && LA75_0<=HamHandback)) ) {
alt75=1;
}
switch (alt75) {
case 1 :
// Ham4Parser.g:2060:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelhand7518);
dorsalorpalmar210=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar210.getTree());
break;
}
// AST REWRITE
// elements: side, lochand, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2061:5: -> ^( LEVHAND side lochand ( dorsalorpalmar )? )
{
// Ham4Parser.g:2061:8: ^( LEVHAND side lochand ( dorsalorpalmar )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVHAND, "LEVHAND"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
this.adaptor.addChild(root_1, stream_lochand.nextTree());
// Ham4Parser.g:2061:31: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelarm_return: (function() {
Ham4Parser.levelarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2065:1: levelarm : ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) ) ;
// $ANTLR start "levelarm"
levelarm: function() {
var retval = new Ham4Parser.levelarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamEtc212 = null;
var HamEtc217 = null;
var locarm211 = null;
var dorsalorpalmar213 = null;
var side214 = null;
var side215 = null;
var locarm216 = null;
var dorsalorpalmar218 = null;
var HamEtc212_tree=null;
var HamEtc217_tree=null;
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_dorsalorpalmar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dorsalorpalmar");
var stream_locarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locarm");
this.trace("ANTLR Parse: levelarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:2092:5: ( ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) ) )
// Ham4Parser.g:2093:5: ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) )
// Ham4Parser.g:2093:5: ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) )
var alt82=2;
var LA82_0 = this.input.LA(1);
if ( ((LA82_0>=HamUpperarm && LA82_0<=HamLowerarm)) ) {
alt82=1;
}
else if ( ((LA82_0>=HamLrbeside && LA82_0<=HamLrat)) ) {
alt82=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 82, 0, this.input);
throw nvae;
}
switch (alt82) {
case 1 :
// Ham4Parser.g:2094:9: locarm ( HamEtc )? ( dorsalorpalmar )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locarm_in_levelarm7585);
locarm211=this.locarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locarm.add(locarm211.getTree());
// Ham4Parser.g:2095:9: ( HamEtc )?
var alt77=2;
var LA77_0 = this.input.LA(1);
if ( (LA77_0==HamEtc) ) {
alt77=1;
}
switch (alt77) {
case 1 :
// Ham4Parser.g:2095:11: HamEtc
HamEtc212=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelarm7597); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc212);
break;
}
// Ham4Parser.g:2096:9: ( dorsalorpalmar )?
var alt78=2;
var LA78_0 = this.input.LA(1);
if ( ((LA78_0>=HamPalm && LA78_0<=HamHandback)) ) {
alt78=1;
}
switch (alt78) {
case 1 :
// Ham4Parser.g:2096:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelarm7612);
dorsalorpalmar213=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar213.getTree());
break;
}
// Ham4Parser.g:2097:9: ( side )?
var alt79=2;
var LA79_0 = this.input.LA(1);
if ( ((LA79_0>=HamLrbeside && LA79_0<=HamLrat)) ) {
alt79=1;
}
switch (alt79) {
case 1 :
// Ham4Parser.g:2097:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelarm7627);
side214=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side214.getTree());
break;
}
// AST REWRITE
// elements: side, locarm, HamEtc, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2098:6: -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? )
{
// Ham4Parser.g:2098:9: ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVARM, "LEVARM"), root_1);
this.adaptor.addChild(root_1, stream_locarm.nextTree());
// Ham4Parser.g:2098:25: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2098:33: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
// Ham4Parser.g:2098:49: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2100:9: side locarm ( HamEtc )? ( dorsalorpalmar )?
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelarm7668);
side215=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side215.getTree());
this.pushFollow(Ham4Parser.FOLLOW_locarm_in_levelarm7678);
locarm216=this.locarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locarm.add(locarm216.getTree());
// Ham4Parser.g:2102:9: ( HamEtc )?
var alt80=2;
var LA80_0 = this.input.LA(1);
if ( (LA80_0==HamEtc) ) {
alt80=1;
}
switch (alt80) {
case 1 :
// Ham4Parser.g:2102:11: HamEtc
HamEtc217=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelarm7690); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc217);
break;
}
// Ham4Parser.g:2103:9: ( dorsalorpalmar )?
var alt81=2;
var LA81_0 = this.input.LA(1);
if ( ((LA81_0>=HamPalm && LA81_0<=HamHandback)) ) {
alt81=1;
}
switch (alt81) {
case 1 :
// Ham4Parser.g:2103:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelarm7705);
dorsalorpalmar218=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar218.getTree());
break;
}
// AST REWRITE
// elements: locarm, HamEtc, side, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2104:6: -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? )
{
// Ham4Parser.g:2104:9: ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVARM, "LEVARM"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
this.adaptor.addChild(root_1, stream_locarm.nextTree());
// Ham4Parser.g:2104:30: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2104:38: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactbody_return: (function() {
Ham4Parser.contactbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2108:1: contactbody : ( pcontact | HamArmextended | contactofhand ) -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? ) ;
// $ANTLR start "contactbody"
contactbody: function() {
var retval = new Ham4Parser.contactbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamArmextended220 = null;
var pcontact219 = null;
var contactofhand221 = null;
var HamArmextended220_tree=null;
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactofhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactofhand");
this.trace("ANTLR Parse: contactbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:2130:5: ( ( pcontact | HamArmextended | contactofhand ) -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? ) )
// Ham4Parser.g:2131:5: ( pcontact | HamArmextended | contactofhand )
// Ham4Parser.g:2131:5: ( pcontact | HamArmextended | contactofhand )
var alt83=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt83=1;
break;
case HamArmextended:
alt83=2;
break;
case HamSeqbegin:
alt83=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 83, 0, this.input);
throw nvae;
}
switch (alt83) {
case 1 :
// Ham4Parser.g:2132:9: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contactbody7776);
pcontact219=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact219.getTree());
break;
case 2 :
// Ham4Parser.g:2134:9: HamArmextended
HamArmextended220=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_contactbody7792); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended220);
break;
case 3 :
// Ham4Parser.g:2136:9: contactofhand
this.pushFollow(Ham4Parser.FOLLOW_contactofhand_in_contactbody7808);
contactofhand221=this.contactofhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactofhand.add(contactofhand221.getTree());
break;
}
// AST REWRITE
// elements: contactofhand, HamArmextended, pcontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2138:5: -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? )
{
// Ham4Parser.g:2138:8: ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTBODY, "CNTCTBODY"), root_1);
// Ham4Parser.g:2138:20: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2138:30: ( HamArmextended )?
if ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:2138:46: ( contactofhand )?
if ( stream_contactofhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactofhand.nextTree());
}
stream_contactofhand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contacthand_return: (function() {
Ham4Parser.contacthand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contacthand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2141:1: contacthand : ( pcontact | ccontact | contactofhand ) -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? ) ;
// $ANTLR start "contacthand"
contacthand: function() {
var retval = new Ham4Parser.contacthand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var pcontact222 = null;
var ccontact223 = null;
var contactofhand224 = null;
var stream_ccontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ccontact");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactofhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactofhand");
this.trace("ANTLR Parse: contacthand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2163:5: ( ( pcontact | ccontact | contactofhand ) -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? ) )
// Ham4Parser.g:2164:5: ( pcontact | ccontact | contactofhand )
// Ham4Parser.g:2164:5: ( pcontact | ccontact | contactofhand )
var alt84=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt84=1;
break;
case HamInterlock:
case HamCross:
alt84=2;
break;
case HamSeqbegin:
alt84=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 84, 0, this.input);
throw nvae;
}
switch (alt84) {
case 1 :
// Ham4Parser.g:2165:9: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contacthand7874);
pcontact222=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact222.getTree());
break;
case 2 :
// Ham4Parser.g:2167:9: ccontact
this.pushFollow(Ham4Parser.FOLLOW_ccontact_in_contacthand7890);
ccontact223=this.ccontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ccontact.add(ccontact223.getTree());
break;
case 3 :
// Ham4Parser.g:2169:9: contactofhand
this.pushFollow(Ham4Parser.FOLLOW_contactofhand_in_contacthand7906);
contactofhand224=this.contactofhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactofhand.add(contactofhand224.getTree());
break;
}
// AST REWRITE
// elements: pcontact, contactofhand, ccontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2171:5: -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? )
{
// Ham4Parser.g:2171:8: ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTHAND, "CNTCTHAND"), root_1);
// Ham4Parser.g:2171:20: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2171:30: ( ccontact )?
if ( stream_ccontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_ccontact.nextTree());
}
stream_ccontact.reset();
// Ham4Parser.g:2171:40: ( contactofhand )?
if ( stream_contactofhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactofhand.nextTree());
}
stream_contactofhand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contacthand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconstellation_return: (function() {
Ham4Parser.handconstellation_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconstellation_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2174:1: handconstellation : ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand -> ^( HCONSTLLN ( locationhand )* contacthand ) ;
// $ANTLR start "handconstellation"
handconstellation: function() {
var retval = new Ham4Parser.handconstellation_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin225 = null;
var HamPlus227 = null;
var HamParend229 = null;
var locationhand226 = null;
var locationhand228 = null;
var contacthand230 = null;
var HamParbegin225_tree=null;
var HamPlus227_tree=null;
var HamParend229_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_contacthand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contacthand");
var stream_locationhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationhand");
this.trace("ANTLR Parse: handconstellation starts "+this.state.backtracking);
try {
// Ham4Parser.g:2197:5: ( ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand -> ^( HCONSTLLN ( locationhand )* contacthand ) )
// Ham4Parser.g:2197:9: ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand
// Ham4Parser.g:2197:9: ( HamParbegin locationhand HamPlus locationhand HamParend )?
var alt85=2;
var LA85_0 = this.input.LA(1);
if ( (LA85_0==HamParbegin) ) {
alt85=1;
}
switch (alt85) {
case 1 :
// Ham4Parser.g:2198:13: HamParbegin locationhand HamPlus locationhand HamParend
HamParbegin225=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handconstellation7974); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin225);
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_handconstellation7989);
locationhand226=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand226.getTree());
HamPlus227=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handconstellation8003); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus227);
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_handconstellation8018);
locationhand228=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand228.getTree());
HamParend229=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handconstellation8032); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend229);
break;
}
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_handconstellation8054);
contacthand230=this.contacthand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contacthand.add(contacthand230.getTree());
// AST REWRITE
// elements: contacthand, locationhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2206:6: -> ^( HCONSTLLN ( locationhand )* contacthand )
{
// Ham4Parser.g:2206:9: ^( HCONSTLLN ( locationhand )* contacthand )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HCONSTLLN, "HCONSTLLN"), root_1);
// Ham4Parser.g:2206:21: ( locationhand )*
while ( stream_locationhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationhand.nextTree());
}
stream_locationhand.reset();
this.adaptor.addChild(root_1, stream_contacthand.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconstellation finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactofhand_return: (function() {
Ham4Parser.contactofhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactofhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2209:1: contactofhand : HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? ) ;
// $ANTLR start "contactofhand"
contactofhand: function() {
var retval = new Ham4Parser.contactofhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin231 = null;
var HamSeqend236 = null;
var pcontact232 = null;
var ccontact233 = null;
var contactohhand234 = null;
var contactoharm235 = null;
var HamSeqbegin231_tree=null;
var HamSeqend236_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_contactoharm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactoharm");
var stream_ccontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ccontact");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactohhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactohhand");
this.trace("ANTLR Parse: contactofhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2238:5: ( HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? ) )
// Ham4Parser.g:2238:9: HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend
HamSeqbegin231=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_contactofhand8108); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin231);
// Ham4Parser.g:2239:9: ( pcontact | ccontact )
var alt86=2;
var LA86_0 = this.input.LA(1);
if ( ((LA86_0>=HamClose && LA86_0<=HamTouch)) ) {
alt86=1;
}
else if ( ((LA86_0>=HamInterlock && LA86_0<=HamCross)) ) {
alt86=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 86, 0, this.input);
throw nvae;
}
switch (alt86) {
case 1 :
// Ham4Parser.g:2240:13: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contactofhand8133);
pcontact232=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact232.getTree());
break;
case 2 :
// Ham4Parser.g:2242:13: ccontact
this.pushFollow(Ham4Parser.FOLLOW_ccontact_in_contactofhand8157);
ccontact233=this.ccontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ccontact.add(ccontact233.getTree());
break;
}
// Ham4Parser.g:2244:9: ( ( levelhand )=> contactohhand | contactoharm )
var alt87=2;
var LA87_0 = this.input.LA(1);
if ( ((LA87_0>=HamWristback && LA87_0<=HamHandback)||(LA87_0>=HamThumbside && LA87_0<=HamPinkyside)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamFingertip && LA87_0<=HamFingerside)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( (LA87_0==HamThumb) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamIndexfinger && LA87_0<=HamPinky)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamLrbeside && LA87_0<=HamLrat)) ) {
var LA87_5 = this.input.LA(2);
if ( (this.synpred26_Ham4Parser()) ) {
alt87=1;
}
else if ( (true) ) {
alt87=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 87, 5, this.input);
throw nvae;
}
}
else if ( ((LA87_0>=HamUpperarm && LA87_0<=HamLowerarm)) ) {
alt87=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 87, 0, this.input);
throw nvae;
}
switch (alt87) {
case 1 :
// Ham4Parser.g:2245:13: ( levelhand )=> contactohhand
this.pushFollow(Ham4Parser.FOLLOW_contactohhand_in_contactofhand8223);
contactohhand234=this.contactohhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactohhand.add(contactohhand234.getTree());
break;
case 2 :
// Ham4Parser.g:2249:13: contactoharm
this.pushFollow(Ham4Parser.FOLLOW_contactoharm_in_contactofhand8247);
contactoharm235=this.contactoharm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactoharm.add(contactoharm235.getTree());
break;
}
HamSeqend236=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_contactofhand8267); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend236);
// AST REWRITE
// elements: pcontact, contactohhand, contactoharm, ccontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2253:6: -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? )
{
// Ham4Parser.g:2253:9: ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOFHAND, "CNTCTOFHAND"), root_1);
// Ham4Parser.g:2253:23: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2253:33: ( ccontact )?
if ( stream_ccontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_ccontact.nextTree());
}
stream_ccontact.reset();
// Ham4Parser.g:2253:43: ( contactohhand )?
if ( stream_contactohhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactohhand.nextTree());
}
stream_contactohhand.reset();
// Ham4Parser.g:2253:58: ( contactoharm )?
if ( stream_contactoharm.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactoharm.nextTree());
}
stream_contactoharm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactofhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactohhand_return: (function() {
Ham4Parser.contactohhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactohhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2256:1: contactohhand : levelcomplexhand -> ^( CNTCTOHHAND levelcomplexhand ) ;
// $ANTLR start "contactohhand"
contactohhand: function() {
var retval = new Ham4Parser.contactohhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexhand237 = null;
var stream_levelcomplexhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexhand");
this.trace("ANTLR Parse: contactohhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2272:5: ( levelcomplexhand -> ^( CNTCTOHHAND levelcomplexhand ) )
// Ham4Parser.g:2272:9: levelcomplexhand
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexhand_in_contactohhand8329);
levelcomplexhand237=this.levelcomplexhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexhand.add(levelcomplexhand237.getTree());
// AST REWRITE
// elements: levelcomplexhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2274:6: -> ^( CNTCTOHHAND levelcomplexhand )
{
// Ham4Parser.g:2274:9: ^( CNTCTOHHAND levelcomplexhand )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOHHAND, "CNTCTOHHAND"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexhand.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactohhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactoharm_return: (function() {
Ham4Parser.contactoharm_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactoharm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2277:1: contactoharm : levelcomplexarm -> ^( CNTCTOHARM levelcomplexarm ) ;
// $ANTLR start "contactoharm"
contactoharm: function() {
var retval = new Ham4Parser.contactoharm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexarm238 = null;
var stream_levelcomplexarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexarm");
this.trace("ANTLR Parse: contactoharm starts "+this.state.backtracking);
try {
// Ham4Parser.g:2293:5: ( levelcomplexarm -> ^( CNTCTOHARM levelcomplexarm ) )
// Ham4Parser.g:2293:9: levelcomplexarm
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexarm_in_contactoharm8380);
levelcomplexarm238=this.levelcomplexarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexarm.add(levelcomplexarm238.getTree());
// AST REWRITE
// elements: levelcomplexarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2295:6: -> ^( CNTCTOHARM levelcomplexarm )
{
// Ham4Parser.g:2295:9: ^( CNTCTOHARM levelcomplexarm )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOHARM, "CNTCTOHARM"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexarm.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactoharm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
lochand_return: (function() {
Ham4Parser.lochand_return = function(){};
org.antlr.lang.extend(Ham4Parser.lochand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2298:1: lochand : ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? ) ;
// $ANTLR start "lochand"
lochand: function() {
var retval = new Ham4Parser.lochand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handpart239 = null;
var fingerpart240 = null;
var digit241 = null;
var digit242 = null;
var fingerpart243 = null;
this.trace("ANTLR Parse: lochand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2321:5: ( ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? ) )
// Ham4Parser.g:2322:5: ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? )
root_0 = this.adaptor.nil();
// Ham4Parser.g:2322:5: ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? )
var alt91=3;
switch ( this.input.LA(1) ) {
case HamWristback:
case HamWristpulse:
case HamThumbball:
case HamPalm:
case HamHandback:
case HamThumbside:
case HamPinkyside:
alt91=1;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt91=2;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt91=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 91, 0, this.input);
throw nvae;
}
switch (alt91) {
case 1 :
// Ham4Parser.g:2323:9: handpart
this.pushFollow(Ham4Parser.FOLLOW_handpart_in_lochand8443);
handpart239=this.handpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, handpart239.getTree());
break;
case 2 :
// Ham4Parser.g:2325:9: fingerpart ( digit )*
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_lochand8459);
fingerpart240=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerpart240.getTree());
// Ham4Parser.g:2326:9: ( digit )*
loop88:
do {
var alt88=2;
var LA88_0 = this.input.LA(1);
if ( ((LA88_0>=HamThumb && LA88_0<=HamPinky)) ) {
alt88=1;
}
switch (alt88) {
case 1 :
// Ham4Parser.g:2326:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_lochand8471);
digit241=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit241.getTree());
break;
default :
break loop88;
}
} while (true);
break;
case 3 :
// Ham4Parser.g:2328:9: ( digit )+ ( fingerpart )?
// Ham4Parser.g:2328:9: ( digit )+
var cnt89=0;
loop89:
do {
var alt89=2;
var LA89_0 = this.input.LA(1);
if ( ((LA89_0>=HamThumb && LA89_0<=HamPinky)) ) {
alt89=1;
}
switch (alt89) {
case 1 :
// Ham4Parser.g:2328:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_lochand8492);
digit242=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit242.getTree());
break;
default :
if ( cnt89 >= 1 ) {
break loop89;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(89, this.input);
throw eee;
}
cnt89++;
} while (true);
// Ham4Parser.g:2329:9: ( fingerpart )?
var alt90=2;
var LA90_0 = this.input.LA(1);
if ( ((LA90_0>=HamFingertip && LA90_0<=HamFingerside)) ) {
alt90=1;
}
switch (alt90) {
case 1 :
// Ham4Parser.g:2329:11: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_lochand8507);
fingerpart243=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerpart243.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: lochand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a2tstar_return: (function() {
Ham4Parser.a2tstar_return = function(){};
org.antlr.lang.extend(Ham4Parser.a2tstar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2336:1: a2tstar : a2tlist -> ^( A2TLIST ( a2tlist )? ) ;
// $ANTLR start "a2tstar"
a2tstar: function() {
var retval = new Ham4Parser.a2tstar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var a2tlist244 = null;
var stream_a2tlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a2tlist");
this.trace("ANTLR Parse: a2tstar starts "+this.state.backtracking);
try {
// Ham4Parser.g:2352:5: ( a2tlist -> ^( A2TLIST ( a2tlist )? ) )
// Ham4Parser.g:2352:9: a2tlist
this.pushFollow(Ham4Parser.FOLLOW_a2tlist_in_a2tstar8548);
a2tlist244=this.a2tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a2tlist.add(a2tlist244.getTree());
// AST REWRITE
// elements: a2tlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2354:6: -> ^( A2TLIST ( a2tlist )? )
{
// Ham4Parser.g:2354:9: ^( A2TLIST ( a2tlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(A2TLIST, "A2TLIST"), root_1);
// Ham4Parser.g:2354:19: ( a2tlist )?
if ( stream_a2tlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_a2tlist.nextTree());
}
stream_a2tlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a2tstar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a1tstar_return: (function() {
Ham4Parser.a1tstar_return = function(){};
org.antlr.lang.extend(Ham4Parser.a1tstar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2357:1: a1tstar : a1tlist -> ^( A1TLIST ( a1tlist )? ) ;
// $ANTLR start "a1tstar"
a1tstar: function() {
var retval = new Ham4Parser.a1tstar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var a1tlist245 = null;
var stream_a1tlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tlist");
this.trace("ANTLR Parse: a1tstar starts "+this.state.backtracking);
try {
// Ham4Parser.g:2373:5: ( a1tlist -> ^( A1TLIST ( a1tlist )? ) )
// Ham4Parser.g:2373:9: a1tlist
this.pushFollow(Ham4Parser.FOLLOW_a1tlist_in_a1tstar8600);
a1tlist245=this.a1tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tlist.add(a1tlist245.getTree());
// AST REWRITE
// elements: a1tlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2375:6: -> ^( A1TLIST ( a1tlist )? )
{
// Ham4Parser.g:2375:9: ^( A1TLIST ( a1tlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(A1TLIST, "A1TLIST"), root_1);
// Ham4Parser.g:2375:19: ( a1tlist )?
if ( stream_a1tlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_a1tlist.nextTree());
}
stream_a1tlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a1tstar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a2tlist_return: (function() {
Ham4Parser.a2tlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.a2tlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2378:1: a2tlist : ( action2t a2tlist )? ;
// $ANTLR start "a2tlist"
a2tlist: function() {
var retval = new Ham4Parser.a2tlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action2t246 = null;
var a2tlist247 = null;
this.trace("ANTLR Parse: a2tlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:2396:5: ( ( action2t a2tlist )? )
// Ham4Parser.g:2397:9: ( action2t a2tlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2397:9: ( action2t a2tlist )?
var alt92=2;
alt92 = this.dfa92.predict(this.input);
switch (alt92) {
case 1 :
// Ham4Parser.g:2398:13: action2t a2tlist
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_a2tlist8672);
action2t246=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action2t246.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a2tlist_in_a2tlist8686);
a2tlist247=this.a2tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, a2tlist247.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a2tlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a1tlist_return: (function() {
Ham4Parser.a1tlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.a1tlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2403:1: a1tlist : ( action1t a1tlist )? ;
// $ANTLR start "a1tlist"
a1tlist: function() {
var retval = new Ham4Parser.a1tlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1t248 = null;
var a1tlist249 = null;
this.trace("ANTLR Parse: a1tlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:2421:5: ( ( action1t a1tlist )? )
// Ham4Parser.g:2422:9: ( action1t a1tlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2422:9: ( action1t a1tlist )?
var alt93=2;
alt93 = this.dfa93.predict(this.input);
switch (alt93) {
case 1 :
// Ham4Parser.g:2423:13: action1t a1tlist
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_a1tlist8746);
action1t248=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1t248.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tlist_in_a1tlist8760);
a1tlist249=this.a1tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, a1tlist249.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a1tlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action2t_return: (function() {
Ham4Parser.action2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.action2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2428:1: action2t : ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) ) ;
// $ANTLR start "action2t"
action2t: function() {
var retval = new Ham4Parser.action2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1250 = null;
var location2not1251 = null;
var repetitionsoption252 = null;
var action1t253 = null;
var splitaction2loc2254 = null;
var splitaction2t255 = null;
var paraction2t256 = null;
var seqaction2t257 = null;
var seqfusedaction2t258 = null;
var repetitionsoption259 = null;
var stream_seqfusedaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction2t");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
var stream_seqaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqaction2t");
var stream_location2not1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2not1");
var stream_repetitionsoption=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetitionsoption");
var stream_splitaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitaction2t");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
var stream_paraction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction2t");
var stream_splitaction2loc2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitaction2loc2");
this.trace("ANTLR Parse: action2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2474:5: ( ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) ) )
// Ham4Parser.g:2475:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )
// Ham4Parser.g:2475:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )
var alt95=3;
alt95 = this.dfa95.predict(this.input);
switch (alt95) {
case 1 :
// Ham4Parser.g:2476:9: ( action1 location2not1 )=> action1 location2not1 repetitionsoption
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action2t8838);
action1250=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1250.getTree());
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_action2t8848);
location2not1251=this.location2not1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2not1.add(location2not1251.getTree());
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action2t8858);
repetitionsoption252=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption252.getTree());
// AST REWRITE
// elements: action1, repetitionsoption, location2not1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2481:6: -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? )
{
// Ham4Parser.g:2481:9: ^( ACTION2T action1 location2not1 ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
this.adaptor.addChild(root_1, stream_action1.nextTree());
this.adaptor.addChild(root_1, stream_location2not1.nextTree());
// Ham4Parser.g:2481:42: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2483:9: ( action1t )=> action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_action2t8916);
action1t253=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t253.getTree());
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2486:6: -> ^( ACTION2T action1t )
{
// Ham4Parser.g:2486:9: ^( ACTION2T action1t )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
this.adaptor.addChild(root_1, stream_action1t.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2488:9: ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption
// Ham4Parser.g:2488:9: ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t )
var alt94=5;
switch ( this.input.LA(1) ) {
case HamParbegin:
var LA94_1 = this.input.LA(2);
if ( (this.synpred29_Ham4Parser()) ) {
alt94=1;
}
else if ( (this.synpred30_Ham4Parser()) ) {
alt94=2;
}
else if ( (true) ) {
alt94=3;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 1, this.input);
throw nvae;
}
break;
case HamSeqbegin:
alt94=4;
break;
case HamFusionbegin:
alt94=5;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 0, this.input);
throw nvae;
}
switch (alt94) {
case 1 :
// Ham4Parser.g:2489:13: ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2
this.pushFollow(Ham4Parser.FOLLOW_splitaction2loc2_in_action2t9025);
splitaction2loc2254=this.splitaction2loc2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitaction2loc2.add(splitaction2loc2254.getTree());
break;
case 2 :
// Ham4Parser.g:2494:13: ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t
this.pushFollow(Ham4Parser.FOLLOW_splitaction2t_in_action2t9090);
splitaction2t255=this.splitaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitaction2t.add(splitaction2t255.getTree());
break;
case 3 :
// Ham4Parser.g:2498:13: paraction2t
this.pushFollow(Ham4Parser.FOLLOW_paraction2t_in_action2t9114);
paraction2t256=this.paraction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction2t.add(paraction2t256.getTree());
break;
case 4 :
// Ham4Parser.g:2500:13: seqaction2t
this.pushFollow(Ham4Parser.FOLLOW_seqaction2t_in_action2t9138);
seqaction2t257=this.seqaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqaction2t.add(seqaction2t257.getTree());
break;
case 5 :
// Ham4Parser.g:2502:13: seqfusedaction2t
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction2t_in_action2t9162);
seqfusedaction2t258=this.seqfusedaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction2t.add(seqfusedaction2t258.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action2t9182);
repetitionsoption259=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption259.getTree());
// AST REWRITE
// elements: paraction2t, seqaction2t, splitaction2loc2, seqfusedaction2t, repetitionsoption, splitaction2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2505:6: -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? )
{
// Ham4Parser.g:2505:9: ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
// Ham4Parser.g:2505:20: ( splitaction2loc2 )?
if ( stream_splitaction2loc2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitaction2loc2.nextTree());
}
stream_splitaction2loc2.reset();
// Ham4Parser.g:2505:38: ( splitaction2t )?
if ( stream_splitaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitaction2t.nextTree());
}
stream_splitaction2t.reset();
// Ham4Parser.g:2505:53: ( paraction2t )?
if ( stream_paraction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_paraction2t.nextTree());
}
stream_paraction2t.reset();
// Ham4Parser.g:2505:66: ( seqaction2t )?
if ( stream_seqaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqaction2t.nextTree());
}
stream_seqaction2t.reset();
// Ham4Parser.g:2505:79: ( seqfusedaction2t )?
if ( stream_seqfusedaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqfusedaction2t.nextTree());
}
stream_seqfusedaction2t.reset();
// Ham4Parser.g:2505:97: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1t_return: (function() {
Ham4Parser.action1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2509:1: action1t : ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? ) ;
// $ANTLR start "action1t"
action1t: function() {
var retval = new Ham4Parser.action1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamLargemod263 = null;
var action1260 = null;
var handconstellation261 = null;
var location1262 = null;
var paraction1t264 = null;
var seqnmoraction1t265 = null;
var seqfusedaction1t266 = null;
var repetitionsoption267 = null;
var HamLargemod263_tree=null;
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_seqfusedaction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction1t");
var stream_repetitionsoption=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetitionsoption");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
var stream_seqnmoraction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqnmoraction1t");
var stream_handconstellation=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconstellation");
var stream_paraction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction1t");
this.trace("ANTLR Parse: action1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2552:5: ( ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? ) )
// Ham4Parser.g:2553:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption
// Ham4Parser.g:2553:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t )
var alt98=4;
alt98 = this.dfa98.predict(this.input);
switch (alt98) {
case 1 :
// Ham4Parser.g:2554:13: ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? )
// Ham4Parser.g:2556:13: ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? )
// Ham4Parser.g:2557:17: action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action1t9316);
action1260=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1260.getTree());
// Ham4Parser.g:2558:17: ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?
var alt97=3;
alt97 = this.dfa97.predict(this.input);
switch (alt97) {
case 1 :
// Ham4Parser.g:2559:21: ( handconstellation )=> handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_action1t9404);
handconstellation261=this.handconstellation();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconstellation.add(handconstellation261.getTree());
break;
case 2 :
// Ham4Parser.g:2563:21: location1 ( HamLargemod )?
this.pushFollow(Ham4Parser.FOLLOW_location1_in_action1t9444);
location1262=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1262.getTree());
// Ham4Parser.g:2564:21: ( HamLargemod )?
var alt96=2;
alt96 = this.dfa96.predict(this.input);
switch (alt96) {
case 1 :
// Ham4Parser.g:2564:23: HamLargemod
HamLargemod263=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_action1t9468); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod263);
break;
}
break;
}
break;
case 2 :
// Ham4Parser.g:2568:13: paraction1t
this.pushFollow(Ham4Parser.FOLLOW_paraction1t_in_action1t9528);
paraction1t264=this.paraction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction1t.add(paraction1t264.getTree());
break;
case 3 :
// Ham4Parser.g:2570:13: seqnmoraction1t
this.pushFollow(Ham4Parser.FOLLOW_seqnmoraction1t_in_action1t9552);
seqnmoraction1t265=this.seqnmoraction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqnmoraction1t.add(seqnmoraction1t265.getTree());
break;
case 4 :
// Ham4Parser.g:2572:13: seqfusedaction1t
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction1t_in_action1t9577);
seqfusedaction1t266=this.seqfusedaction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction1t.add(seqfusedaction1t266.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action1t9597);
repetitionsoption267=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption267.getTree());
// AST REWRITE
// elements: location1, paraction1t, seqfusedaction1t, handconstellation, HamLargemod, action1, seqnmoraction1t, repetitionsoption
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2576:6: -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? )
{
// Ham4Parser.g:2576:9: ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1T, "ACTION1T"), root_1);
// Ham4Parser.g:2577:9: ( action1 )?
if ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
// Ham4Parser.g:2577:18: ( handconstellation )?
if ( stream_handconstellation.hasNext() ) {
this.adaptor.addChild(root_1, stream_handconstellation.nextTree());
}
stream_handconstellation.reset();
// Ham4Parser.g:2577:37: ( location1 )?
if ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
// Ham4Parser.g:2577:48: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
// Ham4Parser.g:2578:9: ( paraction1t )?
if ( stream_paraction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_paraction1t.nextTree());
}
stream_paraction1t.reset();
// Ham4Parser.g:2579:21: ( seqnmoraction1t )?
if ( stream_seqnmoraction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqnmoraction1t.nextTree());
}
stream_seqnmoraction1t.reset();
// Ham4Parser.g:2580:9: ( seqfusedaction1t )?
if ( stream_seqfusedaction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqfusedaction1t.nextTree());
}
stream_seqfusedaction1t.reset();
// Ham4Parser.g:2581:8: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1_return: (function() {
Ham4Parser.action1_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2584:1: action1 : ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) ) ;
// $ANTLR start "action1"
action1: function() {
var retval = new Ham4Parser.action1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNomotion268 = null;
var HamLargemod271 = null;
var simplemovement269 = null;
var modifier270 = null;
var specialfingerplaymovement272 = null;
var paraction1273 = null;
var seqaction1274 = null;
var seqfusedaction1275 = null;
var HamNomotion268_tree=null;
var HamLargemod271_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_specialfingerplaymovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule specialfingerplaymovement");
var stream_modifier=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule modifier");
var stream_seqaction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqaction1");
var stream_simplemovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule simplemovement");
var stream_paraction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction1");
var stream_seqfusedaction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction1");
this.trace("ANTLR Parse: action1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2623:5: ( ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) ) )
// Ham4Parser.g:2624:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )
// Ham4Parser.g:2624:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )
var alt102=6;
alt102 = this.dfa102.predict(this.input);
switch (alt102) {
case 1 :
// Ham4Parser.g:2625:9: HamNomotion
HamNomotion268=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_action19733); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion268);
// AST REWRITE
// elements: HamNomotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2626:6: -> ^( ACTION1 HamNomotion )
{
// Ham4Parser.g:2626:9: ^( ACTION1 HamNomotion )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2628:9: simplemovement ( ( modifier )+ ( HamLargemod )? )?
this.pushFollow(Ham4Parser.FOLLOW_simplemovement_in_action19762);
simplemovement269=this.simplemovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_simplemovement.add(simplemovement269.getTree());
// Ham4Parser.g:2629:9: ( ( modifier )+ ( HamLargemod )? )?
var alt101=2;
var LA101_0 = this.input.LA(1);
if ( ((LA101_0>=HamFast && LA101_0<=HamHalt)) ) {
alt101=1;
}
switch (alt101) {
case 1 :
// Ham4Parser.g:2630:13: ( modifier )+ ( HamLargemod )?
// Ham4Parser.g:2630:13: ( modifier )+
var cnt99=0;
loop99:
do {
var alt99=2;
var LA99_0 = this.input.LA(1);
if ( ((LA99_0>=HamFast && LA99_0<=HamHalt)) ) {
alt99=1;
}
switch (alt99) {
case 1 :
// Ham4Parser.g:2630:15: modifier
this.pushFollow(Ham4Parser.FOLLOW_modifier_in_action19788);
modifier270=this.modifier();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_modifier.add(modifier270.getTree());
break;
default :
if ( cnt99 >= 1 ) {
break loop99;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(99, this.input);
throw eee;
}
cnt99++;
} while (true);
// Ham4Parser.g:2631:13: ( HamLargemod )?
var alt100=2;
var LA100_0 = this.input.LA(1);
if ( (LA100_0==HamLargemod) ) {
alt100=1;
}
switch (alt100) {
case 1 :
// Ham4Parser.g:2631:15: HamLargemod
HamLargemod271=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_action19807); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod271);
break;
}
break;
}
// AST REWRITE
// elements: simplemovement, modifier, HamLargemod
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2633:6: -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? )
{
// Ham4Parser.g:2633:9: ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_simplemovement.nextTree());
// Ham4Parser.g:2633:34: ( modifier )*
while ( stream_modifier.hasNext() ) {
this.adaptor.addChild(root_1, stream_modifier.nextTree());
}
stream_modifier.reset();
// Ham4Parser.g:2633:44: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2635:9: ( HamSeqbegin digit )=> specialfingerplaymovement
this.pushFollow(Ham4Parser.FOLLOW_specialfingerplaymovement_in_action19882);
specialfingerplaymovement272=this.specialfingerplaymovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_specialfingerplaymovement.add(specialfingerplaymovement272.getTree());
// AST REWRITE
// elements: specialfingerplaymovement
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2638:6: -> ^( ACTION1 specialfingerplaymovement )
{
// Ham4Parser.g:2638:9: ^( ACTION1 specialfingerplaymovement )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_specialfingerplaymovement.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:2640:9: paraction1
this.pushFollow(Ham4Parser.FOLLOW_paraction1_in_action19911);
paraction1273=this.paraction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction1.add(paraction1273.getTree());
// AST REWRITE
// elements: paraction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2641:6: -> ^( ACTION1 paraction1 )
{
// Ham4Parser.g:2641:9: ^( ACTION1 paraction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_paraction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 5 :
// Ham4Parser.g:2643:9: seqaction1
this.pushFollow(Ham4Parser.FOLLOW_seqaction1_in_action19940);
seqaction1274=this.seqaction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqaction1.add(seqaction1274.getTree());
// AST REWRITE
// elements: seqaction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2644:6: -> ^( ACTION1 seqaction1 )
{
// Ham4Parser.g:2644:9: ^( ACTION1 seqaction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_seqaction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 6 :
// Ham4Parser.g:2646:9: seqfusedaction1
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction1_in_action19969);
seqfusedaction1275=this.seqfusedaction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction1.add(seqfusedaction1275.getTree());
// AST REWRITE
// elements: seqfusedaction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2647:6: -> ^( ACTION1 seqfusedaction1 )
{
// Ham4Parser.g:2647:9: ^( ACTION1 seqfusedaction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_seqfusedaction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1seq_return: (function() {
Ham4Parser.action1seq_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1seq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2654:1: action1seq : ( action1 )+ ;
// $ANTLR start "action1seq"
action1seq: function() {
var retval = new Ham4Parser.action1seq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1276 = null;
try {
// Ham4Parser.g:2655:2: ( ( action1 )+ )
// Ham4Parser.g:2655:4: ( action1 )+
root_0 = this.adaptor.nil();
// Ham4Parser.g:2655:4: ( action1 )+
var cnt103=0;
loop103:
do {
var alt103=2;
alt103 = this.dfa103.predict(this.input);
switch (alt103) {
case 1 :
// Ham4Parser.g:2655:4: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action1seq10005);
action1276=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1276.getTree());
break;
default :
if ( cnt103 >= 1 ) {
break loop103;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(103, this.input);
throw eee;
}
cnt103++;
} while (true);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1tseq_return: (function() {
Ham4Parser.action1tseq_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1tseq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2658:1: action1tseq : ( action1t )+ ;
// $ANTLR start "action1tseq"
action1tseq: function() {
var retval = new Ham4Parser.action1tseq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1t277 = null;
try {
// Ham4Parser.g:2659:2: ( ( action1t )+ )
// Ham4Parser.g:2659:4: ( action1t )+
root_0 = this.adaptor.nil();
// Ham4Parser.g:2659:4: ( action1t )+
var cnt104=0;
loop104:
do {
var alt104=2;
alt104 = this.dfa104.predict(this.input);
switch (alt104) {
case 1 :
// Ham4Parser.g:2659:4: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_action1tseq10017);
action1t277=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1t277.getTree());
break;
default :
if ( cnt104 >= 1 ) {
break loop104;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(104, this.input);
throw eee;
}
cnt104++;
} while (true);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction2t_return: (function() {
Ham4Parser.paraction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2662:1: paraction2t : HamParbegin ( action2t )+ HamParend -> ^( PARACT2T ( action2t )* ) ;
// $ANTLR start "paraction2t"
paraction2t: function() {
var retval = new Ham4Parser.paraction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin278 = null;
var HamParend280 = null;
var action2t279 = null;
var HamParbegin278_tree=null;
var HamParend280_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: paraction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2680:5: ( HamParbegin ( action2t )+ HamParend -> ^( PARACT2T ( action2t )* ) )
// Ham4Parser.g:2680:9: HamParbegin ( action2t )+ HamParend
HamParbegin278=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction2t10044); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin278);
// Ham4Parser.g:2681:9: ( action2t )+
var cnt105=0;
loop105:
do {
var alt105=2;
alt105 = this.dfa105.predict(this.input);
switch (alt105) {
case 1 :
// Ham4Parser.g:2681:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_paraction2t10057);
action2t279=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t279.getTree());
break;
default :
if ( cnt105 >= 1 ) {
break loop105;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(105, this.input);
throw eee;
}
cnt105++;
} while (true);
HamParend280=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction2t10070); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend280);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2684:6: -> ^( PARACT2T ( action2t )* )
{
// Ham4Parser.g:2684:9: ^( PARACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT2T, "PARACT2T"), root_1);
// Ham4Parser.g:2684:20: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqaction2t_return: (function() {
Ham4Parser.seqaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2687:1: seqaction2t : HamSeqbegin ( action2t )+ HamSeqend -> ^( SEQACT2T ( action2t )* ) ;
// $ANTLR start "seqaction2t"
seqaction2t: function() {
var retval = new Ham4Parser.seqaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin281 = null;
var HamSeqend283 = null;
var action2t282 = null;
var HamSeqbegin281_tree=null;
var HamSeqend283_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: seqaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2705:5: ( HamSeqbegin ( action2t )+ HamSeqend -> ^( SEQACT2T ( action2t )* ) )
// Ham4Parser.g:2705:9: HamSeqbegin ( action2t )+ HamSeqend
HamSeqbegin281=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqaction2t10123); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin281);
// Ham4Parser.g:2706:9: ( action2t )+
var cnt106=0;
loop106:
do {
var alt106=2;
alt106 = this.dfa106.predict(this.input);
switch (alt106) {
case 1 :
// Ham4Parser.g:2706:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_seqaction2t10136);
action2t282=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t282.getTree());
break;
default :
if ( cnt106 >= 1 ) {
break loop106;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(106, this.input);
throw eee;
}
cnt106++;
} while (true);
HamSeqend283=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqaction2t10149); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend283);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2709:6: -> ^( SEQACT2T ( action2t )* )
{
// Ham4Parser.g:2709:9: ^( SEQACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT2T, "SEQACT2T"), root_1);
// Ham4Parser.g:2709:20: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction2t_return: (function() {
Ham4Parser.seqfusedaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2712:1: seqfusedaction2t : HamFusionbegin ( action2t )+ HamFusionend -> ^( SEQFUSEDACT2T ( action2t )* ) ;
// $ANTLR start "seqfusedaction2t"
seqfusedaction2t: function() {
var retval = new Ham4Parser.seqfusedaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin284 = null;
var HamFusionend286 = null;
var action2t285 = null;
var HamFusionbegin284_tree=null;
var HamFusionend286_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: seqfusedaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2730:5: ( HamFusionbegin ( action2t )+ HamFusionend -> ^( SEQFUSEDACT2T ( action2t )* ) )
// Ham4Parser.g:2730:9: HamFusionbegin ( action2t )+ HamFusionend
HamFusionbegin284=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction2t10202); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin284);
// Ham4Parser.g:2731:9: ( action2t )+
var cnt107=0;
loop107:
do {
var alt107=2;
alt107 = this.dfa107.predict(this.input);
switch (alt107) {
case 1 :
// Ham4Parser.g:2731:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_seqfusedaction2t10215);
action2t285=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t285.getTree());
break;
default :
if ( cnt107 >= 1 ) {
break loop107;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(107, this.input);
throw eee;
}
cnt107++;
} while (true);
HamFusionend286=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction2t10228); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend286);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2734:6: -> ^( SEQFUSEDACT2T ( action2t )* )
{
// Ham4Parser.g:2734:9: ^( SEQFUSEDACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT2T, "SEQFUSEDACT2T"), root_1);
// Ham4Parser.g:2734:25: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitaction2loc2_return: (function() {
Ham4Parser.splitaction2loc2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitaction2loc2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2737:1: splitaction2loc2 : HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2 -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 ) ;
// $ANTLR start "splitaction2loc2"
splitaction2loc2: function() {
var retval = new Ham4Parser.splitaction2loc2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin287 = null;
var HamPlus288 = null;
var HamParend289 = null;
var acta = null;
var actb = null;
var location2290 = null;
var HamParbegin287_tree=null;
var HamPlus288_tree=null;
var HamParend289_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1seq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1seq");
var stream_location2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2");
this.trace("ANTLR Parse: splitaction2loc2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2758:5: ( HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2 -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 ) )
// Ham4Parser.g:2758:9: HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2
HamParbegin287=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitaction2loc210281); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin287);
this.pushFollow(Ham4Parser.FOLLOW_action1seq_in_splitaction2loc210294);
acta=this.action1seq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1seq.add(acta.getTree());
HamPlus288=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitaction2loc210304); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus288);
this.pushFollow(Ham4Parser.FOLLOW_action1seq_in_splitaction2loc210316);
actb=this.action1seq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1seq.add(actb.getTree());
HamParend289=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitaction2loc210326); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend289);
this.pushFollow(Ham4Parser.FOLLOW_location2_in_splitaction2loc210337);
location2290=this.location2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2.add(location2290.getTree());
// AST REWRITE
// elements: actb, location2, acta, HamPlus
// token labels: 
// rule labels: acta, actb, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_acta=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token acta",acta!=null?acta.tree:null);
var stream_actb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token actb",actb!=null?actb.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2765:6: -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 )
{
// Ham4Parser.g:2765:9: ^( SPLITACT2LOC2 $acta HamPlus $actb location2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITACT2LOC2, "SPLITACT2LOC2"), root_1);
this.adaptor.addChild(root_1, stream_acta.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_actb.nextTree());
this.adaptor.addChild(root_1, stream_location2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitaction2loc2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitaction2t_return: (function() {
Ham4Parser.splitaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2768:1: splitaction2t : HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend -> ^( SPLITACT2T $acta HamPlus $actb) ;
// $ANTLR start "splitaction2t"
splitaction2t: function() {
var retval = new Ham4Parser.splitaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin291 = null;
var HamPlus292 = null;
var HamParend293 = null;
var acta = null;
var actb = null;
var HamParbegin291_tree=null;
var HamPlus292_tree=null;
var HamParend293_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1tseq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1tseq");
this.trace("ANTLR Parse: splitaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2788:5: ( HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend -> ^( SPLITACT2T $acta HamPlus $actb) )
// Ham4Parser.g:2788:9: HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend
HamParbegin291=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitaction2t10396); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin291);
this.pushFollow(Ham4Parser.FOLLOW_action1tseq_in_splitaction2t10409);
acta=this.action1tseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1tseq.add(acta.getTree());
HamPlus292=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitaction2t10419); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus292);
this.pushFollow(Ham4Parser.FOLLOW_action1tseq_in_splitaction2t10431);
actb=this.action1tseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1tseq.add(actb.getTree());
HamParend293=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitaction2t10441); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend293);
// AST REWRITE
// elements: acta, actb, HamPlus
// token labels: 
// rule labels: acta, actb, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_acta=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token acta",acta!=null?acta.tree:null);
var stream_actb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token actb",actb!=null?actb.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2794:6: -> ^( SPLITACT2T $acta HamPlus $actb)
{
// Ham4Parser.g:2794:9: ^( SPLITACT2T $acta HamPlus $actb)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITACT2T, "SPLITACT2T"), root_1);
this.adaptor.addChild(root_1, stream_acta.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_actb.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction1t_return: (function() {
Ham4Parser.paraction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2797:1: paraction1t : HamParbegin ( action1t )+ HamParend -> ^( PARACT1T ( action1t )* ) ;
// $ANTLR start "paraction1t"
paraction1t: function() {
var retval = new Ham4Parser.paraction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin294 = null;
var HamParend296 = null;
var action1t295 = null;
var HamParbegin294_tree=null;
var HamParend296_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
this.trace("ANTLR Parse: paraction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2816:5: ( HamParbegin ( action1t )+ HamParend -> ^( PARACT1T ( action1t )* ) )
// Ham4Parser.g:2817:9: HamParbegin ( action1t )+ HamParend
HamParbegin294=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction1t10505); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin294);
// Ham4Parser.g:2818:9: ( action1t )+
var cnt108=0;
loop108:
do {
var alt108=2;
alt108 = this.dfa108.predict(this.input);
switch (alt108) {
case 1 :
// Ham4Parser.g:2818:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_paraction1t10518);
action1t295=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t295.getTree());
break;
default :
if ( cnt108 >= 1 ) {
break loop108;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(108, this.input);
throw eee;
}
cnt108++;
} while (true);
HamParend296=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction1t10531); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend296);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2821:6: -> ^( PARACT1T ( action1t )* )
{
// Ham4Parser.g:2821:9: ^( PARACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT1T, "PARACT1T"), root_1);
// Ham4Parser.g:2821:20: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqnmoraction1t_return: (function() {
Ham4Parser.seqnmoraction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqnmoraction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2824:1: seqnmoraction1t : HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend ;
// $ANTLR start "seqnmoraction1t"
seqnmoraction1t: function() {
var retval = new Ham4Parser.seqnmoraction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin297 = null;
var HamSeqend302 = null;
var levelbody298 = null;
var levelarm299 = null;
var action1t300 = null;
var action1t301 = null;
var HamSeqbegin297_tree=null;
var HamSeqend302_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
var stream_levelbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelbody");
var stream_levelarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelarm");
this.trace("ANTLR Parse: seqnmoraction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2853:5: ( HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend )
// Ham4Parser.g:2854:9: HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend
HamSeqbegin297=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqnmoraction1t10590); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin297);
// Ham4Parser.g:2855:9: ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) )
var alt111=2;
alt111 = this.dfa111.predict(this.input);
switch (alt111) {
case 1 :
// Ham4Parser.g:2856:4: ( ( levelbody )=> levelbody | levelarm ) action1t
// Ham4Parser.g:2856:4: ( ( levelbody )=> levelbody | levelarm )
var alt109=2;
alt109 = this.dfa109.predict(this.input);
switch (alt109) {
case 1 :
// Ham4Parser.g:2857:6: ( levelbody )=> levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_seqnmoraction1t10621);
levelbody298=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelbody.add(levelbody298.getTree());
break;
case 2 :
// Ham4Parser.g:2859:6: levelarm
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_seqnmoraction1t10633);
levelarm299=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelarm.add(levelarm299.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqnmoraction1t10643);
action1t300=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t300.getTree());
// AST REWRITE
// elements: levelarm, levelbody, action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2862:6: -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t )
{
// Ham4Parser.g:2862:9: ^( NMACT1T ( levelbody )* ( levelarm )* action1t )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMACT1T, "NMACT1T"), root_1);
// Ham4Parser.g:2862:19: ( levelbody )*
while ( stream_levelbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelbody.nextTree());
}
stream_levelbody.reset();
// Ham4Parser.g:2862:30: ( levelarm )*
while ( stream_levelarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelarm.nextTree());
}
stream_levelarm.reset();
this.adaptor.addChild(root_1, stream_action1t.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2864:10: ( action1t )+
// Ham4Parser.g:2864:10: ( action1t )+
var cnt110=0;
loop110:
do {
var alt110=2;
alt110 = this.dfa110.predict(this.input);
switch (alt110) {
case 1 :
// Ham4Parser.g:2864:12: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqnmoraction1t10679);
action1t301=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t301.getTree());
break;
default :
if ( cnt110 >= 1 ) {
break loop110;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(110, this.input);
throw eee;
}
cnt110++;
} while (true);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2865:6: -> ^( SEQACT1T ( action1t )* )
{
// Ham4Parser.g:2865:9: ^( SEQACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT1T, "SEQACT1T"), root_1);
// Ham4Parser.g:2865:20: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
HamSeqend302=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqnmoraction1t10716); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend302);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqnmoraction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction1t_return: (function() {
Ham4Parser.seqfusedaction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2871:1: seqfusedaction1t : HamFusionbegin ( action1t )+ HamFusionend -> ^( SEQFUSEDACT1T ( action1t )* ) ;
// $ANTLR start "seqfusedaction1t"
seqfusedaction1t: function() {
var retval = new Ham4Parser.seqfusedaction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin303 = null;
var HamFusionend305 = null;
var action1t304 = null;
var HamFusionbegin303_tree=null;
var HamFusionend305_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
this.trace("ANTLR Parse: seqfusedaction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2890:5: ( HamFusionbegin ( action1t )+ HamFusionend -> ^( SEQFUSEDACT1T ( action1t )* ) )
// Ham4Parser.g:2891:9: HamFusionbegin ( action1t )+ HamFusionend
HamFusionbegin303=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction1t10761); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin303);
// Ham4Parser.g:2892:9: ( action1t )+
var cnt112=0;
loop112:
do {
var alt112=2;
alt112 = this.dfa112.predict(this.input);
switch (alt112) {
case 1 :
// Ham4Parser.g:2892:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqfusedaction1t10774);
action1t304=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t304.getTree());
break;
default :
if ( cnt112 >= 1 ) {
break loop112;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(112, this.input);
throw eee;
}
cnt112++;
} while (true);
HamFusionend305=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction1t10787); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend305);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2895:5: -> ^( SEQFUSEDACT1T ( action1t )* )
{
// Ham4Parser.g:2895:8: ^( SEQFUSEDACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT1T, "SEQFUSEDACT1T"), root_1);
// Ham4Parser.g:2895:24: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction1_return: (function() {
Ham4Parser.paraction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2898:1: paraction1 : HamParbegin ( action1 )+ HamParend -> ^( PARACT1 ( action1 )* ) ;
// $ANTLR start "paraction1"
paraction1: function() {
var retval = new Ham4Parser.paraction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin306 = null;
var HamParend308 = null;
var action1307 = null;
var HamParbegin306_tree=null;
var HamParend308_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: paraction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2917:5: ( HamParbegin ( action1 )+ HamParend -> ^( PARACT1 ( action1 )* ) )
// Ham4Parser.g:2918:9: HamParbegin ( action1 )+ HamParend
HamParbegin306=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction110845); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin306);
// Ham4Parser.g:2919:9: ( action1 )+
var cnt113=0;
loop113:
do {
var alt113=2;
alt113 = this.dfa113.predict(this.input);
switch (alt113) {
case 1 :
// Ham4Parser.g:2919:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_paraction110858);
action1307=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1307.getTree());
break;
default :
if ( cnt113 >= 1 ) {
break loop113;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(113, this.input);
throw eee;
}
cnt113++;
} while (true);
HamParend308=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction110871); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend308);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2922:5: -> ^( PARACT1 ( action1 )* )
{
// Ham4Parser.g:2922:8: ^( PARACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT1, "PARACT1"), root_1);
// Ham4Parser.g:2922:18: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqaction1_return: (function() {
Ham4Parser.seqaction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqaction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2925:1: seqaction1 : HamSeqbegin ( action1 )+ HamSeqend -> ^( SEQACT1 ( action1 )* ) ;
// $ANTLR start "seqaction1"
seqaction1: function() {
var retval = new Ham4Parser.seqaction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin309 = null;
var HamSeqend311 = null;
var action1310 = null;
var HamSeqbegin309_tree=null;
var HamSeqend311_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: seqaction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2944:5: ( HamSeqbegin ( action1 )+ HamSeqend -> ^( SEQACT1 ( action1 )* ) )
// Ham4Parser.g:2945:9: HamSeqbegin ( action1 )+ HamSeqend
HamSeqbegin309=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqaction110929); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin309);
// Ham4Parser.g:2946:9: ( action1 )+
var cnt114=0;
loop114:
do {
var alt114=2;
alt114 = this.dfa114.predict(this.input);
switch (alt114) {
case 1 :
// Ham4Parser.g:2946:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_seqaction110942);
action1310=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1310.getTree());
break;
default :
if ( cnt114 >= 1 ) {
break loop114;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(114, this.input);
throw eee;
}
cnt114++;
} while (true);
HamSeqend311=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqaction110955); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend311);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2949:5: -> ^( SEQACT1 ( action1 )* )
{
// Ham4Parser.g:2949:8: ^( SEQACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT1, "SEQACT1"), root_1);
// Ham4Parser.g:2949:18: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqaction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction1_return: (function() {
Ham4Parser.seqfusedaction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2952:1: seqfusedaction1 : HamFusionbegin ( action1 )+ HamFusionend -> ^( SEQFUSEDACT1 ( action1 )* ) ;
// $ANTLR start "seqfusedaction1"
seqfusedaction1: function() {
var retval = new Ham4Parser.seqfusedaction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin312 = null;
var HamFusionend314 = null;
var action1313 = null;
var HamFusionbegin312_tree=null;
var HamFusionend314_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: seqfusedaction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2971:5: ( HamFusionbegin ( action1 )+ HamFusionend -> ^( SEQFUSEDACT1 ( action1 )* ) )
// Ham4Parser.g:2972:9: HamFusionbegin ( action1 )+ HamFusionend
HamFusionbegin312=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction111013); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin312);
// Ham4Parser.g:2973:9: ( action1 )+
var cnt115=0;
loop115:
do {
var alt115=2;
alt115 = this.dfa115.predict(this.input);
switch (alt115) {
case 1 :
// Ham4Parser.g:2973:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_seqfusedaction111026);
action1313=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1313.getTree());
break;
default :
if ( cnt115 >= 1 ) {
break loop115;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(115, this.input);
throw eee;
}
cnt115++;
} while (true);
HamFusionend314=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction111039); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend314);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2976:5: -> ^( SEQFUSEDACT1 ( action1 )* )
{
// Ham4Parser.g:2976:8: ^( SEQFUSEDACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT1, "SEQFUSEDACT1"), root_1);
// Ham4Parser.g:2976:23: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetitionsoption_return: (function() {
Ham4Parser.repetitionsoption_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetitionsoption_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2979:1: repetitionsoption : ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )? ;
// $ANTLR start "repetitionsoption"
repetitionsoption: function() {
var retval = new Ham4Parser.repetitionsoption_return();
retval.start = this.input.LT(1);
var root_0 = null;
var repetitions315 = null;
this.trace("ANTLR Parse: repetitionsoption starts "+this.state.backtracking);
try {
// Ham4Parser.g:2998:5: ( ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )? )
// Ham4Parser.g:2999:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2999:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?
var alt116=2;
alt116 = this.dfa116.predict(this.input);
switch (alt116) {
case 1 :
// Ham4Parser.g:3000:13: ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions
this.pushFollow(Ham4Parser.FOLLOW_repetitions_in_repetitionsoption11154);
repetitions315=this.repetitions();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, repetitions315.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetitionsoption finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetitions_return: (function() {
Ham4Parser.repetitions_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetitions_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3006:1: repetitions : ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) ) ;
// $ANTLR start "repetitions"
repetitions: function() {
var retval = new Ham4Parser.repetitions_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin316 = null;
var HamRepeatfromstartseveral317 = null;
var HamEtc318 = null;
var HamSeqend320 = null;
var HamEtc322 = null;
var HamAlternatingmotion326 = null;
var HamAlternatingmotion327 = null;
var HamAlternatingmotion328 = null;
var HamAlternatingmotion329 = null;
var ellipsedirection319 = null;
var repetition321 = null;
var repetition323 = null;
var movingrepetition324 = null;
var sizechangenonlinear325 = null;
var HamSeqbegin316_tree=null;
var HamRepeatfromstartseveral317_tree=null;
var HamEtc318_tree=null;
var HamSeqend320_tree=null;
var HamEtc322_tree=null;
var HamAlternatingmotion326_tree=null;
var HamAlternatingmotion327_tree=null;
var HamAlternatingmotion328_tree=null;
var HamAlternatingmotion329_tree=null;
var stream_HamAlternatingmotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamAlternatingmotion");
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_HamRepeatfromstartseveral=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamRepeatfromstartseveral");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_movingrepetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movingrepetition");
var stream_ellipsedirection=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ellipsedirection");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_repetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetition");
this.trace("ANTLR Parse: repetitions starts "+this.state.backtracking);
try {
// Ham4Parser.g:3051:5: ( ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) ) )
// Ham4Parser.g:3052:5: ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) )
// Ham4Parser.g:3052:5: ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) )
var alt123=3;
switch ( this.input.LA(1) ) {
case HamSeqbegin:
var LA123_1 = this.input.LA(2);
if ( (this.synpred36_Ham4Parser()) ) {
alt123=1;
}
else if ( (true) ) {
alt123=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 123, 1, this.input);
throw nvae;
}
break;
case HamRepeatfromstart:
case HamRepeatfromstartseveral:
case HamRepeatcontinue:
case HamRepeatcontinueseveral:
case HamRepeatreverse:
alt123=2;
break;
case HamAlternatingmotion:
alt123=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 123, 0, this.input);
throw nvae;
}
switch (alt123) {
case 1 :
// Ham4Parser.g:3053:9: ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend
HamSeqbegin316=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_repetitions11234); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin316);
HamRepeatfromstartseveral317=this.match(this.input,HamRepeatfromstartseveral,Ham4Parser.FOLLOW_HamRepeatfromstartseveral_in_repetitions11245); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamRepeatfromstartseveral.add(HamRepeatfromstartseveral317);
HamEtc318=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_repetitions11255); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc318);
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_repetitions11265);
ellipsedirection319=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ellipsedirection.add(ellipsedirection319.getTree());
HamSeqend320=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_repetitions11275); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend320);
// AST REWRITE
// elements: HamEtc, ellipsedirection, HamRepeatfromstartseveral
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3060:5: -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection )
{
// Ham4Parser.g:3060:8: ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
this.adaptor.addChild(root_1, stream_HamRepeatfromstartseveral.nextNode());
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
this.adaptor.addChild(root_1, stream_ellipsedirection.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:3062:9: ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )?
// Ham4Parser.g:3062:9: ( repetition ( HamEtc | repetition )? | movingrepetition )
var alt118=2;
var LA118_0 = this.input.LA(1);
if ( ((LA118_0>=HamRepeatfromstart && LA118_0<=HamRepeatcontinueseveral)||LA118_0==HamRepeatreverse) ) {
alt118=1;
}
else if ( (LA118_0==HamSeqbegin) ) {
alt118=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 118, 0, this.input);
throw nvae;
}
switch (alt118) {
case 1 :
// Ham4Parser.g:3063:13: repetition ( HamEtc | repetition )?
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_repetitions11322);
repetition321=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition321.getTree());
// Ham4Parser.g:3064:13: ( HamEtc | repetition )?
var alt117=3;
var LA117_0 = this.input.LA(1);
if ( (LA117_0==HamEtc) ) {
alt117=1;
}
else if ( ((LA117_0>=HamRepeatfromstart && LA117_0<=HamRepeatcontinueseveral)||LA117_0==HamRepeatreverse) ) {
alt117=2;
}
switch (alt117) {
case 1 :
// Ham4Parser.g:3065:17: HamEtc
HamEtc322=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_repetitions11354); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc322);
break;
case 2 :
// Ham4Parser.g:3067:17: repetition
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_repetitions11386);
repetition323=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition323.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3070:13: movingrepetition
this.pushFollow(Ham4Parser.FOLLOW_movingrepetition_in_repetitions11425);
movingrepetition324=this.movingrepetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movingrepetition.add(movingrepetition324.getTree());
break;
}
// Ham4Parser.g:3072:9: ( sizechangenonlinear )?
var alt119=2;
var LA119_0 = this.input.LA(1);
if ( ((LA119_0>=HamIncreasing && LA119_0<=HamDecreasing)) ) {
alt119=1;
}
switch (alt119) {
case 1 :
// Ham4Parser.g:3072:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_repetitions11447);
sizechangenonlinear325=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear325.getTree());
break;
}
// Ham4Parser.g:3073:9: ( HamAlternatingmotion ( HamAlternatingmotion )? )?
var alt121=2;
var LA121_0 = this.input.LA(1);
if ( (LA121_0==HamAlternatingmotion) ) {
alt121=1;
}
switch (alt121) {
case 1 :
// Ham4Parser.g:3074:13: HamAlternatingmotion ( HamAlternatingmotion )?
HamAlternatingmotion326=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11474); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion326);
// Ham4Parser.g:3075:13: ( HamAlternatingmotion )?
var alt120=2;
var LA120_0 = this.input.LA(1);
if ( (LA120_0==HamAlternatingmotion) ) {
alt120=1;
}
switch (alt120) {
case 1 :
// Ham4Parser.g:3075:15: HamAlternatingmotion
HamAlternatingmotion327=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11490); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion327);
break;
}
break;
}
// AST REWRITE
// elements: HamEtc, sizechangenonlinear, HamAlternatingmotion, movingrepetition, repetition
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3077:5: -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* )
{
// Ham4Parser.g:3077:8: ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
// Ham4Parser.g:3077:22: ( repetition )*
while ( stream_repetition.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetition.nextTree());
}
stream_repetition.reset();
// Ham4Parser.g:3077:34: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:3077:42: ( movingrepetition )?
if ( stream_movingrepetition.hasNext() ) {
this.adaptor.addChild(root_1, stream_movingrepetition.nextTree());
}
stream_movingrepetition.reset();
// Ham4Parser.g:3077:60: ( sizechangenonlinear )?
if ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
// Ham4Parser.g:3077:81: ( HamAlternatingmotion )*
while ( stream_HamAlternatingmotion.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamAlternatingmotion.nextNode());
}
stream_HamAlternatingmotion.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:3079:9: HamAlternatingmotion ( HamAlternatingmotion )?
HamAlternatingmotion328=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11545); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion328);
// Ham4Parser.g:3080:9: ( HamAlternatingmotion )?
var alt122=2;
var LA122_0 = this.input.LA(1);
if ( (LA122_0==HamAlternatingmotion) ) {
alt122=1;
}
switch (alt122) {
case 1 :
// Ham4Parser.g:3080:11: HamAlternatingmotion
HamAlternatingmotion329=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11557); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion329);
break;
}
// AST REWRITE
// elements: HamAlternatingmotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3081:5: -> ^( REPETITIONS ( HamAlternatingmotion )* )
{
// Ham4Parser.g:3081:8: ^( REPETITIONS ( HamAlternatingmotion )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
// Ham4Parser.g:3081:22: ( HamAlternatingmotion )*
while ( stream_HamAlternatingmotion.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamAlternatingmotion.nextNode());
}
stream_HamAlternatingmotion.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetitions finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
alternations_return: (function() {
Ham4Parser.alternations_return = function(){};
org.antlr.lang.extend(Ham4Parser.alternations_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3085:1: alternations : HamAlternatingmotion ( HamAlternatingmotion )? ;
// $ANTLR start "alternations"
alternations: function() {
var retval = new Ham4Parser.alternations_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamAlternatingmotion330 = null;
var HamAlternatingmotion331 = null;
var HamAlternatingmotion330_tree=null;
var HamAlternatingmotion331_tree=null;
this.trace("ANTLR Parse: alternations starts "+this.state.backtracking);
try {
// Ham4Parser.g:3100:5: ( HamAlternatingmotion ( HamAlternatingmotion )? )
// Ham4Parser.g:3100:9: HamAlternatingmotion ( HamAlternatingmotion )?
root_0 = this.adaptor.nil();
HamAlternatingmotion330=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_alternations11608); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion330_tree = this.adaptor.create(HamAlternatingmotion330);
this.adaptor.addChild(root_0, HamAlternatingmotion330_tree);
}
// Ham4Parser.g:3101:9: ( HamAlternatingmotion )?
var alt124=2;
var LA124_0 = this.input.LA(1);
if ( (LA124_0==HamAlternatingmotion) ) {
alt124=1;
}
switch (alt124) {
case 1 :
// Ham4Parser.g:3101:11: HamAlternatingmotion
HamAlternatingmotion331=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_alternations11620); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion331_tree = this.adaptor.create(HamAlternatingmotion331);
this.adaptor.addChild(root_0, HamAlternatingmotion331_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: alternations finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movingrepetition_return: (function() {
Ham4Parser.movingrepetition_return = function(){};
org.antlr.lang.extend(Ham4Parser.movingrepetition_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3104:1: movingrepetition : HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* ) ;
// $ANTLR start "movingrepetition"
movingrepetition: function() {
var retval = new Ham4Parser.movingrepetition_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin332 = null;
var HamSeqend337 = null;
var repetition333 = null;
var movementarrow334 = null;
var size335 = null;
var sizechangenonlinear336 = null;
var HamSeqbegin332_tree=null;
var HamSeqend337_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_movementarrow=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementarrow");
var stream_size=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule size");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_repetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetition");
this.trace("ANTLR Parse: movingrepetition starts "+this.state.backtracking);
try {
// Ham4Parser.g:3126:5: ( HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* ) )
// Ham4Parser.g:3127:9: HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend
HamSeqbegin332=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_movingrepetition11658); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin332);
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_movingrepetition11669);
repetition333=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition333.getTree());
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_movingrepetition11679);
movementarrow334=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow334.getTree());
// Ham4Parser.g:3130:9: ( size )?
var alt125=2;
var LA125_0 = this.input.LA(1);
if ( ((LA125_0>=HamSmallmod && LA125_0<=HamLargemod)) ) {
alt125=1;
}
switch (alt125) {
case 1 :
// Ham4Parser.g:3130:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_movingrepetition11691);
size335=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size335.getTree());
break;
}
// Ham4Parser.g:3131:9: ( sizechangenonlinear )?
var alt126=2;
var LA126_0 = this.input.LA(1);
if ( ((LA126_0>=HamIncreasing && LA126_0<=HamDecreasing)) ) {
alt126=1;
}
switch (alt126) {
case 1 :
// Ham4Parser.g:3131:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_movingrepetition11706);
sizechangenonlinear336=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear336.getTree());
break;
}
HamSeqend337=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_movingrepetition11719); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend337);
// AST REWRITE
// elements: size, movementarrow, sizechangenonlinear, repetition
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3134:4: -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* )
{
// Ham4Parser.g:3134:7: ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MOVINGREPETITION, "MOVINGREPETITION"), root_1);
this.adaptor.addChild(root_1, stream_repetition.nextTree());
this.adaptor.addChild(root_1, stream_movementarrow.nextTree());
// Ham4Parser.g:3134:51: ( size )*
while ( stream_size.hasNext() ) {
this.adaptor.addChild(root_1, stream_size.nextTree());
}
stream_size.reset();
// Ham4Parser.g:3134:57: ( sizechangenonlinear )*
while ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movingrepetition finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
simplemovement_return: (function() {
Ham4Parser.simplemovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.simplemovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3140:1: simplemovement : ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )? -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? ) ;
// $ANTLR start "simplemovement"
simplemovement: function() {
var retval = new Ham4Parser.simplemovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFingerplay352 = null;
var straightmovement338 = null;
var size339 = null;
var arckind340 = null;
var zigzag341 = null;
var circularmovement342 = null;
var size343 = null;
var revolutions344 = null;
var ellipse345 = null;
var sizechangenonlinear346 = null;
var movementcross347 = null;
var size348 = null;
var wristmovement349 = null;
var size350 = null;
var replacement351 = null;
var brushingcontact353 = null;
var locationindexdefine354 = null;
var HamFingerplay352_tree=null;
var stream_HamFingerplay=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFingerplay");
var stream_locationindexdefine=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationindexdefine");
var stream_movementcross=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementcross");
var stream_brushingcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule brushingcontact");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_arckind=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule arckind");
var stream_straightmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule straightmovement");
var stream_zigzag=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule zigzag");
var stream_circularmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule circularmovement");
var stream_revolutions=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule revolutions");
var stream_size=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule size");
var stream_ellipse=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ellipse");
var stream_wristmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule wristmovement");
var stream_replacement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule replacement");
this.trace("ANTLR Parse: simplemovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3195:5: ( ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )? -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? ) )
// Ham4Parser.g:3196:9: ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )?
// Ham4Parser.g:3196:9: ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay )
var alt135=6;
switch ( this.input.LA(1) ) {
case HamMoveu:
case HamMoveur:
case HamMover:
case HamMovedr:
case HamMoved:
case HamMovedl:
case HamMovel:
case HamMoveul:
case HamMoveol:
case HamMoveo:
case HamMoveor:
case HamMoveil:
case HamMovei:
case HamMoveir:
case HamMoveui:
case HamMovedi:
case HamMovedo:
case HamMoveuo:
alt135=1;
break;
case HamCircleo:
case HamCirclei:
case HamCircled:
case HamCircleu:
case HamCirclel:
case HamCircler:
case HamCircleul:
case HamCircledr:
case HamCircleur:
case HamCircledl:
case HamCircleol:
case HamCircleir:
case HamCircleor:
case HamCircleil:
case HamCircledo:
case HamCircleui:
case HamCircledi:
case HamCircleuo:
alt135=2;
break;
case HamMovecross:
case HamMovex:
alt135=3;
break;
case HamNodding:
case HamSwinging:
case HamTwisting:
case HamStircw:
case HamStirccw:
alt135=4;
break;
case HamReplace:
alt135=5;
break;
case HamFingerplay:
alt135=6;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);
throw nvae;
}
switch (alt135) {
case 1 :
// Ham4Parser.g:3197:13: straightmovement ( size )? ( arckind | zigzag )?
this.pushFollow(Ham4Parser.FOLLOW_straightmovement_in_simplemovement11800);
straightmovement338=this.straightmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_straightmovement.add(straightmovement338.getTree());
// Ham4Parser.g:3198:13: ( size )?
var alt127=2;
alt127 = this.dfa127.predict(this.input);
switch (alt127) {
case 1 :
// Ham4Parser.g:3198:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement11816);
size339=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size339.getTree());
break;
}
// Ham4Parser.g:3199:13: ( arckind | zigzag )?
var alt128=3;
alt128 = this.dfa128.predict(this.input);
switch (alt128) {
case 1 :
// Ham4Parser.g:3200:17: arckind
this.pushFollow(Ham4Parser.FOLLOW_arckind_in_simplemovement11851);
arckind340=this.arckind();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_arckind.add(arckind340.getTree());
break;
case 2 :
// Ham4Parser.g:3202:17: zigzag
this.pushFollow(Ham4Parser.FOLLOW_zigzag_in_simplemovement11883);
zigzag341=this.zigzag();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_zigzag.add(zigzag341.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3205:13: circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )?
this.pushFollow(Ham4Parser.FOLLOW_circularmovement_in_simplemovement11922);
circularmovement342=this.circularmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_circularmovement.add(circularmovement342.getTree());
// Ham4Parser.g:3206:13: ( size )?
var alt129=2;
alt129 = this.dfa129.predict(this.input);
switch (alt129) {
case 1 :
// Ham4Parser.g:3206:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement11938);
size343=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size343.getTree());
break;
}
// Ham4Parser.g:3207:13: ( revolutions )?
var alt130=2;
alt130 = this.dfa130.predict(this.input);
switch (alt130) {
case 1 :
// Ham4Parser.g:3207:15: revolutions
this.pushFollow(Ham4Parser.FOLLOW_revolutions_in_simplemovement11957);
revolutions344=this.revolutions();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_revolutions.add(revolutions344.getTree());
break;
}
// Ham4Parser.g:3208:13: ( ellipse )?
var alt131=2;
alt131 = this.dfa131.predict(this.input);
switch (alt131) {
case 1 :
// Ham4Parser.g:3208:15: ellipse
this.pushFollow(Ham4Parser.FOLLOW_ellipse_in_simplemovement11976);
ellipse345=this.ellipse();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ellipse.add(ellipse345.getTree());
break;
}
// Ham4Parser.g:3209:13: ( sizechangenonlinear )?
var alt132=2;
alt132 = this.dfa132.predict(this.input);
switch (alt132) {
case 1 :
// Ham4Parser.g:3209:15: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_simplemovement11995);
sizechangenonlinear346=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear346.getTree());
break;
}
break;
case 3 :
// Ham4Parser.g:3211:13: movementcross ( size )?
this.pushFollow(Ham4Parser.FOLLOW_movementcross_in_simplemovement12022);
movementcross347=this.movementcross();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcross.add(movementcross347.getTree());
// Ham4Parser.g:3212:13: ( size )?
var alt133=2;
alt133 = this.dfa133.predict(this.input);
switch (alt133) {
case 1 :
// Ham4Parser.g:3212:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement12038);
size348=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size348.getTree());
break;
}
break;
case 4 :
// Ham4Parser.g:3214:13: wristmovement ( size )?
this.pushFollow(Ham4Parser.FOLLOW_wristmovement_in_simplemovement12065);
wristmovement349=this.wristmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_wristmovement.add(wristmovement349.getTree());
// Ham4Parser.g:3215:13: ( size )?
var alt134=2;
alt134 = this.dfa134.predict(this.input);
switch (alt134) {
case 1 :
// Ham4Parser.g:3215:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement12081);
size350=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size350.getTree());
break;
}
break;
case 5 :
// Ham4Parser.g:3217:13: replacement
this.pushFollow(Ham4Parser.FOLLOW_replacement_in_simplemovement12108);
replacement351=this.replacement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacement.add(replacement351.getTree());
break;
case 6 :
// Ham4Parser.g:3219:13: HamFingerplay
HamFingerplay352=this.match(this.input,HamFingerplay,Ham4Parser.FOLLOW_HamFingerplay_in_simplemovement12132); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFingerplay.add(HamFingerplay352);
break;
}
// Ham4Parser.g:3221:9: ( ( HamSeqbegin HamBrushing )=> brushingcontact )?
var alt136=2;
alt136 = this.dfa136.predict(this.input);
switch (alt136) {
case 1 :
// Ham4Parser.g:3222:11: ( HamSeqbegin HamBrushing )=> brushingcontact
this.pushFollow(Ham4Parser.FOLLOW_brushingcontact_in_simplemovement12194);
brushingcontact353=this.brushingcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_brushingcontact.add(brushingcontact353.getTree());
break;
}
// Ham4Parser.g:3226:9: ( ( locationindexdefine )=> locationindexdefine )?
var alt137=2;
alt137 = this.dfa137.predict(this.input);
switch (alt137) {
case 1 :
// Ham4Parser.g:3227:11: ( locationindexdefine )=> locationindexdefine
this.pushFollow(Ham4Parser.FOLLOW_locationindexdefine_in_simplemovement12289);
locationindexdefine354=this.locationindexdefine();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationindexdefine.add(locationindexdefine354.getTree());
break;
}
// AST REWRITE
// elements: replacement, revolutions, wristmovement, locationindexdefine, straightmovement, zigzag, movementcross, ellipse, sizechangenonlinear, HamFingerplay, brushingcontact, arckind, circularmovement, size
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3232:4: -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? )
{
// Ham4Parser.g:3232:7: ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIMPLEMVMT, "SIMPLEMVMT"), root_1);
// Ham4Parser.g:3232:20: ( straightmovement )?
if ( stream_straightmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_straightmovement.nextTree());
}
stream_straightmovement.reset();
// Ham4Parser.g:3232:38: ( circularmovement )?
if ( stream_circularmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_circularmovement.nextTree());
}
stream_circularmovement.reset();
// Ham4Parser.g:3232:56: ( movementcross )?
if ( stream_movementcross.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementcross.nextTree());
}
stream_movementcross.reset();
// Ham4Parser.g:3232:71: ( wristmovement )?
if ( stream_wristmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_wristmovement.nextTree());
}
stream_wristmovement.reset();
// Ham4Parser.g:3232:86: ( size )?
if ( stream_size.hasNext() ) {
this.adaptor.addChild(root_1, stream_size.nextTree());
}
stream_size.reset();
// Ham4Parser.g:3233:6: ( arckind )?
if ( stream_arckind.hasNext() ) {
this.adaptor.addChild(root_1, stream_arckind.nextTree());
}
stream_arckind.reset();
// Ham4Parser.g:3233:15: ( zigzag )?
if ( stream_zigzag.hasNext() ) {
this.adaptor.addChild(root_1, stream_zigzag.nextTree());
}
stream_zigzag.reset();
// Ham4Parser.g:3234:6: ( revolutions )?
if ( stream_revolutions.hasNext() ) {
this.adaptor.addChild(root_1, stream_revolutions.nextTree());
}
stream_revolutions.reset();
// Ham4Parser.g:3234:19: ( ellipse )?
if ( stream_ellipse.hasNext() ) {
this.adaptor.addChild(root_1, stream_ellipse.nextTree());
}
stream_ellipse.reset();
// Ham4Parser.g:3234:28: ( sizechangenonlinear )?
if ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
// Ham4Parser.g:3235:6: ( replacement )?
if ( stream_replacement.hasNext() ) {
this.adaptor.addChild(root_1, stream_replacement.nextTree());
}
stream_replacement.reset();
// Ham4Parser.g:3235:19: ( HamFingerplay )?
if ( stream_HamFingerplay.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamFingerplay.nextNode());
}
stream_HamFingerplay.reset();
// Ham4Parser.g:3236:6: ( brushingcontact )?
if ( stream_brushingcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_brushingcontact.nextTree());
}
stream_brushingcontact.reset();
// Ham4Parser.g:3236:23: ( locationindexdefine )?
if ( stream_locationindexdefine.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationindexdefine.nextTree());
}
stream_locationindexdefine.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: simplemovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
specialfingerplaymovement_return: (function() {
Ham4Parser.specialfingerplaymovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.specialfingerplaymovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3239:1: specialfingerplaymovement : HamSeqbegin ( digit )+ HamFingerplay HamSeqend -> ^( SIMPLEMVMT ( digit )* HamFingerplay ) ;
// $ANTLR start "specialfingerplaymovement"
specialfingerplaymovement: function() {
var retval = new Ham4Parser.specialfingerplaymovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin355 = null;
var HamFingerplay357 = null;
var HamSeqend358 = null;
var digit356 = null;
var HamSeqbegin355_tree=null;
var HamFingerplay357_tree=null;
var HamSeqend358_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamFingerplay=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFingerplay");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: specialfingerplaymovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3258:5: ( HamSeqbegin ( digit )+ HamFingerplay HamSeqend -> ^( SIMPLEMVMT ( digit )* HamFingerplay ) )
// Ham4Parser.g:3259:9: HamSeqbegin ( digit )+ HamFingerplay HamSeqend
HamSeqbegin355=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_specialfingerplaymovement12449); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin355);
// Ham4Parser.g:3260:9: ( digit )+
var cnt138=0;
loop138:
do {
var alt138=2;
var LA138_0 = this.input.LA(1);
if ( ((LA138_0>=HamThumb && LA138_0<=HamPinky)) ) {
alt138=1;
}
switch (alt138) {
case 1 :
// Ham4Parser.g:3260:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_specialfingerplaymovement12462);
digit356=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(digit356.getTree());
break;
default :
if ( cnt138 >= 1 ) {
break loop138;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(138, this.input);
throw eee;
}
cnt138++;
} while (true);
HamFingerplay357=this.match(this.input,HamFingerplay,Ham4Parser.FOLLOW_HamFingerplay_in_specialfingerplaymovement12475); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFingerplay.add(HamFingerplay357);
HamSeqend358=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_specialfingerplaymovement12485); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend358);
// AST REWRITE
// elements: HamFingerplay, digit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3263:5: -> ^( SIMPLEMVMT ( digit )* HamFingerplay )
{
// Ham4Parser.g:3263:8: ^( SIMPLEMVMT ( digit )* HamFingerplay )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIMPLEMVMT, "SIMPLEMVMT"), root_1);
// Ham4Parser.g:3263:21: ( digit )*
while ( stream_digit.hasNext() ) {
this.adaptor.addChild(root_1, stream_digit.nextTree());
}
stream_digit.reset();
this.adaptor.addChild(root_1, stream_HamFingerplay.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: specialfingerplaymovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
straightmovement_return: (function() {
Ham4Parser.straightmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.straightmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3266:1: straightmovement : movementarrow ( HamBetween movementarrow )? -> ^( STRGHTMVMT ( movementarrow )* ) ;
// $ANTLR start "straightmovement"
straightmovement: function() {
var retval = new Ham4Parser.straightmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween360 = null;
var movementarrow359 = null;
var movementarrow361 = null;
var HamBetween360_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_movementarrow=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementarrow");
this.trace("ANTLR Parse: straightmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3285:5: ( movementarrow ( HamBetween movementarrow )? -> ^( STRGHTMVMT ( movementarrow )* ) )
// Ham4Parser.g:3285:9: movementarrow ( HamBetween movementarrow )?
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_straightmovement12530);
movementarrow359=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow359.getTree());
// Ham4Parser.g:3286:9: ( HamBetween movementarrow )?
var alt139=2;
var LA139_0 = this.input.LA(1);
if ( (LA139_0==HamBetween) ) {
alt139=1;
}
switch (alt139) {
case 1 :
// Ham4Parser.g:3287:13: HamBetween movementarrow
HamBetween360=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_straightmovement12554); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween360);
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_straightmovement12569);
movementarrow361=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow361.getTree());
break;
}
// AST REWRITE
// elements: movementarrow
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3290:5: -> ^( STRGHTMVMT ( movementarrow )* )
{
// Ham4Parser.g:3290:8: ^( STRGHTMVMT ( movementarrow )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(STRGHTMVMT, "STRGHTMVMT"), root_1);
// Ham4Parser.g:3290:21: ( movementarrow )*
while ( stream_movementarrow.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementarrow.nextTree());
}
stream_movementarrow.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: straightmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
circularmovement_return: (function() {
Ham4Parser.circularmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.circularmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3293:1: circularmovement : movementcircle ( HamBetween movementcircle )? -> ^( CRCLRMVMT ( movementcircle )* ) ;
// $ANTLR start "circularmovement"
circularmovement: function() {
var retval = new Ham4Parser.circularmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween363 = null;
var movementcircle362 = null;
var movementcircle364 = null;
var HamBetween363_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_movementcircle=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementcircle");
this.trace("ANTLR Parse: circularmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3312:5: ( movementcircle ( HamBetween movementcircle )? -> ^( CRCLRMVMT ( movementcircle )* ) )
// Ham4Parser.g:3312:9: movementcircle ( HamBetween movementcircle )?
this.pushFollow(Ham4Parser.FOLLOW_movementcircle_in_circularmovement12622);
movementcircle362=this.movementcircle();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcircle.add(movementcircle362.getTree());
// Ham4Parser.g:3313:9: ( HamBetween movementcircle )?
var alt140=2;
var LA140_0 = this.input.LA(1);
if ( (LA140_0==HamBetween) ) {
alt140=1;
}
switch (alt140) {
case 1 :
// Ham4Parser.g:3314:13: HamBetween movementcircle
HamBetween363=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_circularmovement12646); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween363);
this.pushFollow(Ham4Parser.FOLLOW_movementcircle_in_circularmovement12661);
movementcircle364=this.movementcircle();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcircle.add(movementcircle364.getTree());
break;
}
// AST REWRITE
// elements: movementcircle
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3317:5: -> ^( CRCLRMVMT ( movementcircle )* )
{
// Ham4Parser.g:3317:8: ^( CRCLRMVMT ( movementcircle )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CRCLRMVMT, "CRCLRMVMT"), root_1);
// Ham4Parser.g:3317:20: ( movementcircle )*
while ( stream_movementcircle.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementcircle.nextTree());
}
stream_movementcircle.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: circularmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
arckind_return: (function() {
Ham4Parser.arckind_return = function(){};
org.antlr.lang.extend(Ham4Parser.arckind_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3320:1: arckind : arc ( arc )? ( size )? ;
// $ANTLR start "arckind"
arckind: function() {
var retval = new Ham4Parser.arckind_return();
retval.start = this.input.LT(1);
var root_0 = null;
var arc365 = null;
var arc366 = null;
var size367 = null;
this.trace("ANTLR Parse: arckind starts "+this.state.backtracking);
try {
// Ham4Parser.g:3336:5: ( arc ( arc )? ( size )? )
// Ham4Parser.g:3336:9: arc ( arc )? ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_arc_in_arckind12714);
arc365=this.arc();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arc365.getTree());
// Ham4Parser.g:3337:9: ( arc )?
var alt141=2;
var LA141_0 = this.input.LA(1);
if ( ((LA141_0>=HamArcl && LA141_0<=HamArcd)) ) {
alt141=1;
}
switch (alt141) {
case 1 :
// Ham4Parser.g:3337:11: arc
this.pushFollow(Ham4Parser.FOLLOW_arc_in_arckind12726);
arc366=this.arc();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arc366.getTree());
break;
}
// Ham4Parser.g:3338:9: ( size )?
var alt142=2;
var LA142_0 = this.input.LA(1);
if ( ((LA142_0>=HamSmallmod && LA142_0<=HamLargemod)) ) {
alt142=1;
}
switch (alt142) {
case 1 :
// Ham4Parser.g:3338:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_arckind12741);
size367=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size367.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: arckind finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
zigzag_return: (function() {
Ham4Parser.zigzag_return = function(){};
org.antlr.lang.extend(Ham4Parser.zigzag_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3341:1: zigzag : ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )? ;
// $ANTLR start "zigzag"
zigzag: function() {
var retval = new Ham4Parser.zigzag_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set368 = null;
var size369 = null;
var ellipsedirection370 = null;
var sizechangenonlinear371 = null;
var set368_tree=null;
this.trace("ANTLR Parse: zigzag starts "+this.state.backtracking);
try {
// Ham4Parser.g:3362:5: ( ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )? )
// Ham4Parser.g:3362:9: ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )?
root_0 = this.adaptor.nil();
set368=this.input.LT(1);
if ( (this.input.LA(1)>=HamWavy && this.input.LA(1)<=HamZigzag) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set368));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:3367:9: ( size )?
var alt143=2;
var LA143_0 = this.input.LA(1);
if ( ((LA143_0>=HamSmallmod && LA143_0<=HamLargemod)) ) {
alt143=1;
}
switch (alt143) {
case 1 :
// Ham4Parser.g:3367:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_zigzag12833);
size369=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size369.getTree());
break;
}
// Ham4Parser.g:3368:9: ( ellipsedirection )?
var alt144=2;
var LA144_0 = this.input.LA(1);
if ( ((LA144_0>=HamEllipseh && LA144_0<=HamEllipseul)) ) {
alt144=1;
}
switch (alt144) {
case 1 :
// Ham4Parser.g:3368:11: ellipsedirection
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_zigzag12848);
ellipsedirection370=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ellipsedirection370.getTree());
break;
}
// Ham4Parser.g:3369:9: ( sizechangenonlinear )?
var alt145=2;
var LA145_0 = this.input.LA(1);
if ( ((LA145_0>=HamIncreasing && LA145_0<=HamDecreasing)) ) {
alt145=1;
}
switch (alt145) {
case 1 :
// Ham4Parser.g:3369:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_zigzag12863);
sizechangenonlinear371=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sizechangenonlinear371.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: zigzag finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sizechangenonlinear_return: (function() {
Ham4Parser.sizechangenonlinear_return = function(){};
org.antlr.lang.extend(Ham4Parser.sizechangenonlinear_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3372:1: sizechangenonlinear : sizechange ( size )? ;
// $ANTLR start "sizechangenonlinear"
sizechangenonlinear: function() {
var retval = new Ham4Parser.sizechangenonlinear_return();
retval.start = this.input.LT(1);
var root_0 = null;
var sizechange372 = null;
var size373 = null;
this.trace("ANTLR Parse: sizechangenonlinear starts "+this.state.backtracking);
try {
// Ham4Parser.g:3387:5: ( sizechange ( size )? )
// Ham4Parser.g:3387:9: sizechange ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_sizechange_in_sizechangenonlinear12895);
sizechange372=this.sizechange();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sizechange372.getTree());
// Ham4Parser.g:3388:9: ( size )?
var alt146=2;
var LA146_0 = this.input.LA(1);
if ( ((LA146_0>=HamSmallmod && LA146_0<=HamLargemod)) ) {
alt146=1;
}
switch (alt146) {
case 1 :
// Ham4Parser.g:3388:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_sizechangenonlinear12907);
size373=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size373.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sizechangenonlinear finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ellipse_return: (function() {
Ham4Parser.ellipse_return = function(){};
org.antlr.lang.extend(Ham4Parser.ellipse_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3391:1: ellipse : ellipsedirection ( size )? ;
// $ANTLR start "ellipse"
ellipse: function() {
var retval = new Ham4Parser.ellipse_return();
retval.start = this.input.LT(1);
var root_0 = null;
var ellipsedirection374 = null;
var size375 = null;
this.trace("ANTLR Parse: ellipse starts "+this.state.backtracking);
try {
// Ham4Parser.g:3406:5: ( ellipsedirection ( size )? )
// Ham4Parser.g:3406:9: ellipsedirection ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_ellipse12939);
ellipsedirection374=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ellipsedirection374.getTree());
// Ham4Parser.g:3407:9: ( size )?
var alt147=2;
var LA147_0 = this.input.LA(1);
if ( ((LA147_0>=HamSmallmod && LA147_0<=HamLargemod)) ) {
alt147=1;
}
switch (alt147) {
case 1 :
// Ham4Parser.g:3407:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_ellipse12951);
size375=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size375.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ellipse finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
revolutions_return: (function() {
Ham4Parser.revolutions_return = function(){};
org.antlr.lang.extend(Ham4Parser.revolutions_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3410:1: revolutions : ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? ) ;
// $ANTLR start "revolutions"
revolutions: function() {
var retval = new Ham4Parser.revolutions_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamClockfull377 = null;
var HamClockfull378 = null;
var HamClockfull380 = null;
var HamClockfull381 = null;
var clock376 = null;
var clock379 = null;
var clock382 = null;
var HamClockfull377_tree=null;
var HamClockfull378_tree=null;
var HamClockfull380_tree=null;
var HamClockfull381_tree=null;
this.trace("ANTLR Parse: revolutions starts "+this.state.backtracking);
try {
// Ham4Parser.g:3436:5: ( ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? ) )
// Ham4Parser.g:3437:5: ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3437:5: ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? )
var alt153=2;
var LA153_0 = this.input.LA(1);
if ( ((LA153_0>=HamClocku && LA153_0<=HamClockur)) ) {
alt153=1;
}
else if ( (LA153_0==HamClockfull) ) {
alt153=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 153, 0, this.input);
throw nvae;
}
switch (alt153) {
case 1 :
// Ham4Parser.g:3438:9: clock ( HamClockfull ( HamClockfull )? )? ( clock )?
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions12995);
clock376=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock376.getTree());
// Ham4Parser.g:3439:9: ( HamClockfull ( HamClockfull )? )?
var alt149=2;
var LA149_0 = this.input.LA(1);
if ( (LA149_0==HamClockfull) ) {
alt149=1;
}
switch (alt149) {
case 1 :
// Ham4Parser.g:3440:13: HamClockfull ( HamClockfull )?
HamClockfull377=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13019); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull377_tree = this.adaptor.create(HamClockfull377);
this.adaptor.addChild(root_0, HamClockfull377_tree);
}
// Ham4Parser.g:3441:13: ( HamClockfull )?
var alt148=2;
var LA148_0 = this.input.LA(1);
if ( (LA148_0==HamClockfull) ) {
alt148=1;
}
switch (alt148) {
case 1 :
// Ham4Parser.g:3441:15: HamClockfull
HamClockfull378=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13035); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull378_tree = this.adaptor.create(HamClockfull378);
this.adaptor.addChild(root_0, HamClockfull378_tree);
}
break;
}
break;
}
// Ham4Parser.g:3443:9: ( clock )?
var alt150=2;
var LA150_0 = this.input.LA(1);
if ( ((LA150_0>=HamClocku && LA150_0<=HamClockur)) ) {
alt150=1;
}
switch (alt150) {
case 1 :
// Ham4Parser.g:3443:11: clock
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions13061);
clock379=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock379.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3445:9: HamClockfull ( HamClockfull )? ( clock )?
HamClockfull380=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13080); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull380_tree = this.adaptor.create(HamClockfull380);
this.adaptor.addChild(root_0, HamClockfull380_tree);
}
// Ham4Parser.g:3446:9: ( HamClockfull )?
var alt151=2;
var LA151_0 = this.input.LA(1);
if ( (LA151_0==HamClockfull) ) {
alt151=1;
}
switch (alt151) {
case 1 :
// Ham4Parser.g:3446:11: HamClockfull
HamClockfull381=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13092); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull381_tree = this.adaptor.create(HamClockfull381);
this.adaptor.addChild(root_0, HamClockfull381_tree);
}
break;
}
// Ham4Parser.g:3447:9: ( clock )?
var alt152=2;
var LA152_0 = this.input.LA(1);
if ( ((LA152_0>=HamClocku && LA152_0<=HamClockur)) ) {
alt152=1;
}
switch (alt152) {
case 1 :
// Ham4Parser.g:3447:11: clock
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions13107);
clock382=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock382.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: revolutions finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
replacement_return: (function() {
Ham4Parser.replacement_return = function(){};
org.antlr.lang.extend(Ham4Parser.replacement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3451:1: replacement : HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) ) ;
// $ANTLR start "replacement"
replacement: function() {
var retval = new Ham4Parser.replacement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamReplace383 = null;
var sizechange384 = null;
var handshape1385 = null;
var splitreplacetail386 = null;
var extfidir1387 = null;
var palmor1388 = null;
var splitreplacetail389 = null;
var extfidir1390 = null;
var palmor1391 = null;
var palmor1392 = null;
var HamReplace383_tree=null;
var stream_HamReplace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamReplace");
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_sizechange=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechange");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
var stream_splitreplacetail=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitreplacetail");
this.trace("ANTLR Parse: replacement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3488:5: ( HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) ) )
// Ham4Parser.g:3488:9: HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) )
HamReplace383=this.match(this.input,HamReplace,Ham4Parser.FOLLOW_HamReplace_in_replacement13145); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamReplace.add(HamReplace383);
// Ham4Parser.g:3489:9: ( sizechange )?
var alt154=2;
var LA154_0 = this.input.LA(1);
if ( ((LA154_0>=HamIncreasing && LA154_0<=HamDecreasing)) ) {
alt154=1;
}
switch (alt154) {
case 1 :
// Ham4Parser.g:3489:11: sizechange
this.pushFollow(Ham4Parser.FOLLOW_sizechange_in_replacement13158);
sizechange384=this.sizechange();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechange.add(sizechange384.getTree());
break;
}
// Ham4Parser.g:3490:9: ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) )
var alt159=4;
switch ( this.input.LA(1) ) {
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
case HamNondominant:
alt159=1;
break;
case HamParbegin:
alt159=2;
break;
case HamExtfingeru:
case HamExtfingerur:
case HamExtfingerr:
case HamExtfingerdr:
case HamExtfingerd:
case HamExtfingerdl:
case HamExtfingerl:
case HamExtfingerul:
case HamExtfingerol:
case HamExtfingero:
case HamExtfingeror:
case HamExtfingeril:
case HamExtfingeri:
case HamExtfingerir:
case HamExtfingerui:
case HamExtfingerdi:
case HamExtfingerdo:
case HamExtfingeruo:
alt159=3;
break;
case HamPalmu:
case HamPalmur:
case HamPalmr:
case HamPalmdr:
case HamPalmd:
case HamPalmdl:
case HamPalml:
case HamPalmul:
alt159=4;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 159, 0, this.input);
throw nvae;
}
switch (alt159) {
case 1 :
// Ham4Parser.g:3491:13: handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_replacement13185);
handshape1385=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape1385.getTree());
// Ham4Parser.g:3492:13: ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )
var alt157=2;
alt157 = this.dfa157.predict(this.input);
switch (alt157) {
case 1 :
// Ham4Parser.g:3493:17: ( splitreplacetail )=> splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_replacement13257);
splitreplacetail386=this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitreplacetail.add(splitreplacetail386.getTree());
break;
case 2 :
// Ham4Parser.g:3497:17: ( extfidir1 )? ( palmor1 )?
// Ham4Parser.g:3497:17: ( extfidir1 )?
var alt155=2;
var LA155_0 = this.input.LA(1);
if ( ((LA155_0>=HamExtfingeru && LA155_0<=HamExtfingeruo)) ) {
alt155=1;
}
switch (alt155) {
case 1 :
// Ham4Parser.g:3497:19: extfidir1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacement13291);
extfidir1387=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1387.getTree());
break;
}
// Ham4Parser.g:3498:17: ( palmor1 )?
var alt156=2;
var LA156_0 = this.input.LA(1);
if ( ((LA156_0>=HamPalmu && LA156_0<=HamPalmul)) ) {
alt156=1;
}
switch (alt156) {
case 1 :
// Ham4Parser.g:3498:19: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13314);
palmor1388=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1388.getTree());
break;
}
break;
}
// AST REWRITE
// elements: sizechange, palmor1, splitreplacetail, handshape1, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3500:6: -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* )
{
// Ham4Parser.g:3500:9: ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3500:19: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
// Ham4Parser.g:3500:42: ( splitreplacetail )*
while ( stream_splitreplacetail.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitreplacetail.nextTree());
}
stream_splitreplacetail.reset();
// Ham4Parser.g:3500:60: ( extfidir1 )*
while ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:3500:71: ( palmor1 )*
while ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:3502:13: splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_replacement13380);
splitreplacetail389=this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitreplacetail.add(splitreplacetail389.getTree());
// AST REWRITE
// elements: sizechange, splitreplacetail
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3503:5: -> ^( REPLACE ( sizechange )* splitreplacetail )
{
// Ham4Parser.g:3503:8: ^( REPLACE ( sizechange )* splitreplacetail )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3503:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_splitreplacetail.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:3505:13: extfidir1 ( palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacement13419);
extfidir1390=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1390.getTree());
// Ham4Parser.g:3506:13: ( palmor1 )?
var alt158=2;
var LA158_0 = this.input.LA(1);
if ( ((LA158_0>=HamPalmu && LA158_0<=HamPalmul)) ) {
alt158=1;
}
switch (alt158) {
case 1 :
// Ham4Parser.g:3506:15: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13435);
palmor1391=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1391.getTree());
break;
}
// AST REWRITE
// elements: palmor1, sizechange, extfidir1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3507:5: -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* )
{
// Ham4Parser.g:3507:8: ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3507:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
// Ham4Parser.g:3507:40: ( palmor1 )*
while ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:3509:13: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13480);
palmor1392=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1392.getTree());
// AST REWRITE
// elements: palmor1, sizechange
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3510:5: -> ^( REPLACE ( sizechange )* palmor1 )
{
// Ham4Parser.g:3510:8: ^( REPLACE ( sizechange )* palmor1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3510:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: replacement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitreplacetail_return: (function() {
Ham4Parser.splitreplacetail_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitreplacetail_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3514:1: splitreplacetail : HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend -> ^( SPLITREPLACETL ( replacetail1 )* ) ;
// $ANTLR start "splitreplacetail"
splitreplacetail: function() {
var retval = new Ham4Parser.splitreplacetail_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin393 = null;
var HamPlus395 = null;
var HamNomotion396 = null;
var HamParend398 = null;
var replacetail1394 = null;
var replacetail1397 = null;
var HamParbegin393_tree=null;
var HamPlus395_tree=null;
var HamNomotion396_tree=null;
var HamParend398_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_replacetail1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule replacetail1");
this.trace("ANTLR Parse: splitreplacetail starts "+this.state.backtracking);
try {
// Ham4Parser.g:3538:5: ( HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend -> ^( SPLITREPLACETL ( replacetail1 )* ) )
// Ham4Parser.g:3538:9: HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend
HamParbegin393=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitreplacetail13534); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin393);
this.pushFollow(Ham4Parser.FOLLOW_replacetail1_in_splitreplacetail13545);
replacetail1394=this.replacetail1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacetail1.add(replacetail1394.getTree());
HamPlus395=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitreplacetail13555); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus395);
// Ham4Parser.g:3541:9: ( HamNomotion | replacetail1 )
var alt160=2;
var LA160_0 = this.input.LA(1);
if ( (LA160_0==HamNomotion) ) {
alt160=1;
}
else if ( ((LA160_0>=HamExtfingeru && LA160_0<=HamExtfingeruo)||(LA160_0>=HamPalmu && LA160_0<=HamPalmul)) ) {
alt160=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 160, 0, this.input);
throw nvae;
}
switch (alt160) {
case 1 :
// Ham4Parser.g:3542:13: HamNomotion
HamNomotion396=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_splitreplacetail13580); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion396);
break;
case 2 :
// Ham4Parser.g:3544:13: replacetail1
this.pushFollow(Ham4Parser.FOLLOW_replacetail1_in_splitreplacetail13605);
replacetail1397=this.replacetail1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacetail1.add(replacetail1397.getTree());
break;
}
HamParend398=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitreplacetail13625); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend398);
// AST REWRITE
// elements: replacetail1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3548:5: -> ^( SPLITREPLACETL ( replacetail1 )* )
{
// Ham4Parser.g:3548:8: ^( SPLITREPLACETL ( replacetail1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITREPLACETL, "SPLITREPLACETL"), root_1);
// Ham4Parser.g:3548:25: ( replacetail1 )*
while ( stream_replacetail1.hasNext() ) {
this.adaptor.addChild(root_1, stream_replacetail1.nextTree());
}
stream_replacetail1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitreplacetail finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
replacetail1_return: (function() {
Ham4Parser.replacetail1_return = function(){};
org.antlr.lang.extend(Ham4Parser.replacetail1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3551:1: replacetail1 : ( extfidir1 ( palmor1 )? | palmor1 ) -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? ) ;
// $ANTLR start "replacetail1"
replacetail1: function() {
var retval = new Ham4Parser.replacetail1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidir1399 = null;
var palmor1400 = null;
var palmor1401 = null;
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: replacetail1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:3572:5: ( ( extfidir1 ( palmor1 )? | palmor1 ) -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? ) )
// Ham4Parser.g:3573:5: ( extfidir1 ( palmor1 )? | palmor1 )
// Ham4Parser.g:3573:5: ( extfidir1 ( palmor1 )? | palmor1 )
var alt162=2;
var LA162_0 = this.input.LA(1);
if ( ((LA162_0>=HamExtfingeru && LA162_0<=HamExtfingeruo)) ) {
alt162=1;
}
else if ( ((LA162_0>=HamPalmu && LA162_0<=HamPalmul)) ) {
alt162=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 162, 0, this.input);
throw nvae;
}
switch (alt162) {
case 1 :
// Ham4Parser.g:3574:9: extfidir1 ( palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacetail113689);
extfidir1399=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1399.getTree());
// Ham4Parser.g:3575:9: ( palmor1 )?
var alt161=2;
var LA161_0 = this.input.LA(1);
if ( ((LA161_0>=HamPalmu && LA161_0<=HamPalmul)) ) {
alt161=1;
}
switch (alt161) {
case 1 :
// Ham4Parser.g:3575:11: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacetail113701);
palmor1400=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1400.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3577:9: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacetail113720);
palmor1401=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1401.getTree());
break;
}
// AST REWRITE
// elements: extfidir1, palmor1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3579:4: -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? )
{
// Ham4Parser.g:3579:7: ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACETAIL1, "REPLACETAIL1"), root_1);
// Ham4Parser.g:3579:22: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:3579:33: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: replacetail1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
brushingcontact_return: (function() {
Ham4Parser.brushingcontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.brushingcontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3582:1: brushingcontact : HamSeqbegin HamBrushing location1 HamSeqend ;
// $ANTLR start "brushingcontact"
brushingcontact: function() {
var retval = new Ham4Parser.brushingcontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin402 = null;
var HamBrushing403 = null;
var HamSeqend405 = null;
var location1404 = null;
var HamSeqbegin402_tree=null;
var HamBrushing403_tree=null;
var HamSeqend405_tree=null;
this.trace("ANTLR Parse: brushingcontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:3600:5: ( HamSeqbegin HamBrushing location1 HamSeqend )
// Ham4Parser.g:3601:9: HamSeqbegin HamBrushing location1 HamSeqend
root_0 = this.adaptor.nil();
HamSeqbegin402=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_brushingcontact13776); if (this.state.failed) return retval;
HamBrushing403=this.match(this.input,HamBrushing,Ham4Parser.FOLLOW_HamBrushing_in_brushingcontact13788); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamBrushing403_tree = this.adaptor.create(HamBrushing403);
this.adaptor.addChild(root_0, HamBrushing403_tree);
}
this.pushFollow(Ham4Parser.FOLLOW_location1_in_brushingcontact13798);
location1404=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location1404.getTree());
HamSeqend405=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_brushingcontact13808); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: brushingcontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshapeclasstok_return: (function() {
Ham4Parser.handshapeclasstok_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshapeclasstok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3610:1: handshapeclasstok : ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ;
// $ANTLR start "handshapeclasstok"
handshapeclasstok: function() {
var retval = new Ham4Parser.handshapeclasstok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set406 = null;
var set406_tree=null;
this.trace("ANTLR Parse: handshapeclasstok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3639:5: ( ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) )
// Ham4Parser.g:3640:5: ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open )
root_0 = this.adaptor.nil();
set406=this.input.LT(1);
if ( (this.input.LA(1)>=HamFist && this.input.LA(1)<=HamFinger2345)||(this.input.LA(1)>=HamPinch12 && this.input.LA(1)<=HamCee12open) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set406));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshapeclasstok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshapeclass_return: (function() {
Ham4Parser.handshapeclass_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshapeclass_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3657:1: handshapeclass : handshapeclasstok -> ^( HSCLASS handshapeclasstok ) ;
// $ANTLR start "handshapeclass"
handshapeclass: function() {
var retval = new Ham4Parser.handshapeclass_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshapeclasstok407 = null;
var stream_handshapeclasstok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshapeclasstok");
try {
// Ham4Parser.g:3658:2: ( handshapeclasstok -> ^( HSCLASS handshapeclasstok ) )
// Ham4Parser.g:3658:4: handshapeclasstok
this.pushFollow(Ham4Parser.FOLLOW_handshapeclasstok_in_handshapeclass13980);
handshapeclasstok407=this.handshapeclasstok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshapeclasstok.add(handshapeclasstok407.getTree());
// AST REWRITE
// elements: handshapeclasstok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3659:2: -> ^( HSCLASS handshapeclasstok )
{
// Ham4Parser.g:3659:5: ^( HSCLASS handshapeclasstok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSCLASS, "HSCLASS"), root_1);
this.adaptor.addChild(root_1, stream_handshapeclasstok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerbendingtok_return: (function() {
Ham4Parser.fingerbendingtok_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerbendingtok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3662:1: fingerbendingtok : ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ;
// $ANTLR start "fingerbendingtok"
fingerbendingtok: function() {
var retval = new Ham4Parser.fingerbendingtok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set408 = null;
var set408_tree=null;
this.trace("ANTLR Parse: fingerbendingtok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3682:5: ( ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) )
// Ham4Parser.g:3683:5: ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked )
root_0 = this.adaptor.nil();
set408=this.input.LT(1);
if ( (this.input.LA(1)>=HamFingerstraightmod && this.input.LA(1)<=HamFingerhookedmod)||(this.input.LA(1)>=HamDoublebent && this.input.LA(1)<=HamDoublehooked) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set408));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerbendingtok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerbending_return: (function() {
Ham4Parser.fingerbending_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerbending_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3691:1: fingerbending : fingerbendingtok -> ^( FIBENDING fingerbendingtok ) ;
// $ANTLR start "fingerbending"
fingerbending: function() {
var retval = new Ham4Parser.fingerbending_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingerbendingtok409 = null;
var stream_fingerbendingtok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerbendingtok");
try {
// Ham4Parser.g:3692:2: ( fingerbendingtok -> ^( FIBENDING fingerbendingtok ) )
// Ham4Parser.g:3692:4: fingerbendingtok
this.pushFollow(Ham4Parser.FOLLOW_fingerbendingtok_in_fingerbending14085);
fingerbendingtok409=this.fingerbendingtok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerbendingtok.add(fingerbendingtok409.getTree());
// AST REWRITE
// elements: fingerbendingtok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3693:4: -> ^( FIBENDING fingerbendingtok )
{
// Ham4Parser.g:3693:7: ^( FIBENDING fingerbendingtok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FIBENDING, "FIBENDING"), root_1);
this.adaptor.addChild(root_1, stream_fingerbendingtok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbpostok_return: (function() {
Ham4Parser.thumbpostok_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbpostok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3696:1: thumbpostok : ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ;
// $ANTLR start "thumbpostok"
thumbpostok: function() {
var retval = new Ham4Parser.thumbpostok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set410 = null;
var set410_tree=null;
this.trace("ANTLR Parse: thumbpostok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3714:5: ( ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) )
// Ham4Parser.g:3715:5: ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod )
root_0 = this.adaptor.nil();
set410=this.input.LT(1);
if ( (this.input.LA(1)>=HamThumboutmod && this.input.LA(1)<=HamThumbacrossmod)||this.input.LA(1)==HamThumbopenmod ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set410));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbpostok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbpos_return: (function() {
Ham4Parser.thumbpos_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbpos_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3721:1: thumbpos : thumbpostok -> ^( THUMBPOS thumbpostok ) ;
// $ANTLR start "thumbpos"
thumbpos: function() {
var retval = new Ham4Parser.thumbpos_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbpostok411 = null;
var stream_thumbpostok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbpostok");
try {
// Ham4Parser.g:3722:2: ( thumbpostok -> ^( THUMBPOS thumbpostok ) )
// Ham4Parser.g:3722:4: thumbpostok
this.pushFollow(Ham4Parser.FOLLOW_thumbpostok_in_thumbpos14171);
thumbpostok411=this.thumbpostok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbpostok.add(thumbpostok411.getTree());
// AST REWRITE
// elements: thumbpostok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3723:4: -> ^( THUMBPOS thumbpostok )
{
// Ham4Parser.g:3723:7: ^( THUMBPOS thumbpostok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THUMBPOS, "THUMBPOS"), root_1);
this.adaptor.addChild(root_1, stream_thumbpostok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumb_return: (function() {
Ham4Parser.thumb_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumb_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3726:1: thumb : HamThumb ;
// $ANTLR start "thumb"
thumb: function() {
var retval = new Ham4Parser.thumb_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamThumb412 = null;
var HamThumb412_tree=null;
this.trace("ANTLR Parse: thumb starts "+this.state.backtracking);
try {
// Ham4Parser.g:3740:5: ( HamThumb )
// Ham4Parser.g:3740:9: HamThumb
root_0 = this.adaptor.nil();
HamThumb412=this.match(this.input,HamThumb,Ham4Parser.FOLLOW_HamThumb_in_thumb14211); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamThumb412_tree = this.adaptor.create(HamThumb412);
this.adaptor.addChild(root_0, HamThumb412_tree);
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumb finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
finger_return: (function() {
Ham4Parser.finger_return = function(){};
org.antlr.lang.extend(Ham4Parser.finger_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3743:1: finger : ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky );
// $ANTLR start "finger"
finger: function() {
var retval = new Ham4Parser.finger_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set413 = null;
var set413_tree=null;
this.trace("ANTLR Parse: finger starts "+this.state.backtracking);
try {
// Ham4Parser.g:3760:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set413=this.input.LT(1);
if ( (this.input.LA(1)>=HamIndexfinger && this.input.LA(1)<=HamPinky) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set413));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: finger finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerpart_return: (function() {
Ham4Parser.fingerpart_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerpart_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3766:1: fingerpart : ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside );
// $ANTLR start "fingerpart"
fingerpart: function() {
var retval = new Ham4Parser.fingerpart_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set414 = null;
var set414_tree=null;
this.trace("ANTLR Parse: fingerpart starts "+this.state.backtracking);
try {
// Ham4Parser.g:3785:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set414=this.input.LT(1);
if ( (this.input.LA(1)>=HamFingertip && this.input.LA(1)<=HamFingerside) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set414));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerpart finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidirtok_return: (function() {
Ham4Parser.extfidirtok_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidirtok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3793:1: extfidirtok : ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) ) ;
// $ANTLR start "extfidirtok"
extfidirtok: function() {
var retval = new Ham4Parser.extfidirtok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamExtfingeru415 = null;
var HamExtfingerur416 = null;
var HamExtfingerr417 = null;
var HamExtfingerdr418 = null;
var HamExtfingerd419 = null;
var HamExtfingerdl420 = null;
var HamExtfingerl421 = null;
var HamExtfingerul422 = null;
var HamExtfingerol423 = null;
var set424 = null;
var HamExtfingero425 = null;
var HamExtfingeror426 = null;
var set427 = null;
var HamExtfingeril428 = null;
var set429 = null;
var HamExtfingeri430 = null;
var HamExtfingerir431 = null;
var set432 = null;
var HamExtfingerui433 = null;
var set434 = null;
var HamExtfingerdi435 = null;
var set436 = null;
var HamExtfingerdo437 = null;
var set438 = null;
var HamExtfingeruo439 = null;
var set440 = null;
var HamExtfingeru415_tree=null;
var HamExtfingerur416_tree=null;
var HamExtfingerr417_tree=null;
var HamExtfingerdr418_tree=null;
var HamExtfingerd419_tree=null;
var HamExtfingerdl420_tree=null;
var HamExtfingerl421_tree=null;
var HamExtfingerul422_tree=null;
var HamExtfingerol423_tree=null;
var set424_tree=null;
var HamExtfingero425_tree=null;
var HamExtfingeror426_tree=null;
var set427_tree=null;
var HamExtfingeril428_tree=null;
var set429_tree=null;
var HamExtfingeri430_tree=null;
var HamExtfingerir431_tree=null;
var set432_tree=null;
var HamExtfingerui433_tree=null;
var set434_tree=null;
var HamExtfingerdi435_tree=null;
var set436_tree=null;
var HamExtfingerdo437_tree=null;
var set438_tree=null;
var HamExtfingeruo439_tree=null;
var set440_tree=null;
this.trace("ANTLR Parse: extfidirtok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3874:5: ( ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) ) )
// Ham4Parser.g:3875:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3875:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )
var alt171=18;
alt171 = this.dfa171.predict(this.input);
switch (alt171) {
case 1 :
// Ham4Parser.g:3875:9: HamExtfingeru
HamExtfingeru415=this.match(this.input,HamExtfingeru,Ham4Parser.FOLLOW_HamExtfingeru_in_extfidirtok14384); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeru415_tree = this.adaptor.create(HamExtfingeru415);
this.adaptor.addChild(root_0, HamExtfingeru415_tree);
}
break;
case 2 :
// Ham4Parser.g:3876:9: HamExtfingerur
HamExtfingerur416=this.match(this.input,HamExtfingerur,Ham4Parser.FOLLOW_HamExtfingerur_in_extfidirtok14394); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerur416_tree = this.adaptor.create(HamExtfingerur416);
this.adaptor.addChild(root_0, HamExtfingerur416_tree);
}
break;
case 3 :
// Ham4Parser.g:3877:9: HamExtfingerr
HamExtfingerr417=this.match(this.input,HamExtfingerr,Ham4Parser.FOLLOW_HamExtfingerr_in_extfidirtok14404); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerr417_tree = this.adaptor.create(HamExtfingerr417);
this.adaptor.addChild(root_0, HamExtfingerr417_tree);
}
break;
case 4 :
// Ham4Parser.g:3878:9: HamExtfingerdr
HamExtfingerdr418=this.match(this.input,HamExtfingerdr,Ham4Parser.FOLLOW_HamExtfingerdr_in_extfidirtok14414); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdr418_tree = this.adaptor.create(HamExtfingerdr418);
this.adaptor.addChild(root_0, HamExtfingerdr418_tree);
}
break;
case 5 :
// Ham4Parser.g:3879:9: HamExtfingerd
HamExtfingerd419=this.match(this.input,HamExtfingerd,Ham4Parser.FOLLOW_HamExtfingerd_in_extfidirtok14424); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerd419_tree = this.adaptor.create(HamExtfingerd419);
this.adaptor.addChild(root_0, HamExtfingerd419_tree);
}
break;
case 6 :
// Ham4Parser.g:3880:9: HamExtfingerdl
HamExtfingerdl420=this.match(this.input,HamExtfingerdl,Ham4Parser.FOLLOW_HamExtfingerdl_in_extfidirtok14434); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdl420_tree = this.adaptor.create(HamExtfingerdl420);
this.adaptor.addChild(root_0, HamExtfingerdl420_tree);
}
break;
case 7 :
// Ham4Parser.g:3881:9: HamExtfingerl
HamExtfingerl421=this.match(this.input,HamExtfingerl,Ham4Parser.FOLLOW_HamExtfingerl_in_extfidirtok14444); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerl421_tree = this.adaptor.create(HamExtfingerl421);
this.adaptor.addChild(root_0, HamExtfingerl421_tree);
}
break;
case 8 :
// Ham4Parser.g:3882:9: HamExtfingerul
HamExtfingerul422=this.match(this.input,HamExtfingerul,Ham4Parser.FOLLOW_HamExtfingerul_in_extfidirtok14454); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerul422_tree = this.adaptor.create(HamExtfingerul422);
this.adaptor.addChild(root_0, HamExtfingerul422_tree);
}
break;
case 9 :
// Ham4Parser.g:3883:9: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3883:9: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3884:13: HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )?
HamExtfingerol423=this.match(this.input,HamExtfingerol,Ham4Parser.FOLLOW_HamExtfingerol_in_extfidirtok14478); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerol423_tree = this.adaptor.create(HamExtfingerol423);
this.adaptor.addChild(root_0, HamExtfingerol423_tree);
}
// Ham4Parser.g:3885:13: ( HamExtfingeruo | HamExtfingerdo )?
var alt163=2;
var LA163_0 = this.input.LA(1);
if ( ((LA163_0>=HamExtfingerdo && LA163_0<=HamExtfingeruo)) ) {
alt163=1;
}
switch (alt163) {
case 1 :
// Ham4Parser.g:
set424=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerdo && this.input.LA(1)<=HamExtfingeruo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set424));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 10 :
// Ham4Parser.g:3890:9: HamExtfingero
HamExtfingero425=this.match(this.input,HamExtfingero,Ham4Parser.FOLLOW_HamExtfingero_in_extfidirtok14563); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingero425_tree = this.adaptor.create(HamExtfingero425);
this.adaptor.addChild(root_0, HamExtfingero425_tree);
}
break;
case 11 :
// Ham4Parser.g:3891:9: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3891:9: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3892:13: HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )?
HamExtfingeror426=this.match(this.input,HamExtfingeror,Ham4Parser.FOLLOW_HamExtfingeror_in_extfidirtok14587); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeror426_tree = this.adaptor.create(HamExtfingeror426);
this.adaptor.addChild(root_0, HamExtfingeror426_tree);
}
// Ham4Parser.g:3893:13: ( HamExtfingeruo | HamExtfingerdo )?
var alt164=2;
var LA164_0 = this.input.LA(1);
if ( ((LA164_0>=HamExtfingerdo && LA164_0<=HamExtfingeruo)) ) {
alt164=1;
}
switch (alt164) {
case 1 :
// Ham4Parser.g:
set427=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerdo && this.input.LA(1)<=HamExtfingeruo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set427));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 12 :
// Ham4Parser.g:3898:9: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3898:9: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3899:13: HamExtfingeril ( HamExtfingerui | HamExtfingerdi )?
HamExtfingeril428=this.match(this.input,HamExtfingeril,Ham4Parser.FOLLOW_HamExtfingeril_in_extfidirtok14686); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeril428_tree = this.adaptor.create(HamExtfingeril428);
this.adaptor.addChild(root_0, HamExtfingeril428_tree);
}
// Ham4Parser.g:3900:13: ( HamExtfingerui | HamExtfingerdi )?
var alt165=2;
var LA165_0 = this.input.LA(1);
if ( ((LA165_0>=HamExtfingerui && LA165_0<=HamExtfingerdi)) ) {
alt165=1;
}
switch (alt165) {
case 1 :
// Ham4Parser.g:
set429=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerui && this.input.LA(1)<=HamExtfingerdi) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set429));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 13 :
// Ham4Parser.g:3905:9: HamExtfingeri
HamExtfingeri430=this.match(this.input,HamExtfingeri,Ham4Parser.FOLLOW_HamExtfingeri_in_extfidirtok14771); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeri430_tree = this.adaptor.create(HamExtfingeri430);
this.adaptor.addChild(root_0, HamExtfingeri430_tree);
}
break;
case 14 :
// Ham4Parser.g:3906:9: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3906:9: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3907:13: HamExtfingerir ( HamExtfingerui | HamExtfingerdi )?
HamExtfingerir431=this.match(this.input,HamExtfingerir,Ham4Parser.FOLLOW_HamExtfingerir_in_extfidirtok14795); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerir431_tree = this.adaptor.create(HamExtfingerir431);
this.adaptor.addChild(root_0, HamExtfingerir431_tree);
}
// Ham4Parser.g:3908:13: ( HamExtfingerui | HamExtfingerdi )?
var alt166=2;
var LA166_0 = this.input.LA(1);
if ( ((LA166_0>=HamExtfingerui && LA166_0<=HamExtfingerdi)) ) {
alt166=1;
}
switch (alt166) {
case 1 :
// Ham4Parser.g:
set432=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerui && this.input.LA(1)<=HamExtfingerdi) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set432));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 15 :
// Ham4Parser.g:3913:9: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3913:9: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3914:13: HamExtfingerui ( HamExtfingeril | HamExtfingerir )?
HamExtfingerui433=this.match(this.input,HamExtfingerui,Ham4Parser.FOLLOW_HamExtfingerui_in_extfidirtok14894); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerui433_tree = this.adaptor.create(HamExtfingerui433);
this.adaptor.addChild(root_0, HamExtfingerui433_tree);
}
// Ham4Parser.g:3915:13: ( HamExtfingeril | HamExtfingerir )?
var alt167=2;
var LA167_0 = this.input.LA(1);
if ( (LA167_0==HamExtfingeril||LA167_0==HamExtfingerir) ) {
alt167=1;
}
switch (alt167) {
case 1 :
// Ham4Parser.g:
set434=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingeril||this.input.LA(1)==HamExtfingerir ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set434));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 16 :
// Ham4Parser.g:3920:9: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3920:9: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3921:13: HamExtfingerdi ( HamExtfingeril | HamExtfingerir )?
HamExtfingerdi435=this.match(this.input,HamExtfingerdi,Ham4Parser.FOLLOW_HamExtfingerdi_in_extfidirtok14993); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdi435_tree = this.adaptor.create(HamExtfingerdi435);
this.adaptor.addChild(root_0, HamExtfingerdi435_tree);
}
// Ham4Parser.g:3922:13: ( HamExtfingeril | HamExtfingerir )?
var alt168=2;
var LA168_0 = this.input.LA(1);
if ( (LA168_0==HamExtfingeril||LA168_0==HamExtfingerir) ) {
alt168=1;
}
switch (alt168) {
case 1 :
// Ham4Parser.g:
set436=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingeril||this.input.LA(1)==HamExtfingerir ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set436));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 17 :
// Ham4Parser.g:3927:9: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3927:9: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3928:13: HamExtfingerdo ( HamExtfingerol | HamExtfingeror )?
HamExtfingerdo437=this.match(this.input,HamExtfingerdo,Ham4Parser.FOLLOW_HamExtfingerdo_in_extfidirtok15092); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdo437_tree = this.adaptor.create(HamExtfingerdo437);
this.adaptor.addChild(root_0, HamExtfingerdo437_tree);
}
// Ham4Parser.g:3929:13: ( HamExtfingerol | HamExtfingeror )?
var alt169=2;
var LA169_0 = this.input.LA(1);
if ( (LA169_0==HamExtfingerol||LA169_0==HamExtfingeror) ) {
alt169=1;
}
switch (alt169) {
case 1 :
// Ham4Parser.g:
set438=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingerol||this.input.LA(1)==HamExtfingeror ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set438));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 18 :
// Ham4Parser.g:3934:9: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3934:9: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3935:13: HamExtfingeruo ( HamExtfingerol | HamExtfingeror )?
HamExtfingeruo439=this.match(this.input,HamExtfingeruo,Ham4Parser.FOLLOW_HamExtfingeruo_in_extfidirtok15191); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeruo439_tree = this.adaptor.create(HamExtfingeruo439);
this.adaptor.addChild(root_0, HamExtfingeruo439_tree);
}
// Ham4Parser.g:3936:13: ( HamExtfingerol | HamExtfingeror )?
var alt170=2;
var LA170_0 = this.input.LA(1);
if ( (LA170_0==HamExtfingerol||LA170_0==HamExtfingeror) ) {
alt170=1;
}
switch (alt170) {
case 1 :
// Ham4Parser.g:
set440=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingerol||this.input.LA(1)==HamExtfingeror ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set440));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidirtok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir_return: (function() {
Ham4Parser.extfidir_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3944:1: extfidir : extfidirtok -> ^( EXTFIDIR extfidirtok ) ;
// $ANTLR start "extfidir"
extfidir: function() {
var retval = new Ham4Parser.extfidir_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidirtok441 = null;
var stream_extfidirtok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidirtok");
try {
// Ham4Parser.g:3945:2: ( extfidirtok -> ^( EXTFIDIR extfidirtok ) )
// Ham4Parser.g:3945:4: extfidirtok
this.pushFollow(Ham4Parser.FOLLOW_extfidirtok_in_extfidir15286);
extfidirtok441=this.extfidirtok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidirtok.add(extfidirtok441.getTree());
// AST REWRITE
// elements: extfidirtok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3946:2: -> ^( EXTFIDIR extfidirtok )
{
// Ham4Parser.g:3946:5: ^( EXTFIDIR extfidirtok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR, "EXTFIDIR"), root_1);
this.adaptor.addChild(root_1, stream_extfidirtok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor_return: (function() {
Ham4Parser.palmor_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3949:1: palmor : ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul );
// $ANTLR start "palmor"
palmor: function() {
var retval = new Ham4Parser.palmor_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set442 = null;
var set442_tree=null;
this.trace("ANTLR Parse: palmor starts "+this.state.backtracking);
try {
// Ham4Parser.g:3970:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set442=this.input.LT(1);
if ( (this.input.LA(1)>=HamPalmu && this.input.LA(1)<=HamPalmul) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set442));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locarm_return: (function() {
Ham4Parser.locarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3983:1: locarm : ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm );
// $ANTLR start "locarm"
locarm: function() {
var retval = new Ham4Parser.locarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set443 = null;
var set443_tree=null;
this.trace("ANTLR Parse: locarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:4000:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set443=this.input.LT(1);
if ( (this.input.LA(1)>=HamUpperarm && this.input.LA(1)<=HamLowerarm) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set443));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locbodytok_return: (function() {
Ham4Parser.locbodytok_return = function(){};
org.antlr.lang.extend(Ham4Parser.locbodytok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4006:1: locbodytok : ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ;
// $ANTLR start "locbodytok"
locbodytok: function() {
var retval = new Ham4Parser.locbodytok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamHead444 = null;
var HamHeadtop445 = null;
var HamForehead446 = null;
var HamEyebrows447 = null;
var HamNose448 = null;
var HamNostrils449 = null;
var HamTongue450 = null;
var set451 = null;
var set452 = null;
var HamChin453 = null;
var HamUnderchin454 = null;
var HamNeck455 = null;
var HamShouldertop456 = null;
var HamShoulders457 = null;
var HamChest458 = null;
var HamStomach459 = null;
var HamBelowstomach460 = null;
var HamHead444_tree=null;
var HamHeadtop445_tree=null;
var HamForehead446_tree=null;
var HamEyebrows447_tree=null;
var HamNose448_tree=null;
var HamNostrils449_tree=null;
var HamTongue450_tree=null;
var set451_tree=null;
var set452_tree=null;
var HamChin453_tree=null;
var HamUnderchin454_tree=null;
var HamNeck455_tree=null;
var HamShouldertop456_tree=null;
var HamShoulders457_tree=null;
var HamChest458_tree=null;
var HamStomach459_tree=null;
var HamBelowstomach460_tree=null;
this.trace("ANTLR Parse: locbodytok starts "+this.state.backtracking);
try {
// Ham4Parser.g:4047:5: ( ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) )
// Ham4Parser.g:4048:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
root_0 = this.adaptor.nil();
// Ham4Parser.g:4048:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
var alt173=16;
alt173 = this.dfa173.predict(this.input);
switch (alt173) {
case 1 :
// Ham4Parser.g:4048:9: HamHead
HamHead444=this.match(this.input,HamHead,Ham4Parser.FOLLOW_HamHead_in_locbodytok15488); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamHead444_tree = this.adaptor.create(HamHead444);
this.adaptor.addChild(root_0, HamHead444_tree);
}
break;
case 2 :
// Ham4Parser.g:4049:9: HamHeadtop
HamHeadtop445=this.match(this.input,HamHeadtop,Ham4Parser.FOLLOW_HamHeadtop_in_locbodytok15498); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamHeadtop445_tree = this.adaptor.create(HamHeadtop445);
this.adaptor.addChild(root_0, HamHeadtop445_tree);
}
break;
case 3 :
// Ham4Parser.g:4050:9: HamForehead
HamForehead446=this.match(this.input,HamForehead,Ham4Parser.FOLLOW_HamForehead_in_locbodytok15508); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamForehead446_tree = this.adaptor.create(HamForehead446);
this.adaptor.addChild(root_0, HamForehead446_tree);
}
break;
case 4 :
// Ham4Parser.g:4051:9: HamEyebrows
HamEyebrows447=this.match(this.input,HamEyebrows,Ham4Parser.FOLLOW_HamEyebrows_in_locbodytok15518); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamEyebrows447_tree = this.adaptor.create(HamEyebrows447);
this.adaptor.addChild(root_0, HamEyebrows447_tree);
}
break;
case 5 :
// Ham4Parser.g:4052:9: HamNose
HamNose448=this.match(this.input,HamNose,Ham4Parser.FOLLOW_HamNose_in_locbodytok15528); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNose448_tree = this.adaptor.create(HamNose448);
this.adaptor.addChild(root_0, HamNose448_tree);
}
break;
case 6 :
// Ham4Parser.g:4053:9: HamNostrils
HamNostrils449=this.match(this.input,HamNostrils,Ham4Parser.FOLLOW_HamNostrils_in_locbodytok15538); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNostrils449_tree = this.adaptor.create(HamNostrils449);
this.adaptor.addChild(root_0, HamNostrils449_tree);
}
break;
case 7 :
// Ham4Parser.g:4054:9: HamTongue
HamTongue450=this.match(this.input,HamTongue,Ham4Parser.FOLLOW_HamTongue_in_locbodytok15548); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamTongue450_tree = this.adaptor.create(HamTongue450);
this.adaptor.addChild(root_0, HamTongue450_tree);
}
break;
case 8 :
// Ham4Parser.g:4055:9: ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? )
// Ham4Parser.g:4055:9: ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? )
// Ham4Parser.g:4056:13: ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )?
set451=this.input.LT(1);
if ( this.input.LA(1)==HamTeeth||this.input.LA(1)==HamEyes||this.input.LA(1)==HamLips ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set451));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:4061:13: ( HamDoublebent | HamDoublehooked )?
var alt172=2;
var LA172_0 = this.input.LA(1);
if ( ((LA172_0>=HamDoublebent && LA172_0<=HamDoublehooked)) ) {
alt172=1;
}
switch (alt172) {
case 1 :
// Ham4Parser.g:
set452=this.input.LT(1);
if ( (this.input.LA(1)>=HamDoublebent && this.input.LA(1)<=HamDoublehooked) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set452));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 9 :
// Ham4Parser.g:4066:9: HamChin
HamChin453=this.match(this.input,HamChin,Ham4Parser.FOLLOW_HamChin_in_locbodytok15725); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamChin453_tree = this.adaptor.create(HamChin453);
this.adaptor.addChild(root_0, HamChin453_tree);
}
break;
case 10 :
// Ham4Parser.g:4067:9: HamUnderchin
HamUnderchin454=this.match(this.input,HamUnderchin,Ham4Parser.FOLLOW_HamUnderchin_in_locbodytok15735); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamUnderchin454_tree = this.adaptor.create(HamUnderchin454);
this.adaptor.addChild(root_0, HamUnderchin454_tree);
}
break;
case 11 :
// Ham4Parser.g:4068:9: HamNeck
HamNeck455=this.match(this.input,HamNeck,Ham4Parser.FOLLOW_HamNeck_in_locbodytok15745); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNeck455_tree = this.adaptor.create(HamNeck455);
this.adaptor.addChild(root_0, HamNeck455_tree);
}
break;
case 12 :
// Ham4Parser.g:4069:9: HamShouldertop
HamShouldertop456=this.match(this.input,HamShouldertop,Ham4Parser.FOLLOW_HamShouldertop_in_locbodytok15755); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamShouldertop456_tree = this.adaptor.create(HamShouldertop456);
this.adaptor.addChild(root_0, HamShouldertop456_tree);
}
break;
case 13 :
// Ham4Parser.g:4070:9: HamShoulders
HamShoulders457=this.match(this.input,HamShoulders,Ham4Parser.FOLLOW_HamShoulders_in_locbodytok15765); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamShoulders457_tree = this.adaptor.create(HamShoulders457);
this.adaptor.addChild(root_0, HamShoulders457_tree);
}
break;
case 14 :
// Ham4Parser.g:4071:9: HamChest
HamChest458=this.match(this.input,HamChest,Ham4Parser.FOLLOW_HamChest_in_locbodytok15775); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamChest458_tree = this.adaptor.create(HamChest458);
this.adaptor.addChild(root_0, HamChest458_tree);
}
break;
case 15 :
// Ham4Parser.g:4072:9: HamStomach
HamStomach459=this.match(this.input,HamStomach,Ham4Parser.FOLLOW_HamStomach_in_locbodytok15785); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamStomach459_tree = this.adaptor.create(HamStomach459);
this.adaptor.addChild(root_0, HamStomach459_tree);
}
break;
case 16 :
// Ham4Parser.g:4073:9: HamBelowstomach
HamBelowstomach460=this.match(this.input,HamBelowstomach,Ham4Parser.FOLLOW_HamBelowstomach_in_locbodytok15795); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamBelowstomach460_tree = this.adaptor.create(HamBelowstomach460);
this.adaptor.addChild(root_0, HamBelowstomach460_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locbodytok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locbody_return: (function() {
Ham4Parser.locbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.locbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4077:1: locbody : locbodytok -> ^( LOCBODY locbodytok ) ;
// $ANTLR start "locbody"
locbody: function() {
var retval = new Ham4Parser.locbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var locbodytok461 = null;
var stream_locbodytok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locbodytok");
try {
// Ham4Parser.g:4078:2: ( locbodytok -> ^( LOCBODY locbodytok ) )
// Ham4Parser.g:4078:4: locbodytok
this.pushFollow(Ham4Parser.FOLLOW_locbodytok_in_locbody15815);
locbodytok461=this.locbodytok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbodytok.add(locbodytok461.getTree());
// AST REWRITE
// elements: locbodytok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 4079:4: -> ^( LOCBODY locbodytok )
{
// Ham4Parser.g:4079:7: ^( LOCBODY locbodytok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCBODY, "LOCBODY"), root_1);
this.adaptor.addChild(root_1, stream_locbodytok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locsided_return: (function() {
Ham4Parser.locsided_return = function(){};
org.antlr.lang.extend(Ham4Parser.locsided_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4082:1: locsided : ( HamEar | HamEarlobe | HamCheek );
// $ANTLR start "locsided"
locsided: function() {
var retval = new Ham4Parser.locsided_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set462 = null;
var set462_tree=null;
this.trace("ANTLR Parse: locsided starts "+this.state.backtracking);
try {
// Ham4Parser.g:4098:5: ( HamEar | HamEarlobe | HamCheek )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set462=this.input.LT(1);
if ( this.input.LA(1)==HamEarlobe||(this.input.LA(1)>=HamEar && this.input.LA(1)<=HamCheek) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set462));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locsided finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handpart_return: (function() {
Ham4Parser.handpart_return = function(){};
org.antlr.lang.extend(Ham4Parser.handpart_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4103:1: handpart : ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside );
// $ANTLR start "handpart"
handpart: function() {
var retval = new Ham4Parser.handpart_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set463 = null;
var set463_tree=null;
this.trace("ANTLR Parse: handpart starts "+this.state.backtracking);
try {
// Ham4Parser.g:4123:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set463=this.input.LT(1);
if ( (this.input.LA(1)>=HamWristback && this.input.LA(1)<=HamHandback)||(this.input.LA(1)>=HamThumbside && this.input.LA(1)<=HamPinkyside) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set463));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handpart finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
side_return: (function() {
Ham4Parser.side_return = function(){};
org.antlr.lang.extend(Ham4Parser.side_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4132:1: side : ( HamLrbeside | HamLrat );
// $ANTLR start "side"
side: function() {
var retval = new Ham4Parser.side_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set464 = null;
var set464_tree=null;
this.trace("ANTLR Parse: side starts "+this.state.backtracking);
try {
// Ham4Parser.g:4147:5: ( HamLrbeside | HamLrat )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set464=this.input.LT(1);
if ( (this.input.LA(1)>=HamLrbeside && this.input.LA(1)<=HamLrat) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set464));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: side finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
dorsalorpalmar_return: (function() {
Ham4Parser.dorsalorpalmar_return = function(){};
org.antlr.lang.extend(Ham4Parser.dorsalorpalmar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4151:1: dorsalorpalmar : ( HamHandback | HamPalm );
// $ANTLR start "dorsalorpalmar"
dorsalorpalmar: function() {
var retval = new Ham4Parser.dorsalorpalmar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set465 = null;
var set465_tree=null;
this.trace("ANTLR Parse: dorsalorpalmar starts "+this.state.backtracking);
try {
// Ham4Parser.g:4166:5: ( HamHandback | HamPalm )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set465=this.input.LT(1);
if ( (this.input.LA(1)>=HamPalm && this.input.LA(1)<=HamHandback) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set465));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: dorsalorpalmar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
pcontact_return: (function() {
Ham4Parser.pcontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.pcontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4170:1: pcontact : ( HamTouch | HamClose );
// $ANTLR start "pcontact"
pcontact: function() {
var retval = new Ham4Parser.pcontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set466 = null;
var set466_tree=null;
this.trace("ANTLR Parse: pcontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:4185:5: ( HamTouch | HamClose )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set466=this.input.LT(1);
if ( (this.input.LA(1)>=HamClose && this.input.LA(1)<=HamTouch) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set466));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: pcontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ccontact_return: (function() {
Ham4Parser.ccontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.ccontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4189:1: ccontact : ( HamInterlock | HamCross );
// $ANTLR start "ccontact"
ccontact: function() {
var retval = new Ham4Parser.ccontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set467 = null;
var set467_tree=null;
this.trace("ANTLR Parse: ccontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:4204:5: ( HamInterlock | HamCross )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set467=this.input.LT(1);
if ( (this.input.LA(1)>=HamInterlock && this.input.LA(1)<=HamCross) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set467));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ccontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sizechange_return: (function() {
Ham4Parser.sizechange_return = function(){};
org.antlr.lang.extend(Ham4Parser.sizechange_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4211:1: sizechange : ( HamIncreasing | HamDecreasing );
// $ANTLR start "sizechange"
sizechange: function() {
var retval = new Ham4Parser.sizechange_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set468 = null;
var set468_tree=null;
this.trace("ANTLR Parse: sizechange starts "+this.state.backtracking);
try {
// Ham4Parser.g:4226:5: ( HamIncreasing | HamDecreasing )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set468=this.input.LT(1);
if ( (this.input.LA(1)>=HamIncreasing && this.input.LA(1)<=HamDecreasing) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set468));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sizechange finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetition_return: (function() {
Ham4Parser.repetition_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetition_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4230:1: repetition : ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse );
// $ANTLR start "repetition"
repetition: function() {
var retval = new Ham4Parser.repetition_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set469 = null;
var set469_tree=null;
this.trace("ANTLR Parse: repetition starts "+this.state.backtracking);
try {
// Ham4Parser.g:4248:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set469=this.input.LT(1);
if ( (this.input.LA(1)>=HamRepeatfromstart && this.input.LA(1)<=HamRepeatcontinueseveral)||this.input.LA(1)==HamRepeatreverse ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set469));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetition finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementarrow_return: (function() {
Ham4Parser.movementarrow_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementarrow_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4255:1: movementarrow : ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo );
// $ANTLR start "movementarrow"
movementarrow: function() {
var retval = new Ham4Parser.movementarrow_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set470 = null;
var set470_tree=null;
this.trace("ANTLR Parse: movementarrow starts "+this.state.backtracking);
try {
// Ham4Parser.g:4286:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set470=this.input.LT(1);
if ( (this.input.LA(1)>=HamMoveu && this.input.LA(1)<=HamMoveuo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set470));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementarrow finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementcross_return: (function() {
Ham4Parser.movementcross_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementcross_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4306:1: movementcross : ( HamMovecross | HamMovex );
// $ANTLR start "movementcross"
movementcross: function() {
var retval = new Ham4Parser.movementcross_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set471 = null;
var set471_tree=null;
this.trace("ANTLR Parse: movementcross starts "+this.state.backtracking);
try {
// Ham4Parser.g:4321:5: ( HamMovecross | HamMovex )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set471=this.input.LT(1);
if ( (this.input.LA(1)>=HamMovecross && this.input.LA(1)<=HamMovex) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set471));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementcross finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
wristmovement_return: (function() {
Ham4Parser.wristmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.wristmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4325:1: wristmovement : ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw );
// $ANTLR start "wristmovement"
wristmovement: function() {
var retval = new Ham4Parser.wristmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set472 = null;
var set472_tree=null;
this.trace("ANTLR Parse: wristmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:4343:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set472=this.input.LT(1);
if ( (this.input.LA(1)>=HamNodding && this.input.LA(1)<=HamStirccw) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set472));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: wristmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementcircle_return: (function() {
Ham4Parser.movementcircle_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementcircle_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4350:1: movementcircle : ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo );
// $ANTLR start "movementcircle"
movementcircle: function() {
var retval = new Ham4Parser.movementcircle_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set473 = null;
var set473_tree=null;
this.trace("ANTLR Parse: movementcircle starts "+this.state.backtracking);
try {
// Ham4Parser.g:4381:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set473=this.input.LT(1);
if ( (this.input.LA(1)>=HamCircleo && this.input.LA(1)<=HamCircler)||(this.input.LA(1)>=HamCircleul && this.input.LA(1)<=HamCircleuo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set473));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementcircle finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ellipsedirection_return: (function() {
Ham4Parser.ellipsedirection_return = function(){};
org.antlr.lang.extend(Ham4Parser.ellipsedirection_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4401:1: ellipsedirection : ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul );
// $ANTLR start "ellipsedirection"
ellipsedirection: function() {
var retval = new Ham4Parser.ellipsedirection_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set474 = null;
var set474_tree=null;
this.trace("ANTLR Parse: ellipsedirection starts "+this.state.backtracking);
try {
// Ham4Parser.g:4418:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set474=this.input.LT(1);
if ( (this.input.LA(1)>=HamEllipseh && this.input.LA(1)<=HamEllipseul) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set474));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ellipsedirection finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
clock_return: (function() {
Ham4Parser.clock_return = function(){};
org.antlr.lang.extend(Ham4Parser.clock_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4424:1: clock : ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur );
// $ANTLR start "clock"
clock: function() {
var retval = new Ham4Parser.clock_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set475 = null;
var set475_tree=null;
this.trace("ANTLR Parse: clock starts "+this.state.backtracking);
try {
// Ham4Parser.g:4445:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set475=this.input.LT(1);
if ( (this.input.LA(1)>=HamClocku && this.input.LA(1)<=HamClockur) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set475));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: clock finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
modifier_return: (function() {
Ham4Parser.modifier_return = function(){};
org.antlr.lang.extend(Ham4Parser.modifier_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4455:1: modifier : ( HamFast | HamSlow | HamTense | HamRest | HamHalt );
// $ANTLR start "modifier"
modifier: function() {
var retval = new Ham4Parser.modifier_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set476 = null;
var set476_tree=null;
this.trace("ANTLR Parse: modifier starts "+this.state.backtracking);
try {
// Ham4Parser.g:4473:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set476=this.input.LT(1);
if ( (this.input.LA(1)>=HamFast && this.input.LA(1)<=HamHalt) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set476));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: modifier finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
arc_return: (function() {
Ham4Parser.arc_return = function(){};
org.antlr.lang.extend(Ham4Parser.arc_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4480:1: arc : ( HamArcl | HamArcu | HamArcr | HamArcd );
// $ANTLR start "arc"
arc: function() {
var retval = new Ham4Parser.arc_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set477 = null;
var set477_tree=null;
this.trace("ANTLR Parse: arc starts "+this.state.backtracking);
try {
// Ham4Parser.g:4497:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set477=this.input.LT(1);
if ( (this.input.LA(1)>=HamArcl && this.input.LA(1)<=HamArcd) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set477));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: arc finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
size_return: (function() {
Ham4Parser.size_return = function(){};
org.antlr.lang.extend(Ham4Parser.size_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4503:1: size : ( HamSmallmod | HamLargemod );
// $ANTLR start "size"
size: function() {
var retval = new Ham4Parser.size_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set478 = null;
var set478_tree=null;
this.trace("ANTLR Parse: size starts "+this.state.backtracking);
try {
// Ham4Parser.g:4518:5: ( HamSmallmod | HamLargemod )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set478=this.input.LT(1);
if ( (this.input.LA(1)>=HamSmallmod && this.input.LA(1)<=HamLargemod) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set478));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: size finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// $ANTLR start "synpred1_Ham4Parser"
synpred1_Ham4Parser_fragment: function() {
// Ham4Parser.g:253:9: ( HamNondominant initialconfig1 )
// Ham4Parser.g:253:11: HamNondominant initialconfig1
this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_synpred1_Ham4Parser928); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_synpred1_Ham4Parser930);
this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred1_Ham4Parser",
// $ANTLR start "synpred2_Ham4Parser"
synpred2_Ham4Parser_fragment: function() {
// Ham4Parser.g:322:9: ( HamNomotion HamNondominant initialconfig1 )
// Ham4Parser.g:322:11: HamNomotion HamNondominant initialconfig1
this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_synpred2_Ham4Parser1112); if (this.state.failed) return ;
this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_synpred2_Ham4Parser1114); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_synpred2_Ham4Parser1116);
this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred2_Ham4Parser",
// $ANTLR start "synpred3_Ham4Parser"
synpred3_Ham4Parser_fragment: function() {
// Ham4Parser.g:504:11: ( levelbody )
// Ham4Parser.g:504:13: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred3_Ham4Parser1806);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred3_Ham4Parser",
// $ANTLR start "synpred4_Ham4Parser"
synpred4_Ham4Parser_fragment: function() {
// Ham4Parser.g:561:9: ( handconfig2 )
// Ham4Parser.g:561:11: handconfig2
this.pushFollow(Ham4Parser.FOLLOW_handconfig2_in_synpred4_Ham4Parser1943);
this.handconfig2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred4_Ham4Parser",
// $ANTLR start "synpred5_Ham4Parser"
synpred5_Ham4Parser_fragment: function() {
// Ham4Parser.g:565:13: ( location2 )
// Ham4Parser.g:565:15: location2
this.pushFollow(Ham4Parser.FOLLOW_location2_in_synpred5_Ham4Parser1991);
this.location2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred5_Ham4Parser",
// $ANTLR start "synpred6_Ham4Parser"
synpred6_Ham4Parser_fragment: function() {
// Ham4Parser.g:574:13: ( HamPlus )
// Ham4Parser.g:574:15: HamPlus
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred6_Ham4Parser2101); if (this.state.failed) return ;
},
// $ANTLR end "synpred6_Ham4Parser",
// $ANTLR start "synpred7_Ham4Parser"
synpred7_Ham4Parser_fragment: function() {
// Ham4Parser.g:651:9: ( handshape2 ( HamParbegin )? extfidir1 )
// Ham4Parser.g:651:11: handshape2 ( HamParbegin )? extfidir1
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_synpred7_Ham4Parser2414);
this.handshape2();
this.state._fsp--;
if (this.state.failed) return ;
// Ham4Parser.g:651:22: ( HamParbegin )?
var alt174=2;
var LA174_0 = this.input.LA(1);
if ( (LA174_0==HamParbegin) ) {
alt174=1;
}
switch (alt174) {
case 1 :
// Ham4Parser.g:651:24: HamParbegin
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred7_Ham4Parser2418); if (this.state.failed) return ;
break;
}
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_synpred7_Ham4Parser2423);
this.extfidir1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred7_Ham4Parser",
// $ANTLR start "synpred8_Ham4Parser"
synpred8_Ham4Parser_fragment: function() {
// Ham4Parser.g:657:9: ( handshape2 )
// Ham4Parser.g:657:11: handshape2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_synpred8_Ham4Parser2488);
this.handshape2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred8_Ham4Parser",
// $ANTLR start "synpred9_Ham4Parser"
synpred9_Ham4Parser_fragment: function() {
// Ham4Parser.g:760:9: ( extfidir2 )
// Ham4Parser.g:760:11: extfidir2
this.pushFollow(Ham4Parser.FOLLOW_extfidir2_in_synpred9_Ham4Parser2805);
this.extfidir2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred9_Ham4Parser",
// $ANTLR start "synpred10_Ham4Parser"
synpred10_Ham4Parser_fragment: function() {
// Ham4Parser.g:869:13: ( ( hsfingeritem )+ HamBetween finger )
// Ham4Parser.g:869:15: ( hsfingeritem )+ HamBetween finger
// Ham4Parser.g:869:15: ( hsfingeritem )+
var cnt175=0;
loop175:
do {
var alt175=2;
var LA175_0 = this.input.LA(1);
if ( ((LA175_0>=HamIndexfinger && LA175_0<=HamPinky)) ) {
alt175=1;
}
switch (alt175) {
case 1 :
// Ham4Parser.g:869:17: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred10_Ham4Parser3168);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt175 >= 1 ) {
break loop175;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(175, this.input);
throw eee;
}
cnt175++;
} while (true);
this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_synpred10_Ham4Parser3173); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_finger_in_synpred10_Ham4Parser3175);
this.finger();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred10_Ham4Parser",
// $ANTLR start "synpred11_Ham4Parser"
synpred11_Ham4Parser_fragment: function() {
// Ham4Parser.g:877:13: ( ( hsdigit )* ( fingerbending | fingerpart ) )
// Ham4Parser.g:877:15: ( hsdigit )* ( fingerbending | fingerpart )
// Ham4Parser.g:877:15: ( hsdigit )*
loop176:
do {
var alt176=2;
var LA176_0 = this.input.LA(1);
if ( ((LA176_0>=HamThumb && LA176_0<=HamPinky)) ) {
alt176=1;
}
switch (alt176) {
case 1 :
// Ham4Parser.g:877:17: hsdigit
this.pushFollow(Ham4Parser.FOLLOW_hsdigit_in_synpred11_Ham4Parser3282);
this.hsdigit();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
break loop176;
}
} while (true);
// Ham4Parser.g:877:28: ( fingerbending | fingerpart )
var alt177=2;
var LA177_0 = this.input.LA(1);
if ( ((LA177_0>=HamFingerstraightmod && LA177_0<=HamFingerhookedmod)||(LA177_0>=HamDoublebent && LA177_0<=HamDoublehooked)) ) {
alt177=1;
}
else if ( ((LA177_0>=HamFingertip && LA177_0<=HamFingerside)) ) {
alt177=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 177, 0, this.input);
throw nvae;
}
switch (alt177) {
case 1 :
// Ham4Parser.g:877:30: fingerbending
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_synpred11_Ham4Parser3289);
this.fingerbending();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:877:46: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_synpred11_Ham4Parser3293);
this.fingerpart();
this.state._fsp--;
if (this.state.failed) return ;
break;
}
},
// $ANTLR end "synpred11_Ham4Parser",
// $ANTLR start "synpred12_Ham4Parser"
synpred12_Ham4Parser_fragment: function() {
// Ham4Parser.g:882:15: ( thumbspecial )
// Ham4Parser.g:882:17: thumbspecial
this.pushFollow(Ham4Parser.FOLLOW_thumbspecial_in_synpred12_Ham4Parser3371);
this.thumbspecial();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred12_Ham4Parser",
// $ANTLR start "synpred13_Ham4Parser"
synpred13_Ham4Parser_fragment: function() {
// Ham4Parser.g:885:13: ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )
// Ham4Parser.g:885:15: ( hsfingeritem )* ( thumbbetweendefault | thumbextra )
// Ham4Parser.g:885:15: ( hsfingeritem )*
loop178:
do {
var alt178=2;
var LA178_0 = this.input.LA(1);
if ( ((LA178_0>=HamIndexfinger && LA178_0<=HamPinky)) ) {
alt178=1;
}
switch (alt178) {
case 1 :
// Ham4Parser.g:885:17: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred13_Ham4Parser3415);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
break loop178;
}
} while (true);
// Ham4Parser.g:885:33: ( thumbbetweendefault | thumbextra )
var alt179=2;
var LA179_0 = this.input.LA(1);
if ( (LA179_0==HamBetween) ) {
alt179=1;
}
else if ( (LA179_0==HamThumb||(LA179_0>=HamFingertip && LA179_0<=HamFingerside)) ) {
alt179=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 179, 0, this.input);
throw nvae;
}
switch (alt179) {
case 1 :
// Ham4Parser.g:885:35: thumbbetweendefault
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_synpred13_Ham4Parser3422);
this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:885:57: thumbextra
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_synpred13_Ham4Parser3426);
this.thumbextra();
this.state._fsp--;
if (this.state.failed) return ;
break;
}
},
// $ANTLR end "synpred13_Ham4Parser",
// $ANTLR start "synpred14_Ham4Parser"
synpred14_Ham4Parser_fragment: function() {
// Ham4Parser.g:927:13: ( HamBetween handshapeclass )
// Ham4Parser.g:927:15: HamBetween handshapeclass
this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_synpred14_Ham4Parser3680); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_handshapeclass_in_synpred14_Ham4Parser3682);
this.handshapeclass();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred14_Ham4Parser",
// $ANTLR start "synpred15_Ham4Parser"
synpred15_Ham4Parser_fragment: function() {
// Ham4Parser.g:1036:13: ( hsfingeritem )
// Ham4Parser.g:1036:15: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred15_Ham4Parser4086);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred15_Ham4Parser",
// $ANTLR start "synpred16_Ham4Parser"
synpred16_Ham4Parser_fragment: function() {
// Ham4Parser.g:1084:13: ( hsfingeritem digit )
// Ham4Parser.g:1084:15: hsfingeritem digit
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred16_Ham4Parser4241);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_digit_in_synpred16_Ham4Parser4243);
this.digit();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred16_Ham4Parser",
// $ANTLR start "synpred17_Ham4Parser"
synpred17_Ham4Parser_fragment: function() {
// Ham4Parser.g:1132:13: ( fingershape )
// Ham4Parser.g:1132:15: fingershape
this.pushFollow(Ham4Parser.FOLLOW_fingershape_in_synpred17_Ham4Parser4401);
this.fingershape();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred17_Ham4Parser",
// $ANTLR start "synpred18_Ham4Parser"
synpred18_Ham4Parser_fragment: function() {
// Ham4Parser.g:1180:13: ( fingercrossing )
// Ham4Parser.g:1180:15: fingercrossing
this.pushFollow(Ham4Parser.FOLLOW_fingercrossing_in_synpred18_Ham4Parser4556);
this.fingercrossing();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred18_Ham4Parser",
// $ANTLR start "synpred19_Ham4Parser"
synpred19_Ham4Parser_fragment: function() {
// Ham4Parser.g:1677:9: ( handconstellation )
// Ham4Parser.g:1677:11: handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_synpred19_Ham4Parser5989);
this.handconstellation();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred19_Ham4Parser",
// $ANTLR start "synpred20_Ham4Parser"
synpred20_Ham4Parser_fragment: function() {
// Ham4Parser.g:1725:9: ( locationindexuse )
// Ham4Parser.g:1725:11: locationindexuse
this.pushFollow(Ham4Parser.FOLLOW_locationindexuse_in_synpred20_Ham4Parser6231);
this.locationindexuse();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred20_Ham4Parser",
// $ANTLR start "synpred21_Ham4Parser"
synpred21_Ham4Parser_fragment: function() {
// Ham4Parser.g:1729:9: ( levelhand )
// Ham4Parser.g:1729:11: levelhand
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_synpred21_Ham4Parser6291);
this.levelhand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred21_Ham4Parser",
// $ANTLR start "synpred22_Ham4Parser"
synpred22_Ham4Parser_fragment: function() {
// Ham4Parser.g:1810:9: ( levelbody )
// Ham4Parser.g:1810:11: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred22_Ham4Parser6522);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred22_Ham4Parser",
// $ANTLR start "synpred23_Ham4Parser"
synpred23_Ham4Parser_fragment: function() {
// Ham4Parser.g:1839:11: ( contactbody )
// Ham4Parser.g:1839:13: contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_synpred23_Ham4Parser6643);
this.contactbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred23_Ham4Parser",
// $ANTLR start "synpred24_Ham4Parser"
synpred24_Ham4Parser_fragment: function() {
// Ham4Parser.g:1862:11: ( contacthand )
// Ham4Parser.g:1862:12: contacthand
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_synpred24_Ham4Parser6723);
this.contacthand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred24_Ham4Parser",
// $ANTLR start "synpred25_Ham4Parser"
synpred25_Ham4Parser_fragment: function() {
// Ham4Parser.g:1887:11: ( contactbody )
// Ham4Parser.g:1887:13: contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_synpred25_Ham4Parser6815);
this.contactbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred25_Ham4Parser",
// $ANTLR start "synpred26_Ham4Parser"
synpred26_Ham4Parser_fragment: function() {
// Ham4Parser.g:2245:13: ( levelhand )
// Ham4Parser.g:2245:15: levelhand
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_synpred26_Ham4Parser8193);
this.levelhand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred26_Ham4Parser",
// $ANTLR start "synpred27_Ham4Parser"
synpred27_Ham4Parser_fragment: function() {
// Ham4Parser.g:2476:9: ( action1 location2not1 )
// Ham4Parser.g:2476:11: action1 location2not1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred27_Ham4Parser8814);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_synpred27_Ham4Parser8816);
this.location2not1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred27_Ham4Parser",
// $ANTLR start "synpred28_Ham4Parser"
synpred28_Ham4Parser_fragment: function() {
// Ham4Parser.g:2483:9: ( action1t )
// Ham4Parser.g:2483:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_synpred28_Ham4Parser8894);
this.action1t();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred28_Ham4Parser",
// $ANTLR start "synpred29_Ham4Parser"
synpred29_Ham4Parser_fragment: function() {
// Ham4Parser.g:2489:13: ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )
// Ham4Parser.g:2489:15: HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred29_Ham4Parser8961); if (this.state.failed) return ;
// Ham4Parser.g:2489:27: ( action1 )+
var cnt180=0;
loop180:
do {
var alt180=2;
alt180 = this.dfa180.predict(this.input);
switch (alt180) {
case 1 :
// Ham4Parser.g:2489:29: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred29_Ham4Parser8965);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt180 >= 1 ) {
break loop180;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(180, this.input);
throw eee;
}
cnt180++;
} while (true);
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred29_Ham4Parser8970); if (this.state.failed) return ;
// Ham4Parser.g:2490:15: ( action1 )+
var cnt181=0;
loop181:
do {
var alt181=2;
alt181 = this.dfa181.predict(this.input);
switch (alt181) {
case 1 :
// Ham4Parser.g:2490:17: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred29_Ham4Parser8988);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt181 >= 1 ) {
break loop181;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(181, this.input);
throw eee;
}
cnt181++;
} while (true);
this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_synpred29_Ham4Parser8993); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_location2_in_synpred29_Ham4Parser8995);
this.location2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred29_Ham4Parser",
// $ANTLR start "synpred30_Ham4Parser"
synpred30_Ham4Parser_fragment: function() {
// Ham4Parser.g:2494:13: ( HamParbegin ( action1t )+ HamPlus )
// Ham4Parser.g:2494:15: HamParbegin ( action1t )+ HamPlus
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred30_Ham4Parser9051); if (this.state.failed) return ;
// Ham4Parser.g:2494:27: ( action1t )+
var cnt182=0;
loop182:
do {
var alt182=2;
alt182 = this.dfa182.predict(this.input);
switch (alt182) {
case 1 :
// Ham4Parser.g:2494:29: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_synpred30_Ham4Parser9055);
this.action1t();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt182 >= 1 ) {
break loop182;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(182, this.input);
throw eee;
}
cnt182++;
} while (true);
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred30_Ham4Parser9060); if (this.state.failed) return ;
},
// $ANTLR end "synpred30_Ham4Parser",
// $ANTLR start "synpred31_Ham4Parser"
synpred31_Ham4Parser_fragment: function() {
// Ham4Parser.g:2554:13: ( action1 )
// Ham4Parser.g:2554:15: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred31_Ham4Parser9268);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred31_Ham4Parser",
// $ANTLR start "synpred32_Ham4Parser"
synpred32_Ham4Parser_fragment: function() {
// Ham4Parser.g:2559:21: ( handconstellation )
// Ham4Parser.g:2559:23: handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_synpred32_Ham4Parser9358);
this.handconstellation();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred32_Ham4Parser",
// $ANTLR start "synpred33_Ham4Parser"
synpred33_Ham4Parser_fragment: function() {
// Ham4Parser.g:2635:9: ( HamSeqbegin digit )
// Ham4Parser.g:2635:11: HamSeqbegin digit
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred33_Ham4Parser9858); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_digit_in_synpred33_Ham4Parser9860);
this.digit();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred33_Ham4Parser",
// $ANTLR start "synpred34_Ham4Parser"
synpred34_Ham4Parser_fragment: function() {
// Ham4Parser.g:2857:6: ( levelbody )
// Ham4Parser.g:2857:8: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred34_Ham4Parser10615);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred34_Ham4Parser",
// $ANTLR start "synpred35_Ham4Parser"
synpred35_Ham4Parser_fragment: function() {
// Ham4Parser.g:3000:13: ( ( HamSeqbegin )? repetition | HamAlternatingmotion )
var alt184=2;
var LA184_0 = this.input.LA(1);
if ( ((LA184_0>=HamRepeatfromstart && LA184_0<=HamSeqbegin)||LA184_0==HamRepeatreverse) ) {
alt184=1;
}
else if ( (LA184_0==HamAlternatingmotion) ) {
alt184=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);
throw nvae;
}
switch (alt184) {
case 1 :
// Ham4Parser.g:3000:15: ( HamSeqbegin )? repetition
// Ham4Parser.g:3000:15: ( HamSeqbegin )?
var alt183=2;
var LA183_0 = this.input.LA(1);
if ( (LA183_0==HamSeqbegin) ) {
alt183=1;
}
switch (alt183) {
case 1 :
// Ham4Parser.g:3000:17: HamSeqbegin
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred35_Ham4Parser11115); if (this.state.failed) return ;
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_synpred35_Ham4Parser11120);
this.repetition();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:3000:45: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_synpred35_Ham4Parser11124); if (this.state.failed) return ;
break;
}},
// $ANTLR end "synpred35_Ham4Parser",
// $ANTLR start "synpred36_Ham4Parser"
synpred36_Ham4Parser_fragment: function() {
// Ham4Parser.g:3053:9: ( HamSeqbegin HamRepeatfromstartseveral HamEtc )
// Ham4Parser.g:3053:11: HamSeqbegin HamRepeatfromstartseveral HamEtc
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred36_Ham4Parser11208); if (this.state.failed) return ;
this.match(this.input,HamRepeatfromstartseveral,Ham4Parser.FOLLOW_HamRepeatfromstartseveral_in_synpred36_Ham4Parser11210); if (this.state.failed) return ;
this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_synpred36_Ham4Parser11212); if (this.state.failed) return ;
},
// $ANTLR end "synpred36_Ham4Parser",
// $ANTLR start "synpred37_Ham4Parser"
synpred37_Ham4Parser_fragment: function() {
// Ham4Parser.g:3222:11: ( HamSeqbegin HamBrushing )
// Ham4Parser.g:3222:13: HamSeqbegin HamBrushing
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred37_Ham4Parser12166); if (this.state.failed) return ;
this.match(this.input,HamBrushing,Ham4Parser.FOLLOW_HamBrushing_in_synpred37_Ham4Parser12168); if (this.state.failed) return ;
},
// $ANTLR end "synpred37_Ham4Parser",
// $ANTLR start "synpred38_Ham4Parser"
synpred38_Ham4Parser_fragment: function() {
// Ham4Parser.g:3227:11: ( locationindexdefine )
// Ham4Parser.g:3227:13: locationindexdefine
this.pushFollow(Ham4Parser.FOLLOW_locationindexdefine_in_synpred38_Ham4Parser12263);
this.locationindexdefine();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred38_Ham4Parser",
// $ANTLR start "synpred39_Ham4Parser"
synpred39_Ham4Parser_fragment: function() {
// Ham4Parser.g:3493:17: ( splitreplacetail )
// Ham4Parser.g:3493:19: splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_synpred39_Ham4Parser13219);
this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred39_Ham4Parser"
// Delegated rules
synpred6_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred6_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred19_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred19_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred22_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred22_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred12_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred12_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred9_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred9_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred3_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred3_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred16_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred16_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred26_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred26_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred36_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred36_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred28_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred28_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred32_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred32_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred31_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred31_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred5_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred5_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred21_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred21_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred38_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred38_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred11_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred11_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred15_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred15_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred25_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred25_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred39_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred39_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred35_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred35_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred2_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred2_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred29_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred29_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred37_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred37_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred14_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred14_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred17_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred17_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred20_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred20_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred10_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred10_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred34_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred34_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred24_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred24_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred30_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred30_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred1_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred1_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred7_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred7_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred18_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred18_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred23_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred23_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred13_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred13_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred8_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred8_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred4_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred4_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred27_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred27_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred33_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred33_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
}
}, true); // important to pass true to overwrite default implementations
org.antlr.lang.augmentObject(Ham4Parser, {
DFA13_eotS:
"\u0014\uffff",
DFA13_eofS:
"\u0014\uffff",
DFA13_minS:
"\u0001\u0043\u0011\uffff\u0001\u0000\u0001\uffff",
DFA13_maxS:
"\u0001\u006b\u0011\uffff\u0001\u0000\u0001\uffff",
DFA13_acceptS:
"\u0001\uffff\u0011\u0001\u0001\uffff\u0001\u0002",
DFA13_specialS:
"\u0001\u0000\u0011\uffff\u0001\u0001\u0001\uffff}>",
DFA13_transitionS: [
"\u0001\u0011\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007"+
"\u0001\u0008\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002"+
"\u0001\u0003\u0001\u0004\u0001\u0008\u0001\u0005\u0002\u0011"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d"+
"\u0001\u000e\u0001\u0010\u0002\u0012\u0004\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA13_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_eotS),
DFA13_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_eofS),
DFA13_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA13_minS),
DFA13_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA13_maxS),
DFA13_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_acceptS),
DFA13_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_specialS),
DFA13_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA13_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA13 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 13;
this.eot = Ham4Parser.DFA13_eot;
this.eof = Ham4Parser.DFA13_eof;
this.min = Ham4Parser.DFA13_min;
this.max = Ham4Parser.DFA13_max;
this.accept = Ham4Parser.DFA13_accept;
this.special = Ham4Parser.DFA13_special;
this.transition = Ham4Parser.DFA13_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA13, org.antlr.runtime.DFA, {
getDescription: function() {
return "503:9: ( ( levelbody )=> levelbody | levelarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA13_0 = input.LA(1);
var index13_0 = input.index();
input.rewind();
s = -1;
if ( (LA13_0==HamHead) && (this.synpred3_Ham4Parser())) {s = 1;}
else if ( (LA13_0==HamHeadtop) && (this.synpred3_Ham4Parser())) {s = 2;}
else if ( (LA13_0==HamForehead) && (this.synpred3_Ham4Parser())) {s = 3;}
else if ( (LA13_0==HamEyebrows) && (this.synpred3_Ham4Parser())) {s = 4;}
else if ( (LA13_0==HamNose) && (this.synpred3_Ham4Parser())) {s = 5;}
else if ( (LA13_0==HamNostrils) && (this.synpred3_Ham4Parser())) {s = 6;}
else if ( (LA13_0==HamTongue) && (this.synpred3_Ham4Parser())) {s = 7;}
else if ( (LA13_0==HamTeeth||LA13_0==HamEyes||LA13_0==HamLips) && (this.synpred3_Ham4Parser())) {s = 8;}
else if ( (LA13_0==HamChin) && (this.synpred3_Ham4Parser())) {s = 9;}
else if ( (LA13_0==HamUnderchin) && (this.synpred3_Ham4Parser())) {s = 10;}
else if ( (LA13_0==HamNeck) && (this.synpred3_Ham4Parser())) {s = 11;}
else if ( (LA13_0==HamShouldertop) && (this.synpred3_Ham4Parser())) {s = 12;}
else if ( (LA13_0==HamShoulders) && (this.synpred3_Ham4Parser())) {s = 13;}
else if ( (LA13_0==HamChest) && (this.synpred3_Ham4Parser())) {s = 14;}
else if ( (LA13_0==HamStomach) && (this.synpred3_Ham4Parser())) {s = 15;}
else if ( (LA13_0==HamBelowstomach) && (this.synpred3_Ham4Parser())) {s = 16;}
else if ( (LA13_0==HamEarlobe||(LA13_0>=HamEar && LA13_0<=HamCheek)) && (this.synpred3_Ham4Parser())) {s = 17;}
else if ( ((LA13_0>=HamLrbeside && LA13_0<=HamLrat)) ) {s = 18;}
else if ( ((LA13_0>=HamUpperarm && LA13_0<=HamLowerarm)) ) {s = 19;}
input.seek(index13_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA13_18 = input.LA(1);
var index13_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred3_Ham4Parser()) ) {s = 17;}
else if ( (true) ) {s = 19;}
input.seek(index13_18);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 13, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA14_eotS:
"\u0027\uffff",
DFA14_eofS:
"\u0001\u001d\u0026\uffff",
DFA14_minS:
"\u0001\u000f\u0018\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u000a"+
"\uffff",
DFA14_maxS:
"\u0001\u00d9\u0018\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u000a"+
"\uffff",
DFA14_acceptS:
"\u0001\uffff\u0018\u0001\u0001\uffff\u0002\u0001\u0001\uffff\u0001"+
"\u0002\u0009\uffff",
DFA14_specialS:
"\u0001\u0000\u0018\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u000a"+
"\uffff}>",
DFA14_transitionS: [
"\u0001\u001d\u0033\uffff\u0001\u0017\u0001\u000c\u0001\u0012"+
"\u0008\uffff\u0001\u001d\u0004\uffff\u0001\u000d\u0001\u000e"+
"\u0001\u0015\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009"+
"\u0001\u000a\u0001\u000e\u0001\u000b\u0002\u0017\u0001\u000e"+
"\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0013\u0001\u0014"+
"\u0001\u0016\u0002\u0005\u0004\u0018\u0005\u0003\u0001\u0001"+
"\u0004\u0002\u0002\u0003\u0001\uffff\u0006\u0004\u0006\uffff"+
"\u0015\u001d\u0008\uffff\u0001\u001d\u0001\u0019\u0001\uffff"+
"\u0006\u001d\u0002\uffff\u0002\u001a\u0002\u001b\u0009\uffff"+
"\u0001\u001c\u000c\uffff\u0006\u001d\u0001\uffff\u000c\u001d",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA14_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_eotS),
DFA14_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_eofS),
DFA14_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA14_minS),
DFA14_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA14_maxS),
DFA14_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_acceptS),
DFA14_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_specialS),
DFA14_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA14_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA14 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 14;
this.eot = Ham4Parser.DFA14_eot;
this.eof = Ham4Parser.DFA14_eof;
this.min = Ham4Parser.DFA14_min;
this.max = Ham4Parser.DFA14_max;
this.accept = Ham4Parser.DFA14_accept;
this.special = Ham4Parser.DFA14_special;
this.transition = Ham4Parser.DFA14_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA14, org.antlr.runtime.DFA, {
getDescription: function() {
return "564:9: ( ( location2 )=> location2 )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA14_0 = input.LA(1);
var index14_0 = input.index();
input.rewind();
s = -1;
if ( (LA14_0==HamThumb) && (this.synpred5_Ham4Parser())) {s = 1;}
else if ( ((LA14_0>=HamIndexfinger && LA14_0<=HamPinky)) && (this.synpred5_Ham4Parser())) {s = 2;}
else if ( ((LA14_0>=HamWristback && LA14_0<=HamHandback)||(LA14_0>=HamThumbside && LA14_0<=HamPinkyside)) && (this.synpred5_Ham4Parser())) {s = 3;}
else if ( ((LA14_0>=HamFingertip && LA14_0<=HamFingerside)) && (this.synpred5_Ham4Parser())) {s = 4;}
else if ( ((LA14_0>=HamLrbeside && LA14_0<=HamLrat)) && (this.synpred5_Ham4Parser())) {s = 5;}
else if ( (LA14_0==HamNeutralspace) && (this.synpred5_Ham4Parser())) {s = 6;}
else if ( (LA14_0==HamHead) && (this.synpred5_Ham4Parser())) {s = 7;}
else if ( (LA14_0==HamHeadtop) && (this.synpred5_Ham4Parser())) {s = 8;}
else if ( (LA14_0==HamForehead) && (this.synpred5_Ham4Parser())) {s = 9;}
else if ( (LA14_0==HamEyebrows) && (this.synpred5_Ham4Parser())) {s = 10;}
else if ( (LA14_0==HamNose) && (this.synpred5_Ham4Parser())) {s = 11;}
else if ( (LA14_0==HamNostrils) && (this.synpred5_Ham4Parser())) {s = 12;}
else if ( (LA14_0==HamTongue) && (this.synpred5_Ham4Parser())) {s = 13;}
else if ( (LA14_0==HamTeeth||LA14_0==HamEyes||LA14_0==HamLips) && (this.synpred5_Ham4Parser())) {s = 14;}
else if ( (LA14_0==HamChin) && (this.synpred5_Ham4Parser())) {s = 15;}
else if ( (LA14_0==HamUnderchin) && (this.synpred5_Ham4Parser())) {s = 16;}
else if ( (LA14_0==HamNeck) && (this.synpred5_Ham4Parser())) {s = 17;}
else if ( (LA14_0==HamShouldertop) && (this.synpred5_Ham4Parser())) {s = 18;}
else if ( (LA14_0==HamShoulders) && (this.synpred5_Ham4Parser())) {s = 19;}
else if ( (LA14_0==HamChest) && (this.synpred5_Ham4Parser())) {s = 20;}
else if ( (LA14_0==HamStomach) && (this.synpred5_Ham4Parser())) {s = 21;}
else if ( (LA14_0==HamBelowstomach) && (this.synpred5_Ham4Parser())) {s = 22;}
else if ( (LA14_0==HamEarlobe||(LA14_0>=HamEar && LA14_0<=HamCheek)) && (this.synpred5_Ham4Parser())) {s = 23;}
else if ( ((LA14_0>=HamUpperarm && LA14_0<=HamLowerarm)) && (this.synpred5_Ham4Parser())) {s = 24;}
else if ( (LA14_0==HamParbegin) ) {s = 25;}
else if ( ((LA14_0>=HamClose && LA14_0<=HamTouch)) && (this.synpred5_Ham4Parser())) {s = 26;}
else if ( ((LA14_0>=HamInterlock && LA14_0<=HamCross)) && (this.synpred5_Ham4Parser())) {s = 27;}
else if ( (LA14_0==HamSeqbegin) ) {s = 28;}
else if ( (LA14_0==EOF||LA14_0==HamPlus||LA14_0==HamReplace||(LA14_0>=HamNomotion && LA14_0<=HamMovex)||LA14_0==HamFingerplay||(LA14_0>=HamCircleo && LA14_0<=HamCircler)||(LA14_0>=HamNodding && LA14_0<=HamFusionbegin)||(LA14_0>=HamCircleul && LA14_0<=HamCircleuo)) ) {s = 29;}
input.seek(index14_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA14_25 = input.LA(1);
var index14_25 = input.index();
input.rewind();
s = -1;
if ( (this.synpred5_Ham4Parser()) ) {s = 27;}
else if ( (true) ) {s = 29;}
input.seek(index14_25);
if ( s>=0 ) return s;
break;
case 2 : 
var LA14_28 = input.LA(1);
var index14_28 = input.index();
input.rewind();
s = -1;
if ( (this.synpred5_Ham4Parser()) ) {s = 27;}
else if ( (true) ) {s = 29;}
input.seek(index14_28);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 14, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA16_eotS:
"\u001a\uffff",
DFA16_eofS:
"\u001a\uffff",
DFA16_minS:
"\u0001\u000f\u0019\uffff",
DFA16_maxS:
"\u0001\u007e\u0019\uffff",
DFA16_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0017\uffff",
DFA16_specialS:
"\u0001\u0000\u0019\uffff}>",
DFA16_transitionS: [
"\u0001\u0001\u0033\uffff\u0003\u0002\u000d\uffff\u0025\u0002"+
"\u0001\uffff\u0006\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA16_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_eotS),
DFA16_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_eofS),
DFA16_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA16_minS),
DFA16_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA16_maxS),
DFA16_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_acceptS),
DFA16_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_specialS),
DFA16_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA16_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA16 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 16;
this.eot = Ham4Parser.DFA16_eot;
this.eof = Ham4Parser.DFA16_eof;
this.min = Ham4Parser.DFA16_min;
this.max = Ham4Parser.DFA16_max;
this.accept = Ham4Parser.DFA16_accept;
this.special = Ham4Parser.DFA16_special;
this.transition = Ham4Parser.DFA16_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA16, org.antlr.runtime.DFA, {
getDescription: function() {
return "573:9: ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA16_0 = input.LA(1);
var index16_0 = input.index();
input.rewind();
s = -1;
if ( (LA16_0==HamPlus) && (this.synpred6_Ham4Parser())) {s = 1;}
else if ( ((LA16_0>=HamEarlobe && LA16_0<=HamShouldertop)||(LA16_0>=HamTongue && LA16_0<=HamPinkyside)||(LA16_0>=HamFingertip && LA16_0<=HamFingerside)) ) {s = 2;}
input.seek(index16_0);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 16, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA15_eotS:
"\u001a\uffff",
DFA15_eofS:
"\u001a\uffff",
DFA15_minS:
"\u0001\u0043\u0019\uffff",
DFA15_maxS:
"\u0001\u00a4\u0019\uffff",
DFA15_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002",
DFA15_specialS:
"\u001a\uffff}>",
DFA15_transitionS: [
"\u0003\u0001\u000d\uffff\u0025\u0001\u0001\uffff\u0006\u0001"+
"\u0025\uffff\u0001\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA15_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_eotS),
DFA15_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_eofS),
DFA15_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA15_minS),
DFA15_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA15_maxS),
DFA15_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_acceptS),
DFA15_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_specialS),
DFA15_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA15_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA15 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 15;
this.eot = Ham4Parser.DFA15_eot;
this.eof = Ham4Parser.DFA15_eof;
this.min = Ham4Parser.DFA15_min;
this.max = Ham4Parser.DFA15_max;
this.accept = Ham4Parser.DFA15_accept;
this.special = Ham4Parser.DFA15_special;
this.transition = Ham4Parser.DFA15_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA15, org.antlr.runtime.DFA, {
getDescription: function() {
return "585:13: (ploc= location1 )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA18_eotS:
"\u0025\uffff",
DFA18_eofS:
"\u0001\u0019\u0024\uffff",
DFA18_minS:
"\u0001\u000f\u0024\uffff",
DFA18_maxS:
"\u0001\u00d9\u0024\uffff",
DFA18_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002\u000b\uffff",
DFA18_specialS:
"\u0025\uffff}>",
DFA18_transitionS: [
"\u0001\u0019\u0033\uffff\u0003\u0001\u0008\uffff\u0001\u0019"+
"\u0004\uffff\u0025\u0001\u0001\uffff\u0006\u0001\u0006\uffff"+
"\u0015\u0019\u0008\uffff\u0002\u0019\u0001\uffff\u0006\u0019"+
"\u000f\uffff\u0001\u0019\u000c\uffff\u0006\u0019\u0001\uffff"+
"\u000c\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA18_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_eotS),
DFA18_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_eofS),
DFA18_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA18_minS),
DFA18_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA18_maxS),
DFA18_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_acceptS),
DFA18_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_specialS),
DFA18_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA18_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA18 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 18;
this.eot = Ham4Parser.DFA18_eot;
this.eof = Ham4Parser.DFA18_eof;
this.min = Ham4Parser.DFA18_min;
this.max = Ham4Parser.DFA18_max;
this.accept = Ham4Parser.DFA18_accept;
this.special = Ham4Parser.DFA18_special;
this.transition = Ham4Parser.DFA18_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA18, org.antlr.runtime.DFA, {
getDescription: function() {
return "612:9: ( location1 )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA21_eotS:
"\u0015\uffff",
DFA21_eofS:
"\u0015\uffff",
DFA21_minS:
"\u0001\u0031\u0012\uffff\u0001\u0000\u0001\uffff",
DFA21_maxS:
"\u0001\u00a3\u0012\uffff\u0001\u0000\u0001\uffff",
DFA21_acceptS:
"\u0001\uffff\u0012\u0001\u0001\uffff\u0001\u0002",
DFA21_specialS:
"\u0001\u0000\u0012\uffff\u0001\u0001\u0001\uffff}>",
DFA21_transitionS: [
"\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005"+
"\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a"+
"\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f"+
"\u0001\u0010\u0001\u0011\u0001\u0012\u0060\uffff\u0001\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA21_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_eotS),
DFA21_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_eofS),
DFA21_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA21_minS),
DFA21_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA21_maxS),
DFA21_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_acceptS),
DFA21_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_specialS),
DFA21_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA21_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA21 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 21;
this.eot = Ham4Parser.DFA21_eot;
this.eof = Ham4Parser.DFA21_eof;
this.min = Ham4Parser.DFA21_min;
this.max = Ham4Parser.DFA21_max;
this.accept = Ham4Parser.DFA21_accept;
this.special = Ham4Parser.DFA21_special;
this.transition = Ham4Parser.DFA21_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA21, org.antlr.runtime.DFA, {
getDescription: function() {
return "759:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA21_0 = input.LA(1);
var index21_0 = input.index();
input.rewind();
s = -1;
if ( (LA21_0==HamExtfingeru) && (this.synpred9_Ham4Parser())) {s = 1;}
else if ( (LA21_0==HamExtfingerur) && (this.synpred9_Ham4Parser())) {s = 2;}
else if ( (LA21_0==HamExtfingerr) && (this.synpred9_Ham4Parser())) {s = 3;}
else if ( (LA21_0==HamExtfingerdr) && (this.synpred9_Ham4Parser())) {s = 4;}
else if ( (LA21_0==HamExtfingerd) && (this.synpred9_Ham4Parser())) {s = 5;}
else if ( (LA21_0==HamExtfingerdl) && (this.synpred9_Ham4Parser())) {s = 6;}
else if ( (LA21_0==HamExtfingerl) && (this.synpred9_Ham4Parser())) {s = 7;}
else if ( (LA21_0==HamExtfingerul) && (this.synpred9_Ham4Parser())) {s = 8;}
else if ( (LA21_0==HamExtfingerol) && (this.synpred9_Ham4Parser())) {s = 9;}
else if ( (LA21_0==HamExtfingero) && (this.synpred9_Ham4Parser())) {s = 10;}
else if ( (LA21_0==HamExtfingeror) && (this.synpred9_Ham4Parser())) {s = 11;}
else if ( (LA21_0==HamExtfingeril) && (this.synpred9_Ham4Parser())) {s = 12;}
else if ( (LA21_0==HamExtfingeri) && (this.synpred9_Ham4Parser())) {s = 13;}
else if ( (LA21_0==HamExtfingerir) && (this.synpred9_Ham4Parser())) {s = 14;}
else if ( (LA21_0==HamExtfingerui) && (this.synpred9_Ham4Parser())) {s = 15;}
else if ( (LA21_0==HamExtfingerdi) && (this.synpred9_Ham4Parser())) {s = 16;}
else if ( (LA21_0==HamExtfingerdo) && (this.synpred9_Ham4Parser())) {s = 17;}
else if ( (LA21_0==HamExtfingeruo) && (this.synpred9_Ham4Parser())) {s = 18;}
else if ( (LA21_0==HamParbegin) ) {s = 19;}
input.seek(index21_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA21_19 = input.LA(1);
var index21_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred9_Ham4Parser()) ) {s = 18;}
else if ( (true) ) {s = 20;}
input.seek(index21_19);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 21, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA25_eotS:
"\u0045\uffff",
DFA25_eofS:
"\u0001\u0037\u0044\uffff",
DFA25_minS:
"\u0001\u000f\u0040\u0000\u0004\uffff",
DFA25_maxS:
"\u0001\u00d9\u0040\u0000\u0004\uffff",
DFA25_acceptS:
"\u0041\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004",
DFA25_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
"\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001"+
"\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001"+
"\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001"+
"\u0016\u0001\u0017\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001"+
"\u001c\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021\u0001"+
"\u0022\u0001\u0023\u0001\u0024\u0001\u0025\u0001\u0026\u0001\u0027\u0001"+
"\u0028\u0001\u0029\u0001\u002a\u0001\u002b\u0001\u002c\u0001\u002d\u0001"+
"\u002e\u0001\u002f\u0001\u0030\u0001\u0031\u0001\u0032\u0001\u0033\u0001"+
"\u0034\u0001\u0035\u0001\u0036\u0001\u0037\u0001\u0038\u0001\u0039\u0001"+
"\u003a\u0001\u003b\u0001\u003c\u0001\u003d\u0001\u003e\u0001\u003f\u0004"+
"\uffff}>",
DFA25_transitionS: [
"\u0001\u0017\u0021\uffff\u0001\u0005\u0001\u0006\u0001\u0007"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c"+
"\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011"+
"\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016"+
"\u0001\u002b\u0001\u0020\u0001\u0026\u0008\u003b\u0001\u0032"+
"\u0004\uffff\u0001\u0021\u0001\u0022\u0001\u0029\u0001\u001a"+
"\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u0022"+
"\u0001\u001f\u0002\u002b\u0001\u0022\u0001\u0023\u0001\u0024"+
"\u0001\u0025\u0001\u0027\u0001\u0028\u0001\u002a\u0002\u0019"+
"\u0004\u002c\u0005\u0018\u0001\u0002\u0004\u0001\u0002\u0018"+
"\u0001\u0003\u0006\u0004\u0006\uffff\u0001\u002d\u0012\u002e"+
"\u0002\u0030\u0008\uffff\u0001\u0033\u0001\u0035\u0001\u0038"+
"\u0006\u002f\u0002\uffff\u0002\u0039\u0002\u003a\u0005\u003c"+
"\u0004\u003e\u0001\u0034\u0001\u003d\u0001\u003f\u0001\u003e"+
"\u0009\uffff\u0005\u0031\u0001\u0036\u0001\u0040\u000c\u002f",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA25_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_eotS),
DFA25_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_eofS),
DFA25_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA25_minS),
DFA25_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA25_maxS),
DFA25_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_acceptS),
DFA25_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_specialS),
DFA25_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA25_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA25 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 25;
this.eot = Ham4Parser.DFA25_eot;
this.eof = Ham4Parser.DFA25_eof;
this.min = Ham4Parser.DFA25_min;
this.max = Ham4Parser.DFA25_max;
this.accept = Ham4Parser.DFA25_accept;
this.special = Ham4Parser.DFA25_special;
this.transition = Ham4Parser.DFA25_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA25, org.antlr.runtime.DFA, {
getDescription: function() {
return "868:9: ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA25_1 = input.LA(1);
var index25_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred10_Ham4Parser()) ) {s = 65;}
else if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA25_2 = input.LA(1);
var index25_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred10_Ham4Parser()) ) {s = 65;}
else if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_2);
if ( s>=0 ) return s;
break;
case 2 : 
var LA25_3 = input.LA(1);
var index25_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
input.seek(index25_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA25_4 = input.LA(1);
var index25_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_4);
if ( s>=0 ) return s;
break;
case 4 : 
var LA25_5 = input.LA(1);
var index25_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_5);
if ( s>=0 ) return s;
break;
case 5 : 
var LA25_6 = input.LA(1);
var index25_6 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_6);
if ( s>=0 ) return s;
break;
case 6 : 
var LA25_7 = input.LA(1);
var index25_7 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_7);
if ( s>=0 ) return s;
break;
case 7 : 
var LA25_8 = input.LA(1);
var index25_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_8);
if ( s>=0 ) return s;
break;
case 8 : 
var LA25_9 = input.LA(1);
var index25_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_9);
if ( s>=0 ) return s;
break;
case 9 : 
var LA25_10 = input.LA(1);
var index25_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_10);
if ( s>=0 ) return s;
break;
case 10 : 
var LA25_11 = input.LA(1);
var index25_11 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_11);
if ( s>=0 ) return s;
break;
case 11 : 
var LA25_12 = input.LA(1);
var index25_12 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_12);
if ( s>=0 ) return s;
break;
case 12 : 
var LA25_13 = input.LA(1);
var index25_13 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_13);
if ( s>=0 ) return s;
break;
case 13 : 
var LA25_14 = input.LA(1);
var index25_14 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_14);
if ( s>=0 ) return s;
break;
case 14 : 
var LA25_15 = input.LA(1);
var index25_15 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_15);
if ( s>=0 ) return s;
break;
case 15 : 
var LA25_16 = input.LA(1);
var index25_16 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_16);
if ( s>=0 ) return s;
break;
case 16 : 
var LA25_17 = input.LA(1);
var index25_17 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_17);
if ( s>=0 ) return s;
break;
case 17 : 
var LA25_18 = input.LA(1);
var index25_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_18);
if ( s>=0 ) return s;
break;
case 18 : 
var LA25_19 = input.LA(1);
var index25_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_19);
if ( s>=0 ) return s;
break;
case 19 : 
var LA25_20 = input.LA(1);
var index25_20 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_20);
if ( s>=0 ) return s;
break;
case 20 : 
var LA25_21 = input.LA(1);
var index25_21 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_21);
if ( s>=0 ) return s;
break;
case 21 : 
var LA25_22 = input.LA(1);
var index25_22 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_22);
if ( s>=0 ) return s;
break;
case 22 : 
var LA25_23 = input.LA(1);
var index25_23 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_23);
if ( s>=0 ) return s;
break;
case 23 : 
var LA25_24 = input.LA(1);
var index25_24 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_24);
if ( s>=0 ) return s;
break;
case 24 : 
var LA25_25 = input.LA(1);
var index25_25 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_25);
if ( s>=0 ) return s;
break;
case 25 : 
var LA25_26 = input.LA(1);
var index25_26 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_26);
if ( s>=0 ) return s;
break;
case 26 : 
var LA25_27 = input.LA(1);
var index25_27 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_27);
if ( s>=0 ) return s;
break;
case 27 : 
var LA25_28 = input.LA(1);
var index25_28 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_28);
if ( s>=0 ) return s;
break;
case 28 : 
var LA25_29 = input.LA(1);
var index25_29 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_29);
if ( s>=0 ) return s;
break;
case 29 : 
var LA25_30 = input.LA(1);
var index25_30 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_30);
if ( s>=0 ) return s;
break;
case 30 : 
var LA25_31 = input.LA(1);
var index25_31 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_31);
if ( s>=0 ) return s;
break;
case 31 : 
var LA25_32 = input.LA(1);
var index25_32 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_32);
if ( s>=0 ) return s;
break;
case 32 : 
var LA25_33 = input.LA(1);
var index25_33 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_33);
if ( s>=0 ) return s;
break;
case 33 : 
var LA25_34 = input.LA(1);
var index25_34 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_34);
if ( s>=0 ) return s;
break;
case 34 : 
var LA25_35 = input.LA(1);
var index25_35 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_35);
if ( s>=0 ) return s;
break;
case 35 : 
var LA25_36 = input.LA(1);
var index25_36 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_36);
if ( s>=0 ) return s;
break;
case 36 : 
var LA25_37 = input.LA(1);
var index25_37 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_37);
if ( s>=0 ) return s;
break;
case 37 : 
var LA25_38 = input.LA(1);
var index25_38 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_38);
if ( s>=0 ) return s;
break;
case 38 : 
var LA25_39 = input.LA(1);
var index25_39 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_39);
if ( s>=0 ) return s;
break;
case 39 : 
var LA25_40 = input.LA(1);
var index25_40 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_40);
if ( s>=0 ) return s;
break;
case 40 : 
var LA25_41 = input.LA(1);
var index25_41 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_41);
if ( s>=0 ) return s;
break;
case 41 : 
var LA25_42 = input.LA(1);
var index25_42 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_42);
if ( s>=0 ) return s;
break;
case 42 : 
var LA25_43 = input.LA(1);
var index25_43 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_43);
if ( s>=0 ) return s;
break;
case 43 : 
var LA25_44 = input.LA(1);
var index25_44 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_44);
if ( s>=0 ) return s;
break;
case 44 : 
var LA25_45 = input.LA(1);
var index25_45 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_45);
if ( s>=0 ) return s;
break;
case 45 : 
var LA25_46 = input.LA(1);
var index25_46 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_46);
if ( s>=0 ) return s;
break;
case 46 : 
var LA25_47 = input.LA(1);
var index25_47 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_47);
if ( s>=0 ) return s;
break;
case 47 : 
var LA25_48 = input.LA(1);
var index25_48 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_48);
if ( s>=0 ) return s;
break;
case 48 : 
var LA25_49 = input.LA(1);
var index25_49 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_49);
if ( s>=0 ) return s;
break;
case 49 : 
var LA25_50 = input.LA(1);
var index25_50 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_50);
if ( s>=0 ) return s;
break;
case 50 : 
var LA25_51 = input.LA(1);
var index25_51 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_51);
if ( s>=0 ) return s;
break;
case 51 : 
var LA25_52 = input.LA(1);
var index25_52 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_52);
if ( s>=0 ) return s;
break;
case 52 : 
var LA25_53 = input.LA(1);
var index25_53 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_53);
if ( s>=0 ) return s;
break;
case 53 : 
var LA25_54 = input.LA(1);
var index25_54 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_54);
if ( s>=0 ) return s;
break;
case 54 : 
var LA25_55 = input.LA(1);
var index25_55 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_55);
if ( s>=0 ) return s;
break;
case 55 : 
var LA25_56 = input.LA(1);
var index25_56 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_56);
if ( s>=0 ) return s;
break;
case 56 : 
var LA25_57 = input.LA(1);
var index25_57 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_57);
if ( s>=0 ) return s;
break;
case 57 : 
var LA25_58 = input.LA(1);
var index25_58 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_58);
if ( s>=0 ) return s;
break;
case 58 : 
var LA25_59 = input.LA(1);
var index25_59 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_59);
if ( s>=0 ) return s;
break;
case 59 : 
var LA25_60 = input.LA(1);
var index25_60 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_60);
if ( s>=0 ) return s;
break;
case 60 : 
var LA25_61 = input.LA(1);
var index25_61 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_61);
if ( s>=0 ) return s;
break;
case 61 : 
var LA25_62 = input.LA(1);
var index25_62 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_62);
if ( s>=0 ) return s;
break;
case 62 : 
var LA25_63 = input.LA(1);
var index25_63 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_63);
if ( s>=0 ) return s;
break;
case 63 : 
var LA25_64 = input.LA(1);
var index25_64 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_64);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 25, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA23_eotS:
"\u0041\uffff",
DFA23_eofS:
"\u0001\u0005\u0040\uffff",
DFA23_minS:
"\u0001\u000f\u0001\u0000\u0001\uffff\u0002\u0000\u003c\uffff",
DFA23_maxS:
"\u0001\u00d9\u0001\u0000\u0001\uffff\u0002\u0000\u003c\uffff",
DFA23_acceptS:
"\u0002\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u003b\uffff",
DFA23_specialS:
"\u0001\u0000\u0001\u0001\u0001\uffff\u0001\u0002\u0001\u0003\u003c"+
"\uffff}>",
DFA23_transitionS: [
"\u0001\u0005\u0021\uffff\u001e\u0005\u0004\uffff\u001e\u0005"+
"\u0001\u0003\u0004\u0001\u0002\u0005\u0001\u0002\u0006\u0004"+
"\u0006\uffff\u0015\u0005\u0008\uffff\u0009\u0005\u0002\uffff"+
"\u0011\u0005\u0009\uffff\u0013\u0005",
"\u0001\uffff",
"",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA23_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_eotS),
DFA23_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_eofS),
DFA23_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA23_minS),
DFA23_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA23_maxS),
DFA23_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_acceptS),
DFA23_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_specialS),
DFA23_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA23_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA23 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 23;
this.eot = Ham4Parser.DFA23_eot;
this.eof = Ham4Parser.DFA23_eof;
this.min = Ham4Parser.DFA23_min;
this.max = Ham4Parser.DFA23_max;
this.accept = Ham4Parser.DFA23_accept;
this.special = Ham4Parser.DFA23_special;
this.transition = Ham4Parser.DFA23_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA23, org.antlr.runtime.DFA, {
getDescription: function() {
return "882:13: ( ( thumbspecial )=> thumbspecial )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA23_0 = input.LA(1);
var index23_0 = input.index();
input.rewind();
s = -1;
if ( ((LA23_0>=HamIndexfinger && LA23_0<=HamPinky)) ) {s = 1;}
else if ( (LA23_0==HamBetween) && (this.synpred12_Ham4Parser())) {s = 2;}
else if ( (LA23_0==HamThumb) ) {s = 3;}
else if ( ((LA23_0>=HamFingertip && LA23_0<=HamFingerside)) ) {s = 4;}
else if ( (LA23_0==EOF||LA23_0==HamPlus||(LA23_0>=HamExtfingeru && LA23_0<=HamReplace)||(LA23_0>=HamTongue && LA23_0<=HamHandback)||(LA23_0>=HamThumbside && LA23_0<=HamPinkyside)||(LA23_0>=HamNomotion && LA23_0<=HamMovex)||(LA23_0>=HamFingerplay && LA23_0<=HamCircler)||(LA23_0>=HamClose && LA23_0<=HamRepeatreverse)||(LA23_0>=HamNodding && LA23_0<=HamCircleuo)) ) {s = 5;}
input.seek(index23_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA23_1 = input.LA(1);
var index23_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA23_3 = input.LA(1);
var index23_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA23_4 = input.LA(1);
var index23_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_4);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 23, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA26_eotS:
"\u0042\uffff",
DFA26_eofS:
"\u0001\u0002\u0041\uffff",
DFA26_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA26_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA26_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA26_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA26_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u0025\u0002"+
"\u0001\u0001\u0006\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA26_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_eotS),
DFA26_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_eofS),
DFA26_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA26_minS),
DFA26_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA26_maxS),
DFA26_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_acceptS),
DFA26_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_specialS),
DFA26_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA26_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA26 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 26;
this.eot = Ham4Parser.DFA26_eot;
this.eof = Ham4Parser.DFA26_eof;
this.min = Ham4Parser.DFA26_min;
this.max = Ham4Parser.DFA26_max;
this.accept = Ham4Parser.DFA26_accept;
this.special = Ham4Parser.DFA26_special;
this.transition = Ham4Parser.DFA26_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA26, org.antlr.runtime.DFA, {
getDescription: function() {
return "926:9: ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA26_1 = input.LA(1);
var index26_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred14_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index26_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 26, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA33_eotS:
"\u0042\uffff",
DFA33_eofS:
"\u0001\u0002\u0041\uffff",
DFA33_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA33_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA33_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA33_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA33_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u001f\u0002"+
"\u0004\u0001\u0009\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA33_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_eotS),
DFA33_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_eofS),
DFA33_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA33_minS),
DFA33_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA33_maxS),
DFA33_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_acceptS),
DFA33_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_specialS),
DFA33_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA33_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA33 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 33;
this.eot = Ham4Parser.DFA33_eot;
this.eof = Ham4Parser.DFA33_eof;
this.min = Ham4Parser.DFA33_min;
this.max = Ham4Parser.DFA33_max;
this.accept = Ham4Parser.DFA33_accept;
this.special = Ham4Parser.DFA33_special;
this.transition = Ham4Parser.DFA33_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA33, org.antlr.runtime.DFA, {
getDescription: function() {
return "1035:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA33_1 = input.LA(1);
var index33_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred15_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index33_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 33, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA34_eotS:
"\u0042\uffff",
DFA34_eofS:
"\u0001\u0002\u0041\uffff",
DFA34_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA34_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA34_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA34_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA34_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u001f\u0002"+
"\u0004\u0001\u0009\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA34_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_eotS),
DFA34_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_eofS),
DFA34_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA34_minS),
DFA34_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA34_maxS),
DFA34_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_acceptS),
DFA34_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_specialS),
DFA34_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA34_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA34 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 34;
this.eot = Ham4Parser.DFA34_eot;
this.eof = Ham4Parser.DFA34_eof;
this.min = Ham4Parser.DFA34_min;
this.max = Ham4Parser.DFA34_max;
this.accept = Ham4Parser.DFA34_accept;
this.special = Ham4Parser.DFA34_special;
this.transition = Ham4Parser.DFA34_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA34, org.antlr.runtime.DFA, {
getDescription: function() {
return "1083:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA34_1 = input.LA(1);
var index34_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred16_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index34_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 34, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA35_eotS:
"\u0042\uffff",
DFA35_eofS:
"\u0001\u0003\u0041\uffff",
DFA35_minS:
"\u0001\u000f\u0002\u0000\u003f\uffff",
DFA35_maxS:
"\u0001\u00d9\u0002\u0000\u003f\uffff",
DFA35_acceptS:
"\u0003\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA35_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u003f\uffff}>",
DFA35_transitionS: [
"\u0001\u0003\u0021\uffff\u001e\u0003\u0004\uffff\u001e\u0003"+
"\u0001\u0001\u0004\u0002\u0009\u0003\u0006\uffff\u0015\u0003"+
"\u0008\uffff\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff"+
"\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA35_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_eotS),
DFA35_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_eofS),
DFA35_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA35_minS),
DFA35_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA35_maxS),
DFA35_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_acceptS),
DFA35_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_specialS),
DFA35_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA35_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA35 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 35;
this.eot = Ham4Parser.DFA35_eot;
this.eof = Ham4Parser.DFA35_eof;
this.min = Ham4Parser.DFA35_min;
this.max = Ham4Parser.DFA35_max;
this.accept = Ham4Parser.DFA35_accept;
this.special = Ham4Parser.DFA35_special;
this.transition = Ham4Parser.DFA35_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA35, org.antlr.runtime.DFA, {
getDescription: function() {
return "1131:9: ( ( fingershape )=> fingershape recfingershapelist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA35_1 = input.LA(1);
var index35_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred17_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index35_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA35_2 = input.LA(1);
var index35_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred17_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index35_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 35, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA36_eotS:
"\u0042\uffff",
DFA36_eofS:
"\u0001\u0003\u0041\uffff",
DFA36_minS:
"\u0001\u000f\u0002\u0000\u003f\uffff",
DFA36_maxS:
"\u0001\u00d9\u0002\u0000\u003f\uffff",
DFA36_acceptS:
"\u0003\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA36_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u003f\uffff}>",
DFA36_transitionS: [
"\u0001\u0003\u0021\uffff\u001e\u0003\u0004\uffff\u001e\u0003"+
"\u0001\u0001\u0004\u0002\u0009\u0003\u0006\uffff\u0015\u0003"+
"\u0008\uffff\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff"+
"\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA36_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_eotS),
DFA36_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_eofS),
DFA36_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA36_minS),
DFA36_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA36_maxS),
DFA36_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_acceptS),
DFA36_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_specialS),
DFA36_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA36_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA36 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 36;
this.eot = Ham4Parser.DFA36_eot;
this.eof = Ham4Parser.DFA36_eof;
this.min = Ham4Parser.DFA36_min;
this.max = Ham4Parser.DFA36_max;
this.accept = Ham4Parser.DFA36_accept;
this.special = Ham4Parser.DFA36_special;
this.transition = Ham4Parser.DFA36_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA36, org.antlr.runtime.DFA, {
getDescription: function() {
return "1179:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA36_1 = input.LA(1);
var index36_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred18_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index36_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA36_2 = input.LA(1);
var index36_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred18_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index36_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 36, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA49_eotS:
"\u001d\uffff",
DFA49_eofS:
"\u001d\uffff",
DFA49_minS:
"\u0001\u0043\u001c\uffff",
DFA49_maxS:
"\u0001\u00ba\u001c\uffff",
DFA49_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002\u0003\uffff",
DFA49_specialS:
"\u001d\uffff}>",
DFA49_transitionS: [
"\u0003\u0001\u000d\uffff\u0025\u0001\u0001\uffff\u0006\u0001"+
"\u0024\uffff\u0001\u0019\u0009\uffff\u0004\u0019\u0009\uffff"+
"\u0001\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA49_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_eotS),
DFA49_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_eofS),
DFA49_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA49_minS),
DFA49_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA49_maxS),
DFA49_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_acceptS),
DFA49_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_specialS),
DFA49_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA49_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA49 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 49;
this.eot = Ham4Parser.DFA49_eot;
this.eof = Ham4Parser.DFA49_eof;
this.min = Ham4Parser.DFA49_min;
this.max = Ham4Parser.DFA49_max;
this.accept = Ham4Parser.DFA49_accept;
this.special = Ham4Parser.DFA49_special;
this.transition = Ham4Parser.DFA49_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA49, org.antlr.runtime.DFA, {
getDescription: function() {
return "1616:5: ( location1as2 | location2not1 )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA54_eotS:
"\u001a\uffff",
DFA54_eofS:
"\u001a\uffff",
DFA54_minS:
"\u0001\u0043\u0002\u0000\u0002\uffff\u0001\u0000\u0014\uffff",
DFA54_maxS:
"\u0001\u007e\u0002\u0000\u0002\uffff\u0001\u0000\u0014\uffff",
DFA54_acceptS:
"\u0003\uffff\u0002\u0002\u0001\uffff\u0001\u0003\u0012\uffff\u0001"+
"\u0001",
DFA54_specialS:
"\u0001\u0000\u0001\u0001\u0001\u0002\u0002\uffff\u0001\u0003\u0014"+
"\uffff}>",
DFA54_transitionS: [
"\u0003\u0006\u000d\uffff\u0013\u0006\u0002\u0005\u0004\u0006"+
"\u0005\u0003\u0001\u0001\u0004\u0002\u0002\u0003\u0001\uffff"+
"\u0006\u0004",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA54_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_eotS),
DFA54_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_eofS),
DFA54_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA54_minS),
DFA54_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA54_maxS),
DFA54_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_acceptS),
DFA54_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_specialS),
DFA54_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA54_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA54 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 54;
this.eot = Ham4Parser.DFA54_eot;
this.eof = Ham4Parser.DFA54_eof;
this.min = Ham4Parser.DFA54_min;
this.max = Ham4Parser.DFA54_max;
this.accept = Ham4Parser.DFA54_accept;
this.special = Ham4Parser.DFA54_special;
this.transition = Ham4Parser.DFA54_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA54, org.antlr.runtime.DFA, {
getDescription: function() {
return "1724:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA54_0 = input.LA(1);
var index54_0 = input.index();
input.rewind();
s = -1;
if ( (LA54_0==HamThumb) ) {s = 1;}
else if ( ((LA54_0>=HamIndexfinger && LA54_0<=HamPinky)) ) {s = 2;}
else if ( ((LA54_0>=HamWristback && LA54_0<=HamHandback)||(LA54_0>=HamThumbside && LA54_0<=HamPinkyside)) && (this.synpred21_Ham4Parser())) {s = 3;}
else if ( ((LA54_0>=HamFingertip && LA54_0<=HamFingerside)) && (this.synpred21_Ham4Parser())) {s = 4;}
else if ( ((LA54_0>=HamLrbeside && LA54_0<=HamLrat)) ) {s = 5;}
else if ( ((LA54_0>=HamEarlobe && LA54_0<=HamShouldertop)||(LA54_0>=HamTongue && LA54_0<=HamBelowstomach)||(LA54_0>=HamUpperarm && LA54_0<=HamLowerarm)) ) {s = 6;}
input.seek(index54_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA54_1 = input.LA(1);
var index54_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred20_Ham4Parser()) ) {s = 25;}
else if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
input.seek(index54_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA54_2 = input.LA(1);
var index54_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred20_Ham4Parser()) ) {s = 25;}
else if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
input.seek(index54_2);
if ( s>=0 ) return s;
break;
case 3 : 
var LA54_5 = input.LA(1);
var index54_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
else if ( (true) ) {s = 6;}
input.seek(index54_5);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 54, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA56_eotS:
"\u0015\uffff",
DFA56_eofS:
"\u0015\uffff",
DFA56_minS:
"\u0001\u0043\u0012\uffff\u0001\u0000\u0001\uffff",
DFA56_maxS:
"\u0001\u006b\u0012\uffff\u0001\u0000\u0001\uffff",
DFA56_acceptS:
"\u0001\uffff\u0001\u0001\u0011\u0002\u0001\uffff\u0001\u0003",
DFA56_specialS:
"\u0001\u0000\u0012\uffff\u0001\u0001\u0001\uffff}>",
DFA56_transitionS: [
"\u0001\u0012\u0001\u0007\u0001\u000d\u000d\uffff\u0001\u0008"+
"\u0001\u0009\u0001\u0010\u0001\u0001\u0001\u0002\u0001\u0003"+
"\u0001\u0004\u0001\u0005\u0001\u0009\u0001\u0006\u0002\u0012"+
"\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000e"+
"\u0001\u000f\u0001\u0011\u0002\u0013\u0004\u0014",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA56_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_eotS),
DFA56_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_eofS),
DFA56_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA56_minS),
DFA56_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA56_maxS),
DFA56_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_acceptS),
DFA56_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_specialS),
DFA56_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA56_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA56 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 56;
this.eot = Ham4Parser.DFA56_eot;
this.eof = Ham4Parser.DFA56_eof;
this.min = Ham4Parser.DFA56_min;
this.max = Ham4Parser.DFA56_max;
this.accept = Ham4Parser.DFA56_accept;
this.special = Ham4Parser.DFA56_special;
this.transition = Ham4Parser.DFA56_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA56, org.antlr.runtime.DFA, {
getDescription: function() {
return "1806:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA56_0 = input.LA(1);
var index56_0 = input.index();
input.rewind();
s = -1;
if ( (LA56_0==HamNeutralspace) ) {s = 1;}
else if ( (LA56_0==HamHead) && (this.synpred22_Ham4Parser())) {s = 2;}
else if ( (LA56_0==HamHeadtop) && (this.synpred22_Ham4Parser())) {s = 3;}
else if ( (LA56_0==HamForehead) && (this.synpred22_Ham4Parser())) {s = 4;}
else if ( (LA56_0==HamEyebrows) && (this.synpred22_Ham4Parser())) {s = 5;}
else if ( (LA56_0==HamNose) && (this.synpred22_Ham4Parser())) {s = 6;}
else if ( (LA56_0==HamNostrils) && (this.synpred22_Ham4Parser())) {s = 7;}
else if ( (LA56_0==HamTongue) && (this.synpred22_Ham4Parser())) {s = 8;}
else if ( (LA56_0==HamTeeth||LA56_0==HamEyes||LA56_0==HamLips) && (this.synpred22_Ham4Parser())) {s = 9;}
else if ( (LA56_0==HamChin) && (this.synpred22_Ham4Parser())) {s = 10;}
else if ( (LA56_0==HamUnderchin) && (this.synpred22_Ham4Parser())) {s = 11;}
else if ( (LA56_0==HamNeck) && (this.synpred22_Ham4Parser())) {s = 12;}
else if ( (LA56_0==HamShouldertop) && (this.synpred22_Ham4Parser())) {s = 13;}
else if ( (LA56_0==HamShoulders) && (this.synpred22_Ham4Parser())) {s = 14;}
else if ( (LA56_0==HamChest) && (this.synpred22_Ham4Parser())) {s = 15;}
else if ( (LA56_0==HamStomach) && (this.synpred22_Ham4Parser())) {s = 16;}
else if ( (LA56_0==HamBelowstomach) && (this.synpred22_Ham4Parser())) {s = 17;}
else if ( (LA56_0==HamEarlobe||(LA56_0>=HamEar && LA56_0<=HamCheek)) && (this.synpred22_Ham4Parser())) {s = 18;}
else if ( ((LA56_0>=HamLrbeside && LA56_0<=HamLrat)) ) {s = 19;}
else if ( ((LA56_0>=HamUpperarm && LA56_0<=HamLowerarm)) ) {s = 20;}
input.seek(index56_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA56_19 = input.LA(1);
var index56_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred22_Ham4Parser()) ) {s = 18;}
else if ( (true) ) {s = 20;}
input.seek(index56_19);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 56, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA57_eotS:
"\u0016\uffff",
DFA57_eofS:
"\u0001\u0002\u0015\uffff",
DFA57_minS:
"\u0001\u000f\u0015\uffff",
DFA57_maxS:
"\u0001\u00d9\u0015\uffff",
DFA57_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0013\uffff",
DFA57_specialS:
"\u0016\uffff}>",
DFA57_transitionS: [
"\u0001\u0002\u003e\uffff\u0002\u0002\u0001\u0001\u0034\uffff"+
"\u0015\u0002\u0001\uffff\u0001\u0002\u0006\uffff\u0009\u0002"+
"\u0002\uffff\u0002\u0002\u0007\uffff\u0008\u0002\u0009\uffff"+
"\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA57_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_eotS),
DFA57_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_eofS),
DFA57_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA57_minS),
DFA57_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA57_maxS),
DFA57_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_acceptS),
DFA57_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_specialS),
DFA57_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA57_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA57 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 57;
this.eot = Ham4Parser.DFA57_eot;
this.eof = Ham4Parser.DFA57_eof;
this.min = Ham4Parser.DFA57_min;
this.max = Ham4Parser.DFA57_max;
this.accept = Ham4Parser.DFA57_accept;
this.special = Ham4Parser.DFA57_special;
this.transition = Ham4Parser.DFA57_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA57, org.antlr.runtime.DFA, {
getDescription: function() {
return "1838:9: ( HamBehind )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA58_eotS:
"\u0015\uffff",
DFA58_eofS:
"\u0001\u0004\u0014\uffff",
DFA58_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA58_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA58_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA58_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA58_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0001\u0002\u0035\uffff"+
"\u0015\u0004\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004"+
"\u0002\uffff\u0002\u0001\u0007\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA58_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_eotS),
DFA58_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_eofS),
DFA58_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA58_minS),
DFA58_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA58_maxS),
DFA58_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_acceptS),
DFA58_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_specialS),
DFA58_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA58_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA58 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 58;
this.eot = Ham4Parser.DFA58_eot;
this.eof = Ham4Parser.DFA58_eof;
this.min = Ham4Parser.DFA58_min;
this.max = Ham4Parser.DFA58_max;
this.accept = Ham4Parser.DFA58_accept;
this.special = Ham4Parser.DFA58_special;
this.transition = Ham4Parser.DFA58_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA58, org.antlr.runtime.DFA, {
getDescription: function() {
return "1839:9: ( ( contactbody )=> contactbody )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA58_0 = input.LA(1);
var index58_0 = input.index();
input.rewind();
s = -1;
if ( ((LA58_0>=HamClose && LA58_0<=HamTouch)) && (this.synpred23_Ham4Parser())) {s = 1;}
else if ( (LA58_0==HamArmextended) && (this.synpred23_Ham4Parser())) {s = 2;}
else if ( (LA58_0==HamSeqbegin) ) {s = 3;}
else if ( (LA58_0==EOF||LA58_0==HamPlus||LA58_0==HamReplace||(LA58_0>=HamNomotion && LA58_0<=HamMovex)||LA58_0==HamLargemod||(LA58_0>=HamFingerplay && LA58_0<=HamCircler)||(LA58_0>=HamRepeatfromstart && LA58_0<=HamRepeatcontinueseveral)||(LA58_0>=HamSeqend && LA58_0<=HamRepeatreverse)||(LA58_0>=HamNodding && LA58_0<=HamCircleuo)) ) {s = 4;}
input.seek(index58_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA58_3 = input.LA(1);
var index58_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred23_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index58_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 58, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA59_eotS:
"\u0015\uffff",
DFA59_eofS:
"\u0001\u0004\u0014\uffff",
DFA59_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA59_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA59_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA59_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA59_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0036\uffff\u0015\u0004"+
"\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004\u0002\uffff"+
"\u0002\u0001\u0002\u0002\u0005\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA59_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_eotS),
DFA59_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_eofS),
DFA59_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA59_minS),
DFA59_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA59_maxS),
DFA59_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_acceptS),
DFA59_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_specialS),
DFA59_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA59_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA59 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 59;
this.eot = Ham4Parser.DFA59_eot;
this.eof = Ham4Parser.DFA59_eof;
this.min = Ham4Parser.DFA59_min;
this.max = Ham4Parser.DFA59_max;
this.accept = Ham4Parser.DFA59_accept;
this.special = Ham4Parser.DFA59_special;
this.transition = Ham4Parser.DFA59_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA59, org.antlr.runtime.DFA, {
getDescription: function() {
return "1862:9: ( ( contacthand )=> contacthand )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA59_0 = input.LA(1);
var index59_0 = input.index();
input.rewind();
s = -1;
if ( ((LA59_0>=HamClose && LA59_0<=HamTouch)) && (this.synpred24_Ham4Parser())) {s = 1;}
else if ( ((LA59_0>=HamInterlock && LA59_0<=HamCross)) && (this.synpred24_Ham4Parser())) {s = 2;}
else if ( (LA59_0==HamSeqbegin) ) {s = 3;}
else if ( (LA59_0==EOF||LA59_0==HamPlus||LA59_0==HamReplace||(LA59_0>=HamNomotion && LA59_0<=HamMovex)||LA59_0==HamLargemod||(LA59_0>=HamFingerplay && LA59_0<=HamCircler)||(LA59_0>=HamRepeatfromstart && LA59_0<=HamRepeatcontinueseveral)||(LA59_0>=HamSeqend && LA59_0<=HamRepeatreverse)||(LA59_0>=HamNodding && LA59_0<=HamCircleuo)) ) {s = 4;}
input.seek(index59_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA59_3 = input.LA(1);
var index59_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred24_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index59_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 59, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA60_eotS:
"\u0016\uffff",
DFA60_eofS:
"\u0001\u0002\u0015\uffff",
DFA60_minS:
"\u0001\u000f\u0015\uffff",
DFA60_maxS:
"\u0001\u00d9\u0015\uffff",
DFA60_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0013\uffff",
DFA60_specialS:
"\u0016\uffff}>",
DFA60_transitionS: [
"\u0001\u0002\u003e\uffff\u0002\u0002\u0001\u0001\u0034\uffff"+
"\u0015\u0002\u0001\uffff\u0001\u0002\u0006\uffff\u0009\u0002"+
"\u0002\uffff\u0002\u0002\u0007\uffff\u0008\u0002\u0009\uffff"+
"\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA60_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_eotS),
DFA60_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_eofS),
DFA60_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA60_minS),
DFA60_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA60_maxS),
DFA60_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_acceptS),
DFA60_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_specialS),
DFA60_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA60_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA60 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 60;
this.eot = Ham4Parser.DFA60_eot;
this.eof = Ham4Parser.DFA60_eof;
this.min = Ham4Parser.DFA60_min;
this.max = Ham4Parser.DFA60_max;
this.accept = Ham4Parser.DFA60_accept;
this.special = Ham4Parser.DFA60_special;
this.transition = Ham4Parser.DFA60_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA60, org.antlr.runtime.DFA, {
getDescription: function() {
return "1886:9: ( HamBehind )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA61_eotS:
"\u0015\uffff",
DFA61_eofS:
"\u0001\u0004\u0014\uffff",
DFA61_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA61_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA61_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA61_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA61_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0001\u0002\u0035\uffff"+
"\u0015\u0004\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004"+
"\u0002\uffff\u0002\u0001\u0007\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA61_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_eotS),
DFA61_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_eofS),
DFA61_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA61_minS),
DFA61_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA61_maxS),
DFA61_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_acceptS),
DFA61_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_specialS),
DFA61_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA61_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA61 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 61;
this.eot = Ham4Parser.DFA61_eot;
this.eof = Ham4Parser.DFA61_eof;
this.min = Ham4Parser.DFA61_min;
this.max = Ham4Parser.DFA61_max;
this.accept = Ham4Parser.DFA61_accept;
this.special = Ham4Parser.DFA61_special;
this.transition = Ham4Parser.DFA61_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA61, org.antlr.runtime.DFA, {
getDescription: function() {
return "1887:9: ( ( contactbody )=> contactbody )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA61_0 = input.LA(1);
var index61_0 = input.index();
input.rewind();
s = -1;
if ( ((LA61_0>=HamClose && LA61_0<=HamTouch)) && (this.synpred25_Ham4Parser())) {s = 1;}
else if ( (LA61_0==HamArmextended) && (this.synpred25_Ham4Parser())) {s = 2;}
else if ( (LA61_0==HamSeqbegin) ) {s = 3;}
else if ( (LA61_0==EOF||LA61_0==HamPlus||LA61_0==HamReplace||(LA61_0>=HamNomotion && LA61_0<=HamMovex)||LA61_0==HamLargemod||(LA61_0>=HamFingerplay && LA61_0<=HamCircler)||(LA61_0>=HamRepeatfromstart && LA61_0<=HamRepeatcontinueseveral)||(LA61_0>=HamSeqend && LA61_0<=HamRepeatreverse)||(LA61_0>=HamNodding && LA61_0<=HamCircleuo)) ) {s = 4;}
input.seek(index61_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA61_3 = input.LA(1);
var index61_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred25_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index61_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 61, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA92_eotS:
"\u000d\uffff",
DFA92_eofS:
"\u0001\u000b\u000c\uffff",
DFA92_minS:
"\u0001\u000f\u000c\uffff",
DFA92_maxS:
"\u0001\u00d9\u000c\uffff",
DFA92_acceptS:
"\u0001\uffff\u0001\u0001\u0009\uffff\u0001\u0002\u0001\uffff",
DFA92_specialS:
"\u000d\uffff}>",
DFA92_transitionS: [
"\u0001\u000b\u003e\uffff\u0001\u0001\u0036\uffff\u0015\u0001"+
"\u0008\uffff\u0002\u0001\u0001\uffff\u0006\u0001\u000f\uffff"+
"\u0001\u0001\u000c\uffff\u0006\u0001\u0001\uffff\u000c\u0001",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA92_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_eotS),
DFA92_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_eofS),
DFA92_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA92_minS),
DFA92_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA92_maxS),
DFA92_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_acceptS),
DFA92_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_specialS),
DFA92_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA92_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA92 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 92;
this.eot = Ham4Parser.DFA92_eot;
this.eof = Ham4Parser.DFA92_eof;
this.min = Ham4Parser.DFA92_min;
this.max = Ham4Parser.DFA92_max;
this.accept = Ham4Parser.DFA92_accept;
this.special = Ham4Parser.DFA92_special;
this.transition = Ham4Parser.DFA92_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA92, org.antlr.runtime.DFA, {
getDescription: function() {
return "2397:9: ( action2t a2tlist )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA93_eotS:
"\u000d\uffff",
DFA93_eofS:
"\u0001\u000b\u000c\uffff",
DFA93_minS:
"\u0001\u000f\u000c\uffff",
DFA93_maxS:
"\u0001\u00d9\u000c\uffff",
DFA93_acceptS:
"\u0001\uffff\u0001\u0001\u0009\uffff\u0001\u0002\u0001\uffff",
DFA93_specialS:
"\u000d\uffff}>",
DFA93_transitionS: [
"\u0001\u000b\u003e\uffff\u0001\u0001\u0036\uffff\u0015\u0001"+
"\u0008\uffff\u0002\u0001\u0001\uffff\u0006\u0001\u000f\uffff"+
"\u0001\u0001\u000c\uffff\u0006\u0001\u0001\uffff\u000c\u0001",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA93_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_eotS),
DFA93_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_eofS),
DFA93_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA93_minS),
DFA93_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA93_maxS),
DFA93_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_acceptS),
DFA93_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_specialS),
DFA93_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA93_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA93 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 93;
this.eot = Ham4Parser.DFA93_eot;
this.eof = Ham4Parser.DFA93_eof;
this.min = Ham4Parser.DFA93_min;
this.max = Ham4Parser.DFA93_max;
this.accept = Ham4Parser.DFA93_accept;
this.special = Ham4Parser.DFA93_special;
this.transition = Ham4Parser.DFA93_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA93, org.antlr.runtime.DFA, {
getDescription: function() {
return "2422:9: ( action1t a1tlist )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA95_eotS:
"\u000e\uffff",
DFA95_eofS:
"\u000e\uffff",
DFA95_minS:
"\u0001\u004e\u000a\u0000\u0003\uffff",
DFA95_maxS:
"\u0001\u00d9\u000a\u0000\u0003\uffff",
DFA95_acceptS:
"\u000b\uffff\u0001\u0001\u0001\u0002\u0001\u0003",
DFA95_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
"\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0003"+
"\uffff}>",
DFA95_transitionS: [
"\u0001\u0006\u0036\uffff\u0001\u0001\u0012\u0002\u0002\u0004"+
"\u0008\uffff\u0001\u0007\u0001\u0009\u0001\uffff\u0006\u0003"+
"\u000f\uffff\u0001\u0008\u000c\uffff\u0005\u0005\u0001\u000a"+
"\u0001\uffff\u000c\u0003",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA95_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_eotS),
DFA95_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_eofS),
DFA95_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA95_minS),
DFA95_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA95_maxS),
DFA95_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_acceptS),
DFA95_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_specialS),
DFA95_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA95_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA95 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 95;
this.eot = Ham4Parser.DFA95_eot;
this.eof = Ham4Parser.DFA95_eof;
this.min = Ham4Parser.DFA95_min;
this.max = Ham4Parser.DFA95_max;
this.accept = Ham4Parser.DFA95_accept;
this.special = Ham4Parser.DFA95_special;
this.transition = Ham4Parser.DFA95_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA95, org.antlr.runtime.DFA, {
getDescription: function() {
return "2475:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA95_1 = input.LA(1);
var index95_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA95_2 = input.LA(1);
var index95_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_2);
if ( s>=0 ) return s;
break;
case 2 : 
var LA95_3 = input.LA(1);
var index95_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA95_4 = input.LA(1);
var index95_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_4);
if ( s>=0 ) return s;
break;
case 4 : 
var LA95_5 = input.LA(1);
var index95_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_5);
if ( s>=0 ) return s;
break;
case 5 : 
var LA95_6 = input.LA(1);
var index95_6 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_6);
if ( s>=0 ) return s;
break;
case 6 : 
var LA95_7 = input.LA(1);
var index95_7 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_7);
if ( s>=0 ) return s;
break;
case 7 : 
var LA95_8 = input.LA(1);
var index95_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_8);
if ( s>=0 ) return s;
break;
case 8 : 
var LA95_9 = input.LA(1);
var index95_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_9);
if ( s>=0 ) return s;
break;
case 9 : 
var LA95_10 = input.LA(1);
var index95_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_10);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 95, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA98_eotS:
"\u000e\uffff",
DFA98_eofS:
"\u000e\uffff",
DFA98_minS:
"\u0001\u004e\u0007\uffff\u0003\u0000\u0003\uffff",
DFA98_maxS:
"\u0001\u00d9\u0007\uffff\u0003\u0000\u0003\uffff",
DFA98_acceptS:
"\u0001\uffff\u0007\u0001\u0003\uffff\u0001\u0003\u0001\u0002\u0001"+
"\u0004",
DFA98_specialS:
"\u0001\u0000\u0007\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0003"+
"\uffff}>",
DFA98_transitionS: [
"\u0001\u0006\u0036\uffff\u0001\u0001\u0012\u0002\u0002\u0004"+
"\u0008\uffff\u0001\u0007\u0001\u0009\u0001\uffff\u0006\u0003"+
"\u000f\uffff\u0001\u0008\u000c\uffff\u0005\u0005\u0001\u000a"+
"\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA98_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_eotS),
DFA98_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_eofS),
DFA98_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA98_minS),
DFA98_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA98_maxS),
DFA98_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_acceptS),
DFA98_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_specialS),
DFA98_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA98_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA98 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 98;
this.eot = Ham4Parser.DFA98_eot;
this.eof = Ham4Parser.DFA98_eof;
this.min = Ham4Parser.DFA98_min;
this.max = Ham4Parser.DFA98_max;
this.accept = Ham4Parser.DFA98_accept;
this.special = Ham4Parser.DFA98_special;
this.transition = Ham4Parser.DFA98_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA98, org.antlr.runtime.DFA, {
getDescription: function() {
return "2553:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA98_0 = input.LA(1);
var index98_0 = input.index();
input.rewind();
s = -1;
if ( (LA98_0==HamNomotion) && (this.synpred31_Ham4Parser())) {s = 1;}
else if ( ((LA98_0>=HamMoveu && LA98_0<=HamMoveuo)) && (this.synpred31_Ham4Parser())) {s = 2;}
else if ( ((LA98_0>=HamCircleo && LA98_0<=HamCircler)||(LA98_0>=HamCircleul && LA98_0<=HamCircleuo)) && (this.synpred31_Ham4Parser())) {s = 3;}
else if ( ((LA98_0>=HamMovecross && LA98_0<=HamMovex)) && (this.synpred31_Ham4Parser())) {s = 4;}
else if ( ((LA98_0>=HamNodding && LA98_0<=HamStirccw)) && (this.synpred31_Ham4Parser())) {s = 5;}
else if ( (LA98_0==HamReplace) && (this.synpred31_Ham4Parser())) {s = 6;}
else if ( (LA98_0==HamFingerplay) && (this.synpred31_Ham4Parser())) {s = 7;}
else if ( (LA98_0==HamSeqbegin) ) {s = 8;}
else if ( (LA98_0==HamParbegin) ) {s = 9;}
else if ( (LA98_0==HamFusionbegin) ) {s = 10;}
input.seek(index98_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA98_8 = input.LA(1);
var index98_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 11;}
input.seek(index98_8);
if ( s>=0 ) return s;
break;
case 2 : 
var LA98_9 = input.LA(1);
var index98_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 12;}
input.seek(index98_9);
if ( s>=0 ) return s;
break;
case 3 : 
var LA98_10 = input.LA(1);
var index98_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 13;}
input.seek(index98_10);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 98, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA97_eotS:
"\u002c\uffff",
DFA97_eofS:
"\u0001\u001d\u002b\uffff",
DFA97_minS:
"\u0001\u000f\u0001\u0000\u0002\uffff\u0001\u0000\u0027\uffff",
DFA97_maxS:
"\u0001\u00d9\u0001\u0000\u0002\uffff\u0001\u0000\u0027\uffff",
DFA97_acceptS:
"\u0002\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0017\uffff\u0001"+
"\u0003\u000e\uffff",
DFA97_specialS:
"\u0001\u0000\u0001\u0001\u0002\uffff\u0001\u0002\u0027\uffff}>",
DFA97_transitionS: [
"\u0001\u001d\u0033\uffff\u0003\u0005\u0008\uffff\u0001\u001d"+
"\u0004\uffff\u0025\u0005\u0001\uffff\u0006\u0005\u0006\uffff"+
"\u0015\u001d\u0008\uffff\u0001\u001d\u0001\u0001\u0007\u001d"+
"\u0002\uffff\u0002\u0002\u0002\u0003\u0005\uffff\u0004\u001d"+
"\u0001\u0004\u0003\u001d\u0009\uffff\u0013\u001d",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA97_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_eotS),
DFA97_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_eofS),
DFA97_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA97_minS),
DFA97_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA97_maxS),
DFA97_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_acceptS),
DFA97_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_specialS),
DFA97_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA97_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA97 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 97;
this.eot = Ham4Parser.DFA97_eot;
this.eof = Ham4Parser.DFA97_eof;
this.min = Ham4Parser.DFA97_min;
this.max = Ham4Parser.DFA97_max;
this.accept = Ham4Parser.DFA97_accept;
this.special = Ham4Parser.DFA97_special;
this.transition = Ham4Parser.DFA97_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA97, org.antlr.runtime.DFA, {
getDescription: function() {
return "2558:17: ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA97_0 = input.LA(1);
var index97_0 = input.index();
input.rewind();
s = -1;
if ( (LA97_0==HamParbegin) ) {s = 1;}
else if ( ((LA97_0>=HamClose && LA97_0<=HamTouch)) && (this.synpred32_Ham4Parser())) {s = 2;}
else if ( ((LA97_0>=HamInterlock && LA97_0<=HamCross)) && (this.synpred32_Ham4Parser())) {s = 3;}
else if ( (LA97_0==HamSeqbegin) ) {s = 4;}
else if ( ((LA97_0>=HamEarlobe && LA97_0<=HamShouldertop)||(LA97_0>=HamTongue && LA97_0<=HamPinkyside)||(LA97_0>=HamFingertip && LA97_0<=HamFingerside)) ) {s = 5;}
else if ( (LA97_0==EOF||LA97_0==HamPlus||LA97_0==HamReplace||(LA97_0>=HamNomotion && LA97_0<=HamMovex)||LA97_0==HamFingerplay||(LA97_0>=HamParend && LA97_0<=HamCircler)||(LA97_0>=HamRepeatfromstart && LA97_0<=HamRepeatcontinueseveral)||(LA97_0>=HamSeqend && LA97_0<=HamRepeatreverse)||(LA97_0>=HamNodding && LA97_0<=HamCircleuo)) ) {s = 29;}
input.seek(index97_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA97_1 = input.LA(1);
var index97_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred32_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 29;}
input.seek(index97_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA97_4 = input.LA(1);
var index97_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred32_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 29;}
input.seek(index97_4);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 97, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA96_eotS:
"\u0013\uffff",
DFA96_eofS:
"\u0001\u0002\u0012\uffff",
DFA96_minS:
"\u0001\u000f\u0012\uffff",
DFA96_maxS:
"\u0001\u00d9\u0012\uffff",
DFA96_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0010\uffff",
DFA96_specialS:
"\u0013\uffff}>",
DFA96_transitionS: [
"\u0001\u0002\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0001\uffff\u0001\u0001\u0006\uffff\u0009\u0002\u000b\uffff"+
"\u0008\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA96_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_eotS),
DFA96_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_eofS),
DFA96_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA96_minS),
DFA96_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA96_maxS),
DFA96_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_acceptS),
DFA96_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_specialS),
DFA96_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA96_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA96 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 96;
this.eot = Ham4Parser.DFA96_eot;
this.eof = Ham4Parser.DFA96_eof;
this.min = Ham4Parser.DFA96_min;
this.max = Ham4Parser.DFA96_max;
this.accept = Ham4Parser.DFA96_accept;
this.special = Ham4Parser.DFA96_special;
this.transition = Ham4Parser.DFA96_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA96, org.antlr.runtime.DFA, {
getDescription: function() {
return "2564:21: ( HamLargemod )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA102_eotS:
"\u000d\uffff",
DFA102_eofS:
"\u000d\uffff",
DFA102_minS:
"\u0001\u004e\u0007\uffff\u0001\u0000\u0004\uffff",
DFA102_maxS:
"\u0001\u00d9\u0007\uffff\u0001\u0000\u0004\uffff",
DFA102_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0006\uffff\u0001\u0004\u0001"+
"\u0006\u0001\u0003\u0001\u0005",
DFA102_specialS:
"\u0008\uffff\u0001\u0000\u0004\uffff}>",
DFA102_transitionS: [
"\u0001\u0002\u0036\uffff\u0001\u0001\u0014\u0002\u0008\uffff"+
"\u0001\u0002\u0001\u0009\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0008\u000c\uffff\u0005\u0002\u0001\u000a\u0001\uffff"+
"\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA102_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_eotS),
DFA102_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_eofS),
DFA102_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA102_minS),
DFA102_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA102_maxS),
DFA102_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_acceptS),
DFA102_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_specialS),
DFA102_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA102_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA102 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 102;
this.eot = Ham4Parser.DFA102_eot;
this.eof = Ham4Parser.DFA102_eof;
this.min = Ham4Parser.DFA102_min;
this.max = Ham4Parser.DFA102_max;
this.accept = Ham4Parser.DFA102_accept;
this.special = Ham4Parser.DFA102_special;
this.transition = Ham4Parser.DFA102_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA102, org.antlr.runtime.DFA, {
getDescription: function() {
return "2624:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA102_8 = input.LA(1);
var index102_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred33_Ham4Parser()) ) {s = 11;}
else if ( (true) ) {s = 12;}
input.seek(index102_8);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 102, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA103_eotS:
"\u000d\uffff",
DFA103_eofS:
"\u000d\uffff",
DFA103_minS:
"\u0001\u000f\u000c\uffff",
DFA103_maxS:
"\u0001\u00d9\u000c\uffff",
DFA103_acceptS:
"\u0001\uffff\u0001\u0002\u0001\uffff\u0001\u0001\u0009\uffff",
DFA103_specialS:
"\u000d\uffff}>",
DFA103_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0003\u0036\uffff\u0015\u0003"+
"\u0008\uffff\u0002\u0003\u0001\u0001\u0006\u0003\u000f\uffff"+
"\u0001\u0003\u000c\uffff\u0006\u0003\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA103_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_eotS),
DFA103_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_eofS),
DFA103_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA103_minS),
DFA103_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA103_maxS),
DFA103_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_acceptS),
DFA103_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_specialS),
DFA103_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA103_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA103 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 103;
this.eot = Ham4Parser.DFA103_eot;
this.eof = Ham4Parser.DFA103_eof;
this.min = Ham4Parser.DFA103_min;
this.max = Ham4Parser.DFA103_max;
this.accept = Ham4Parser.DFA103_accept;
this.special = Ham4Parser.DFA103_special;
this.transition = Ham4Parser.DFA103_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA103, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2655:4: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA104_eotS:
"\u000d\uffff",
DFA104_eofS:
"\u000d\uffff",
DFA104_minS:
"\u0001\u000f\u000c\uffff",
DFA104_maxS:
"\u0001\u00d9\u000c\uffff",
DFA104_acceptS:
"\u0001\uffff\u0001\u0002\u0001\uffff\u0001\u0001\u0009\uffff",
DFA104_specialS:
"\u000d\uffff}>",
DFA104_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0003\u0036\uffff\u0015\u0003"+
"\u0008\uffff\u0002\u0003\u0001\u0001\u0006\u0003\u000f\uffff"+
"\u0001\u0003\u000c\uffff\u0006\u0003\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA104_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_eotS),
DFA104_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_eofS),
DFA104_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA104_minS),
DFA104_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA104_maxS),
DFA104_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_acceptS),
DFA104_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_specialS),
DFA104_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA104_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA104 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 104;
this.eot = Ham4Parser.DFA104_eot;
this.eof = Ham4Parser.DFA104_eof;
this.min = Ham4Parser.DFA104_min;
this.max = Ham4Parser.DFA104_max;
this.accept = Ham4Parser.DFA104_accept;
this.special = Ham4Parser.DFA104_special;
this.transition = Ham4Parser.DFA104_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA104, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2659:4: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA105_eotS:
"\u000c\uffff",
DFA105_eofS:
"\u000c\uffff",
DFA105_minS:
"\u0001\u004e\u000b\uffff",
DFA105_maxS:
"\u0001\u00d9\u000b\uffff",
DFA105_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA105_specialS:
"\u000c\uffff}>",
DFA105_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA105_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_eotS),
DFA105_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_eofS),
DFA105_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA105_minS),
DFA105_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA105_maxS),
DFA105_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_acceptS),
DFA105_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_specialS),
DFA105_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA105_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA105 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 105;
this.eot = Ham4Parser.DFA105_eot;
this.eof = Ham4Parser.DFA105_eof;
this.min = Ham4Parser.DFA105_min;
this.max = Ham4Parser.DFA105_max;
this.accept = Ham4Parser.DFA105_accept;
this.special = Ham4Parser.DFA105_special;
this.transition = Ham4Parser.DFA105_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA105, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2681:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA106_eotS:
"\u000c\uffff",
DFA106_eofS:
"\u000c\uffff",
DFA106_minS:
"\u0001\u004e\u000b\uffff",
DFA106_maxS:
"\u0001\u00d9\u000b\uffff",
DFA106_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA106_specialS:
"\u000c\uffff}>",
DFA106_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA106_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_eotS),
DFA106_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_eofS),
DFA106_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA106_minS),
DFA106_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA106_maxS),
DFA106_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_acceptS),
DFA106_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_specialS),
DFA106_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA106_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA106 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 106;
this.eot = Ham4Parser.DFA106_eot;
this.eof = Ham4Parser.DFA106_eof;
this.min = Ham4Parser.DFA106_min;
this.max = Ham4Parser.DFA106_max;
this.accept = Ham4Parser.DFA106_accept;
this.special = Ham4Parser.DFA106_special;
this.transition = Ham4Parser.DFA106_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA106, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2706:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA107_eotS:
"\u000c\uffff",
DFA107_eofS:
"\u000c\uffff",
DFA107_minS:
"\u0001\u004e\u000b\uffff",
DFA107_maxS:
"\u0001\u00d9\u000b\uffff",
DFA107_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA107_specialS:
"\u000c\uffff}>",
DFA107_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA107_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_eotS),
DFA107_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_eofS),
DFA107_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA107_minS),
DFA107_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA107_maxS),
DFA107_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_acceptS),
DFA107_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_specialS),
DFA107_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA107_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA107 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 107;
this.eot = Ham4Parser.DFA107_eot;
this.eof = Ham4Parser.DFA107_eof;
this.min = Ham4Parser.DFA107_min;
this.max = Ham4Parser.DFA107_max;
this.accept = Ham4Parser.DFA107_accept;
this.special = Ham4Parser.DFA107_special;
this.transition = Ham4Parser.DFA107_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA107, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2731:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA108_eotS:
"\u000c\uffff",
DFA108_eofS:
"\u000c\uffff",
DFA108_minS:
"\u0001\u004e\u000b\uffff",
DFA108_maxS:
"\u0001\u00d9\u000b\uffff",
DFA108_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA108_specialS:
"\u000c\uffff}>",
DFA108_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA108_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_eotS),
DFA108_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_eofS),
DFA108_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA108_minS),
DFA108_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA108_maxS),
DFA108_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_acceptS),
DFA108_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_specialS),
DFA108_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA108_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA108 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 108;
this.eot = Ham4Parser.DFA108_eot;
this.eof = Ham4Parser.DFA108_eof;
this.min = Ham4Parser.DFA108_min;
this.max = Ham4Parser.DFA108_max;
this.accept = Ham4Parser.DFA108_accept;
this.special = Ham4Parser.DFA108_special;
this.transition = Ham4Parser.DFA108_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA108, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2818:9: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA111_eotS:
"\u001e\uffff",
DFA111_eofS:
"\u001e\uffff",
DFA111_minS:
"\u0001\u0043\u001d\uffff",
DFA111_maxS:
"\u0001\u00d9\u001d\uffff",
DFA111_acceptS:
"\u0001\uffff\u0001\u0001\u0012\uffff\u0001\u0002\u0009\uffff",
DFA111_specialS:
"\u001e\uffff}>",
DFA111_transitionS: [
"\u0003\u0001\u0008\uffff\u0001\u0014\u0004\uffff\u0003\u0001"+
"\u0001\uffff\u0015\u0001\u0019\uffff\u0015\u0014\u0008\uffff"+
"\u0002\u0014\u0001\uffff\u0006\u0014\u000f\uffff\u0001\u0014"+
"\u000c\uffff\u0006\u0014\u0001\uffff\u000c\u0014",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA111_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_eotS),
DFA111_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_eofS),
DFA111_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA111_minS),
DFA111_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA111_maxS),
DFA111_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_acceptS),
DFA111_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_specialS),
DFA111_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA111_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA111 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 111;
this.eot = Ham4Parser.DFA111_eot;
this.eof = Ham4Parser.DFA111_eof;
this.min = Ham4Parser.DFA111_min;
this.max = Ham4Parser.DFA111_max;
this.accept = Ham4Parser.DFA111_accept;
this.special = Ham4Parser.DFA111_special;
this.transition = Ham4Parser.DFA111_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA111, org.antlr.runtime.DFA, {
getDescription: function() {
return "2855:9: ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA109_eotS:
"\u0014\uffff",
DFA109_eofS:
"\u0014\uffff",
DFA109_minS:
"\u0001\u0043\u0011\uffff\u0001\u0000\u0001\uffff",
DFA109_maxS:
"\u0001\u006b\u0011\uffff\u0001\u0000\u0001\uffff",
DFA109_acceptS:
"\u0001\uffff\u0011\u0001\u0001\uffff\u0001\u0002",
DFA109_specialS:
"\u0001\u0000\u0011\uffff\u0001\u0001\u0001\uffff}>",
DFA109_transitionS: [
"\u0001\u0011\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007"+
"\u0001\u0008\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002"+
"\u0001\u0003\u0001\u0004\u0001\u0008\u0001\u0005\u0002\u0011"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d"+
"\u0001\u000e\u0001\u0010\u0002\u0012\u0004\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA109_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_eotS),
DFA109_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_eofS),
DFA109_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA109_minS),
DFA109_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA109_maxS),
DFA109_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_acceptS),
DFA109_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_specialS),
DFA109_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA109_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA109 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 109;
this.eot = Ham4Parser.DFA109_eot;
this.eof = Ham4Parser.DFA109_eof;
this.min = Ham4Parser.DFA109_min;
this.max = Ham4Parser.DFA109_max;
this.accept = Ham4Parser.DFA109_accept;
this.special = Ham4Parser.DFA109_special;
this.transition = Ham4Parser.DFA109_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA109, org.antlr.runtime.DFA, {
getDescription: function() {
return "2856:4: ( ( levelbody )=> levelbody | levelarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA109_0 = input.LA(1);
var index109_0 = input.index();
input.rewind();
s = -1;
if ( (LA109_0==HamHead) && (this.synpred34_Ham4Parser())) {s = 1;}
else if ( (LA109_0==HamHeadtop) && (this.synpred34_Ham4Parser())) {s = 2;}
else if ( (LA109_0==HamForehead) && (this.synpred34_Ham4Parser())) {s = 3;}
else if ( (LA109_0==HamEyebrows) && (this.synpred34_Ham4Parser())) {s = 4;}
else if ( (LA109_0==HamNose) && (this.synpred34_Ham4Parser())) {s = 5;}
else if ( (LA109_0==HamNostrils) && (this.synpred34_Ham4Parser())) {s = 6;}
else if ( (LA109_0==HamTongue) && (this.synpred34_Ham4Parser())) {s = 7;}
else if ( (LA109_0==HamTeeth||LA109_0==HamEyes||LA109_0==HamLips) && (this.synpred34_Ham4Parser())) {s = 8;}
else if ( (LA109_0==HamChin) && (this.synpred34_Ham4Parser())) {s = 9;}
else if ( (LA109_0==HamUnderchin) && (this.synpred34_Ham4Parser())) {s = 10;}
else if ( (LA109_0==HamNeck) && (this.synpred34_Ham4Parser())) {s = 11;}
else if ( (LA109_0==HamShouldertop) && (this.synpred34_Ham4Parser())) {s = 12;}
else if ( (LA109_0==HamShoulders) && (this.synpred34_Ham4Parser())) {s = 13;}
else if ( (LA109_0==HamChest) && (this.synpred34_Ham4Parser())) {s = 14;}
else if ( (LA109_0==HamStomach) && (this.synpred34_Ham4Parser())) {s = 15;}
else if ( (LA109_0==HamBelowstomach) && (this.synpred34_Ham4Parser())) {s = 16;}
else if ( (LA109_0==HamEarlobe||(LA109_0>=HamEar && LA109_0<=HamCheek)) && (this.synpred34_Ham4Parser())) {s = 17;}
else if ( ((LA109_0>=HamLrbeside && LA109_0<=HamLrat)) ) {s = 18;}
else if ( ((LA109_0>=HamUpperarm && LA109_0<=HamLowerarm)) ) {s = 19;}
input.seek(index109_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA109_18 = input.LA(1);
var index109_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred34_Ham4Parser()) ) {s = 17;}
else if ( (true) ) {s = 19;}
input.seek(index109_18);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 109, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA110_eotS:
"\u000c\uffff",
DFA110_eofS:
"\u000c\uffff",
DFA110_minS:
"\u0001\u004e\u000b\uffff",
DFA110_maxS:
"\u0001\u00d9\u000b\uffff",
DFA110_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA110_specialS:
"\u000c\uffff}>",
DFA110_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA110_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_eotS),
DFA110_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_eofS),
DFA110_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA110_minS),
DFA110_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA110_maxS),
DFA110_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_acceptS),
DFA110_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_specialS),
DFA110_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA110_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA110 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 110;
this.eot = Ham4Parser.DFA110_eot;
this.eof = Ham4Parser.DFA110_eof;
this.min = Ham4Parser.DFA110_min;
this.max = Ham4Parser.DFA110_max;
this.accept = Ham4Parser.DFA110_accept;
this.special = Ham4Parser.DFA110_special;
this.transition = Ham4Parser.DFA110_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA110, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2864:10: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA112_eotS:
"\u000c\uffff",
DFA112_eofS:
"\u000c\uffff",
DFA112_minS:
"\u0001\u004e\u000b\uffff",
DFA112_maxS:
"\u0001\u00d9\u000b\uffff",
DFA112_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA112_specialS:
"\u000c\uffff}>",
DFA112_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA112_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_eotS),
DFA112_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_eofS),
DFA112_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA112_minS),
DFA112_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA112_maxS),
DFA112_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_acceptS),
DFA112_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_specialS),
DFA112_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA112_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA112 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 112;
this.eot = Ham4Parser.DFA112_eot;
this.eof = Ham4Parser.DFA112_eof;
this.min = Ham4Parser.DFA112_min;
this.max = Ham4Parser.DFA112_max;
this.accept = Ham4Parser.DFA112_accept;
this.special = Ham4Parser.DFA112_special;
this.transition = Ham4Parser.DFA112_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA112, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2892:9: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA113_eotS:
"\u000c\uffff",
DFA113_eofS:
"\u000c\uffff",
DFA113_minS:
"\u0001\u004e\u000b\uffff",
DFA113_maxS:
"\u0001\u00d9\u000b\uffff",
DFA113_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA113_specialS:
"\u000c\uffff}>",
DFA113_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA113_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_eotS),
DFA113_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_eofS),
DFA113_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA113_minS),
DFA113_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA113_maxS),
DFA113_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_acceptS),
DFA113_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_specialS),
DFA113_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA113_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA113 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 113;
this.eot = Ham4Parser.DFA113_eot;
this.eof = Ham4Parser.DFA113_eof;
this.min = Ham4Parser.DFA113_min;
this.max = Ham4Parser.DFA113_max;
this.accept = Ham4Parser.DFA113_accept;
this.special = Ham4Parser.DFA113_special;
this.transition = Ham4Parser.DFA113_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA113, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2919:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA114_eotS:
"\u000c\uffff",
DFA114_eofS:
"\u000c\uffff",
DFA114_minS:
"\u0001\u004e\u000b\uffff",
DFA114_maxS:
"\u0001\u00d9\u000b\uffff",
DFA114_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA114_specialS:
"\u000c\uffff}>",
DFA114_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA114_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_eotS),
DFA114_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_eofS),
DFA114_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA114_minS),
DFA114_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA114_maxS),
DFA114_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_acceptS),
DFA114_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_specialS),
DFA114_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA114_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA114 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 114;
this.eot = Ham4Parser.DFA114_eot;
this.eof = Ham4Parser.DFA114_eof;
this.min = Ham4Parser.DFA114_min;
this.max = Ham4Parser.DFA114_max;
this.accept = Ham4Parser.DFA114_accept;
this.special = Ham4Parser.DFA114_special;
this.transition = Ham4Parser.DFA114_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA114, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2946:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA115_eotS:
"\u000c\uffff",
DFA115_eofS:
"\u000c\uffff",
DFA115_minS:
"\u0001\u004e\u000b\uffff",
DFA115_maxS:
"\u0001\u00d9\u000b\uffff",
DFA115_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA115_specialS:
"\u000c\uffff}>",
DFA115_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA115_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_eotS),
DFA115_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_eofS),
DFA115_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA115_minS),
DFA115_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA115_maxS),
DFA115_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_acceptS),
DFA115_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_specialS),
DFA115_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA115_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA115 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 115;
this.eot = Ham4Parser.DFA115_eot;
this.eof = Ham4Parser.DFA115_eof;
this.min = Ham4Parser.DFA115_min;
this.max = Ham4Parser.DFA115_max;
this.accept = Ham4Parser.DFA115_accept;
this.special = Ham4Parser.DFA115_special;
this.transition = Ham4Parser.DFA115_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA115, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2973:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA116_eotS:
"\u0012\uffff",
DFA116_eofS:
"\u0001\u0004\u0011\uffff",
DFA116_minS:
"\u0001\u000f\u0001\u0000\u0010\uffff",
DFA116_maxS:
"\u0001\u00d9\u0001\u0000\u0010\uffff",
DFA116_acceptS:
"\u0002\uffff\u0002\u0001\u0001\u0002\u000d\uffff",
DFA116_specialS:
"\u0001\u0000\u0001\u0001\u0010\uffff}>",
DFA116_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0036\uffff\u0015\u0004"+
"\u0008\uffff\u0009\u0004\u000b\uffff\u0004\u0002\u0001\u0001"+
"\u0001\u0004\u0001\u0003\u0001\u0002\u0009\uffff\u0013\u0004",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA116_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_eotS),
DFA116_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_eofS),
DFA116_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA116_minS),
DFA116_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA116_maxS),
DFA116_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_acceptS),
DFA116_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_specialS),
DFA116_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA116_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA116 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 116;
this.eot = Ham4Parser.DFA116_eot;
this.eof = Ham4Parser.DFA116_eof;
this.min = Ham4Parser.DFA116_min;
this.max = Ham4Parser.DFA116_max;
this.accept = Ham4Parser.DFA116_accept;
this.special = Ham4Parser.DFA116_special;
this.transition = Ham4Parser.DFA116_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA116, org.antlr.runtime.DFA, {
getDescription: function() {
return "2999:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA116_0 = input.LA(1);
var index116_0 = input.index();
input.rewind();
s = -1;
if ( (LA116_0==HamSeqbegin) ) {s = 1;}
else if ( ((LA116_0>=HamRepeatfromstart && LA116_0<=HamRepeatcontinueseveral)||LA116_0==HamRepeatreverse) && (this.synpred35_Ham4Parser())) {s = 2;}
else if ( (LA116_0==HamAlternatingmotion) && (this.synpred35_Ham4Parser())) {s = 3;}
else if ( (LA116_0==EOF||LA116_0==HamPlus||LA116_0==HamReplace||(LA116_0>=HamNomotion && LA116_0<=HamMovex)||(LA116_0>=HamFingerplay && LA116_0<=HamCircler)||LA116_0==HamSeqend||(LA116_0>=HamNodding && LA116_0<=HamCircleuo)) ) {s = 4;}
input.seek(index116_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA116_1 = input.LA(1);
var index116_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred35_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 4;}
input.seek(index116_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 116, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA127_eotS:
"\u0030\uffff",
DFA127_eofS:
"\u0001\u0002\u002f\uffff",
DFA127_minS:
"\u0001\u000f\u002f\uffff",
DFA127_maxS:
"\u0001\u00d9\u002f\uffff",
DFA127_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002d\uffff",
DFA127_specialS:
"\u0030\uffff}>",
DFA127_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u000f\u0002\u0002\uffff\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA127_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_eotS),
DFA127_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_eofS),
DFA127_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA127_minS),
DFA127_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA127_maxS),
DFA127_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_acceptS),
DFA127_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_specialS),
DFA127_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA127_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA127 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 127;
this.eot = Ham4Parser.DFA127_eot;
this.eof = Ham4Parser.DFA127_eof;
this.min = Ham4Parser.DFA127_min;
this.max = Ham4Parser.DFA127_max;
this.accept = Ham4Parser.DFA127_accept;
this.special = Ham4Parser.DFA127_special;
this.transition = Ham4Parser.DFA127_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA127, org.antlr.runtime.DFA, {
getDescription: function() {
return "3198:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA128_eotS:
"\u002f\uffff",
DFA128_eofS:
"\u0001\u0003\u002e\uffff",
DFA128_minS:
"\u0001\u000f\u002e\uffff",
DFA128_maxS:
"\u0001\u00d9\u002e\uffff",
DFA128_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u002b\uffff",
DFA128_specialS:
"\u002f\uffff}>",
DFA128_transitionS: [
"\u0001\u0003\u0033\uffff\u0003\u0003\u0008\uffff\u0001\u0003"+
"\u0004\uffff\u0025\u0003\u0001\uffff\u0006\u0003\u0006\uffff"+
"\u0015\u0003\u0002\uffff\u0004\u0001\u0002\u0002\u0009\u0003"+
"\u0002\uffff\u0011\u0003\u0009\uffff\u0013\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA128_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_eotS),
DFA128_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_eofS),
DFA128_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA128_minS),
DFA128_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA128_maxS),
DFA128_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_acceptS),
DFA128_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_specialS),
DFA128_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA128_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA128 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 128;
this.eot = Ham4Parser.DFA128_eot;
this.eof = Ham4Parser.DFA128_eof;
this.min = Ham4Parser.DFA128_min;
this.max = Ham4Parser.DFA128_max;
this.accept = Ham4Parser.DFA128_accept;
this.special = Ham4Parser.DFA128_special;
this.transition = Ham4Parser.DFA128_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA128, org.antlr.runtime.DFA, {
getDescription: function() {
return "3199:13: ( arckind | zigzag )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA129_eotS:
"\u0032\uffff",
DFA129_eofS:
"\u0001\u0002\u0031\uffff",
DFA129_minS:
"\u0001\u000f\u0031\uffff",
DFA129_maxS:
"\u0001\u00d9\u0031\uffff",
DFA129_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002f\uffff",
DFA129_specialS:
"\u0032\uffff}>",
DFA129_transitionS: [
"\u0001\u0002\u0001\uffff\u0009\u0002\u0029\uffff\u0003\u0002"+
"\u0008\uffff\u0001\u0002\u0004\uffff\u0025\u0002\u0001\uffff"+
"\u0006\u0002\u0006\uffff\u0015\u0002\u0002\u0001\u0006\uffff"+
"\u001c\u0002\u0002\uffff\u0004\u0002\u0003\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA129_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_eotS),
DFA129_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_eofS),
DFA129_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA129_minS),
DFA129_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA129_maxS),
DFA129_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_acceptS),
DFA129_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_specialS),
DFA129_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA129_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA129 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 129;
this.eot = Ham4Parser.DFA129_eot;
this.eof = Ham4Parser.DFA129_eof;
this.min = Ham4Parser.DFA129_min;
this.max = Ham4Parser.DFA129_max;
this.accept = Ham4Parser.DFA129_accept;
this.special = Ham4Parser.DFA129_special;
this.transition = Ham4Parser.DFA129_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA129, org.antlr.runtime.DFA, {
getDescription: function() {
return "3206:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA130_eotS:
"\u0031\uffff",
DFA130_eofS:
"\u0001\u0003\u0030\uffff",
DFA130_minS:
"\u0001\u000f\u0030\uffff",
DFA130_maxS:
"\u0001\u00d9\u0030\uffff",
DFA130_acceptS:
"\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0002\u002d\uffff",
DFA130_specialS:
"\u0031\uffff}>",
DFA130_transitionS: [
"\u0001\u0003\u0001\uffff\u0009\u0001\u0029\uffff\u0003\u0003"+
"\u0008\uffff\u0001\u0003\u0004\uffff\u0025\u0003\u0001\uffff"+
"\u0006\u0003\u0006\uffff\u0015\u0003\u0008\uffff\u001c\u0003"+
"\u0002\uffff\u0004\u0003\u0003\uffff\u0013\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA130_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_eotS),
DFA130_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_eofS),
DFA130_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA130_minS),
DFA130_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA130_maxS),
DFA130_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_acceptS),
DFA130_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_specialS),
DFA130_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA130_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA130 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 130;
this.eot = Ham4Parser.DFA130_eot;
this.eof = Ham4Parser.DFA130_eof;
this.min = Ham4Parser.DFA130_min;
this.max = Ham4Parser.DFA130_max;
this.accept = Ham4Parser.DFA130_accept;
this.special = Ham4Parser.DFA130_special;
this.transition = Ham4Parser.DFA130_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA130, org.antlr.runtime.DFA, {
getDescription: function() {
return "3207:13: ( revolutions )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA131_eotS:
"\u002f\uffff",
DFA131_eofS:
"\u0001\u0002\u002e\uffff",
DFA131_minS:
"\u0001\u000f\u002e\uffff",
DFA131_maxS:
"\u0001\u00d9\u002e\uffff",
DFA131_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002c\uffff",
DFA131_specialS:
"\u002f\uffff}>",
DFA131_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u001c\u0002\u0002\uffff\u0004\u0001"+
"\u0003\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA131_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_eotS),
DFA131_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_eofS),
DFA131_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA131_minS),
DFA131_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA131_maxS),
DFA131_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_acceptS),
DFA131_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_specialS),
DFA131_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA131_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA131 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 131;
this.eot = Ham4Parser.DFA131_eot;
this.eof = Ham4Parser.DFA131_eof;
this.min = Ham4Parser.DFA131_min;
this.max = Ham4Parser.DFA131_max;
this.accept = Ham4Parser.DFA131_accept;
this.special = Ham4Parser.DFA131_special;
this.transition = Ham4Parser.DFA131_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA131, org.antlr.runtime.DFA, {
getDescription: function() {
return "3208:13: ( ellipse )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA132_eotS:
"\u002e\uffff",
DFA132_eofS:
"\u0001\u0002\u002d\uffff",
DFA132_minS:
"\u0001\u000f\u002d\uffff",
DFA132_maxS:
"\u0001\u00d9\u002d\uffff",
DFA132_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA132_specialS:
"\u002e\uffff}>",
DFA132_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u0009\u0002\u0002\u0001\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA132_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_eotS),
DFA132_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_eofS),
DFA132_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA132_minS),
DFA132_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA132_maxS),
DFA132_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_acceptS),
DFA132_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_specialS),
DFA132_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA132_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA132 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 132;
this.eot = Ham4Parser.DFA132_eot;
this.eof = Ham4Parser.DFA132_eof;
this.min = Ham4Parser.DFA132_min;
this.max = Ham4Parser.DFA132_max;
this.accept = Ham4Parser.DFA132_accept;
this.special = Ham4Parser.DFA132_special;
this.transition = Ham4Parser.DFA132_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA132, org.antlr.runtime.DFA, {
getDescription: function() {
return "3209:13: ( sizechangenonlinear )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA133_eotS:
"\u002e\uffff",
DFA133_eofS:
"\u0001\u0002\u002d\uffff",
DFA133_minS:
"\u0001\u000f\u002d\uffff",
DFA133_maxS:
"\u0001\u00d9\u002d\uffff",
DFA133_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA133_specialS:
"\u002e\uffff}>",
DFA133_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u0006\uffff\u0009\u0002\u0002\uffff"+
"\u0011\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA133_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_eotS),
DFA133_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_eofS),
DFA133_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA133_minS),
DFA133_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA133_maxS),
DFA133_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_acceptS),
DFA133_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_specialS),
DFA133_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA133_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA133 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 133;
this.eot = Ham4Parser.DFA133_eot;
this.eof = Ham4Parser.DFA133_eof;
this.min = Ham4Parser.DFA133_min;
this.max = Ham4Parser.DFA133_max;
this.accept = Ham4Parser.DFA133_accept;
this.special = Ham4Parser.DFA133_special;
this.transition = Ham4Parser.DFA133_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA133, org.antlr.runtime.DFA, {
getDescription: function() {
return "3212:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA134_eotS:
"\u002e\uffff",
DFA134_eofS:
"\u0001\u0002\u002d\uffff",
DFA134_minS:
"\u0001\u000f\u002d\uffff",
DFA134_maxS:
"\u0001\u00d9\u002d\uffff",
DFA134_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA134_specialS:
"\u002e\uffff}>",
DFA134_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u0006\uffff\u0009\u0002\u0002\uffff"+
"\u0011\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA134_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_eotS),
DFA134_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_eofS),
DFA134_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA134_minS),
DFA134_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA134_maxS),
DFA134_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_acceptS),
DFA134_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_specialS),
DFA134_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA134_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA134 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 134;
this.eot = Ham4Parser.DFA134_eot;
this.eof = Ham4Parser.DFA134_eof;
this.min = Ham4Parser.DFA134_min;
this.max = Ham4Parser.DFA134_max;
this.accept = Ham4Parser.DFA134_accept;
this.special = Ham4Parser.DFA134_special;
this.transition = Ham4Parser.DFA134_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA134, org.antlr.runtime.DFA, {
getDescription: function() {
return "3215:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA136_eotS:
"\u002e\uffff",
DFA136_eofS:
"\u0001\u0002\u002d\uffff",
DFA136_minS:
"\u0001\u000f\u0001\u0000\u002c\uffff",
DFA136_maxS:
"\u0001\u00d9\u0001\u0000\u002c\uffff",
DFA136_acceptS:
"\u0002\uffff\u0001\u0002\u002a\uffff\u0001\u0001",
DFA136_specialS:
"\u0001\uffff\u0001\u0000\u002c\uffff}>",
DFA136_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u0009\u0002\u0002\uffff\u000d\u0002"+
"\u0001\u0001\u0003\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA136_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_eotS),
DFA136_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_eofS),
DFA136_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA136_minS),
DFA136_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA136_maxS),
DFA136_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_acceptS),
DFA136_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_specialS),
DFA136_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA136_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA136 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 136;
this.eot = Ham4Parser.DFA136_eot;
this.eof = Ham4Parser.DFA136_eof;
this.min = Ham4Parser.DFA136_min;
this.max = Ham4Parser.DFA136_max;
this.accept = Ham4Parser.DFA136_accept;
this.special = Ham4Parser.DFA136_special;
this.transition = Ham4Parser.DFA136_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA136, org.antlr.runtime.DFA, {
getDescription: function() {
return "3221:9: ( ( HamSeqbegin HamBrushing )=> brushingcontact )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA136_1 = input.LA(1);
var index136_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred37_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 2;}
input.seek(index136_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 136, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA137_eotS:
"\u002e\uffff",
DFA137_eofS:
"\u0001\u0003\u002d\uffff",
DFA137_minS:
"\u0001\u000f\u0002\u0000\u002b\uffff",
DFA137_maxS:
"\u0001\u00d9\u0002\u0000\u002b\uffff",
DFA137_acceptS:
"\u0003\uffff\u0001\u0002\u0029\uffff\u0001\u0001",
DFA137_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u002b\uffff}>",
DFA137_transitionS: [
"\u0001\u0003\u0033\uffff\u0003\u0003\u0008\uffff\u0001\u0003"+
"\u0004\uffff\u001e\u0003\u0001\u0001\u0004\u0002\u0002\u0003"+
"\u0001\uffff\u0006\u0003\u0006\uffff\u0015\u0003\u0008\uffff"+
"\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA137_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_eotS),
DFA137_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_eofS),
DFA137_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA137_minS),
DFA137_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA137_maxS),
DFA137_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_acceptS),
DFA137_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_specialS),
DFA137_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA137_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA137 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 137;
this.eot = Ham4Parser.DFA137_eot;
this.eof = Ham4Parser.DFA137_eof;
this.min = Ham4Parser.DFA137_min;
this.max = Ham4Parser.DFA137_max;
this.accept = Ham4Parser.DFA137_accept;
this.special = Ham4Parser.DFA137_special;
this.transition = Ham4Parser.DFA137_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA137, org.antlr.runtime.DFA, {
getDescription: function() {
return "3226:9: ( ( locationindexdefine )=> locationindexdefine )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA137_1 = input.LA(1);
var index137_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred38_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 3;}
input.seek(index137_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA137_2 = input.LA(1);
var index137_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred38_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 3;}
input.seek(index137_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 137, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA157_eotS:
"\u0041\uffff",
DFA157_eofS:
"\u0001\u0002\u0040\uffff",
DFA157_minS:
"\u0001\u000f\u0001\u0000\u003f\uffff",
DFA157_maxS:
"\u0001\u00d9\u0001\u0000\u003f\uffff",
DFA157_acceptS:
"\u0002\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA157_specialS:
"\u0001\uffff\u0001\u0000\u003f\uffff}>",
DFA157_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u0025\u0002"+
"\u0001\uffff\u0006\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0001\u0002\u0001\u0001\u0007\u0002\u0002\uffff\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA157_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_eotS),
DFA157_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_eofS),
DFA157_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA157_minS),
DFA157_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA157_maxS),
DFA157_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_acceptS),
DFA157_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_specialS),
DFA157_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA157_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA157 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 157;
this.eot = Ham4Parser.DFA157_eot;
this.eof = Ham4Parser.DFA157_eof;
this.min = Ham4Parser.DFA157_min;
this.max = Ham4Parser.DFA157_max;
this.accept = Ham4Parser.DFA157_accept;
this.special = Ham4Parser.DFA157_special;
this.transition = Ham4Parser.DFA157_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA157, org.antlr.runtime.DFA, {
getDescription: function() {
return "3492:13: ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA157_1 = input.LA(1);
var index157_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred39_Ham4Parser()) ) {s = 64;}
else if ( (true) ) {s = 2;}
input.seek(index157_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 157, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA171_eotS:
"\u0013\uffff",
DFA171_eofS:
"\u0013\uffff",
DFA171_minS:
"\u0001\u0031\u0012\uffff",
DFA171_maxS:
"\u0001\u0042\u0012\uffff",
DFA171_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
"\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
"\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001"+
"\u0011\u0001\u0012",
DFA171_specialS:
"\u0013\uffff}>",
DFA171_transitionS: [
"\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005"+
"\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a"+
"\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f"+
"\u0001\u0010\u0001\u0011\u0001\u0012",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA171_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_eotS),
DFA171_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_eofS),
DFA171_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA171_minS),
DFA171_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA171_maxS),
DFA171_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_acceptS),
DFA171_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_specialS),
DFA171_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA171_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA171 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 171;
this.eot = Ham4Parser.DFA171_eot;
this.eof = Ham4Parser.DFA171_eof;
this.min = Ham4Parser.DFA171_min;
this.max = Ham4Parser.DFA171_max;
this.accept = Ham4Parser.DFA171_accept;
this.special = Ham4Parser.DFA171_special;
this.transition = Ham4Parser.DFA171_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA171, org.antlr.runtime.DFA, {
getDescription: function() {
return "3875:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA173_eotS:
"\u0011\uffff",
DFA173_eofS:
"\u0011\uffff",
DFA173_minS:
"\u0001\u0044\u0010\uffff",
DFA173_maxS:
"\u0001\u0065\u0010\uffff",
DFA173_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
"\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
"\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010",
DFA173_specialS:
"\u0011\uffff}>",
DFA173_transitionS: [
"\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007\u0001\u0008"+
"\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003"+
"\u0001\u0004\u0001\u0008\u0001\u0005\u0002\uffff\u0001\u0008"+
"\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d\u0001\u000e"+
"\u0001\u0010",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA173_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_eotS),
DFA173_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_eofS),
DFA173_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA173_minS),
DFA173_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA173_maxS),
DFA173_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_acceptS),
DFA173_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_specialS),
DFA173_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA173_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA173 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 173;
this.eot = Ham4Parser.DFA173_eot;
this.eof = Ham4Parser.DFA173_eof;
this.min = Ham4Parser.DFA173_min;
this.max = Ham4Parser.DFA173_max;
this.accept = Ham4Parser.DFA173_accept;
this.special = Ham4Parser.DFA173_special;
this.transition = Ham4Parser.DFA173_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA173, org.antlr.runtime.DFA, {
getDescription: function() {
return "4048:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA180_eotS:
"\u000c\uffff",
DFA180_eofS:
"\u000c\uffff",
DFA180_minS:
"\u0001\u000f\u000b\uffff",
DFA180_maxS:
"\u0001\u00d9\u000b\uffff",
DFA180_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA180_specialS:
"\u000c\uffff}>",
DFA180_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0008\uffff\u0002\u0002\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0002\u000c\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA180_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_eotS),
DFA180_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_eofS),
DFA180_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA180_minS),
DFA180_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA180_maxS),
DFA180_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_acceptS),
DFA180_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_specialS),
DFA180_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA180_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA180 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 180;
this.eot = Ham4Parser.DFA180_eot;
this.eof = Ham4Parser.DFA180_eof;
this.min = Ham4Parser.DFA180_min;
this.max = Ham4Parser.DFA180_max;
this.accept = Ham4Parser.DFA180_accept;
this.special = Ham4Parser.DFA180_special;
this.transition = Ham4Parser.DFA180_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA180, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2489:27: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA181_eotS:
"\u000c\uffff",
DFA181_eofS:
"\u000c\uffff",
DFA181_minS:
"\u0001\u004e\u000b\uffff",
DFA181_maxS:
"\u0001\u00d9\u000b\uffff",
DFA181_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA181_specialS:
"\u000c\uffff}>",
DFA181_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA181_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_eotS),
DFA181_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_eofS),
DFA181_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA181_minS),
DFA181_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA181_maxS),
DFA181_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_acceptS),
DFA181_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_specialS),
DFA181_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA181_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA181 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 181;
this.eot = Ham4Parser.DFA181_eot;
this.eof = Ham4Parser.DFA181_eof;
this.min = Ham4Parser.DFA181_min;
this.max = Ham4Parser.DFA181_max;
this.accept = Ham4Parser.DFA181_accept;
this.special = Ham4Parser.DFA181_special;
this.transition = Ham4Parser.DFA181_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA181, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2490:15: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA182_eotS:
"\u000c\uffff",
DFA182_eofS:
"\u000c\uffff",
DFA182_minS:
"\u0001\u000f\u000b\uffff",
DFA182_maxS:
"\u0001\u00d9\u000b\uffff",
DFA182_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA182_specialS:
"\u000c\uffff}>",
DFA182_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0008\uffff\u0002\u0002\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0002\u000c\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA182_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_eotS),
DFA182_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_eofS),
DFA182_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA182_minS),
DFA182_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA182_maxS),
DFA182_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_acceptS),
DFA182_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_specialS),
DFA182_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA182_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA182 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 182;
this.eot = Ham4Parser.DFA182_eot;
this.eof = Ham4Parser.DFA182_eof;
this.min = Ham4Parser.DFA182_min;
this.max = Ham4Parser.DFA182_max;
this.accept = Ham4Parser.DFA182_accept;
this.special = Ham4Parser.DFA182_special;
this.transition = Ham4Parser.DFA182_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA182, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2494:27: ( action1t )+";
},
dummy: null
});
// public class variables
org.antlr.lang.augmentObject(Ham4Parser, {
tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "WS", "HamTab", "HamLinefeed", "HamPagebreak", "HamReturn", "HamVersion40", "HamSpace", "HamExclaim", "HamQuery", "HamFullstop", "HamComma", "HamPlus", "HamMetaalt", "HamClocku", "HamClockul", "HamClockl", "HamClockdl", "HamClockd", "HamClockdr", "HamClockr", "HamClockur", "HamClockfull", "HamSymmpar", "HamSymmlr", "HamFist", "HamFlathand", "HamFinger2", "HamFinger23", "HamFinger23spread", "HamFinger2345", "HamThumboutmod", "HamThumbacrossmod", "HamPinch12", "HamPinchall", "HamPinch12open", "HamCee12", "HamCeeall", "HamCee12open", "HamThumbopenmod", "HamFingerstraightmod", "HamFingerbendmod", "HamFingerhookedmod", "HamNondominant", "HamDoublebent", "HamDoublehooked", "HamExtfingeru", "HamExtfingerur", "HamExtfingerr", "HamExtfingerdr", "HamExtfingerd", "HamExtfingerdl", "HamExtfingerl", "HamExtfingerul", "HamExtfingerol", "HamExtfingero", "HamExtfingeror", "HamExtfingeril", "HamExtfingeri", "HamExtfingerir", "HamExtfingerui", "HamExtfingerdi", "HamExtfingerdo", "HamExtfingeruo", "HamEarlobe", "HamNostrils", "HamShouldertop", "HamPalmu", "HamPalmur", "HamPalmr", "HamPalmdr", "HamPalmd", "HamPalmdl", "HamPalml", "HamPalmul", "HamReplace", "HamArmextended", "HamBehind", "HamEtc", "HamOrirelative", "HamTongue", "HamTeeth", "HamStomach", "HamNeutralspace", "HamHead", "HamHeadtop", "HamForehead", "HamEyebrows", "HamEyes", "HamNose", "HamEar", "HamCheek", "HamLips", "HamChin", "HamUnderchin", "HamNeck", "HamShoulders", "HamChest", "HamBelowstomach", "HamLrbeside", "HamLrat", "HamUpperarm", "HamElbow", "HamElbowinside", "HamLowerarm", "HamWristback", "HamWristpulse", "HamThumbball", "HamPalm", "HamHandback", "HamThumb", "HamIndexfinger", "HamMiddlefinger", "HamRingfinger", "HamPinky", "HamThumbside", "HamPinkyside", "HamBetween", "HamFingertip", "HamFingernail", "HamFingerpad", "HamFingermidjoint", "HamFingerbase", "HamFingerside", "HamWristtopulse", "HamWristtoback", "HamWristtothumb", "HamWristtopinky", "HamCoreftag", "HamCorefref", "HamNomotion", "HamMoveu", "HamMoveur", "HamMover", "HamMovedr", "HamMoved", "HamMovedl", "HamMovel", "HamMoveul", "HamMoveol", "HamMoveo", "HamMoveor", "HamMoveil", "HamMovei", "HamMoveir", "HamMoveui", "HamMovedi", "HamMovedo", "HamMoveuo", "HamMovecross", "HamMovex", "HamSmallmod", "HamLargemod", "HamArcl", "HamArcu", "HamArcr", "HamArcd", "HamWavy", "HamZigzag", "HamFingerplay", "HamParbegin", "HamParend", "HamCircleo", "HamCirclei", "HamCircled", "HamCircleu", "HamCirclel", "HamCircler", "HamIncreasing", "HamDecreasing", "HamClose", "HamTouch", "HamInterlock", "HamCross", "HamFast", "HamSlow", "HamTense", "HamRest", "HamHalt", "HamRepeatfromstart", "HamRepeatfromstartseveral", "HamRepeatcontinue", "HamRepeatcontinueseveral", "HamSeqbegin", "HamSeqend", "HamAlternatingmotion", "HamRepeatreverse", "HamBrushing", "HamNonipsi", "HamEllipseh", "HamEllipseur", "HamEllipsev", "HamEllipseul", "HamMime", "HamAltbegin", "HamAltend", "HamNodding", "HamSwinging", "HamTwisting", "HamStircw", "HamStirccw", "HamFusionbegin", "HamFusionend", "HamCircleul", "HamCircledr", "HamCircleur", "HamCircledl", "HamCircleol", "HamCircleir", "HamCircleor", "HamCircleil", "HamCircledo", "HamCircleui", "HamCircledi", "HamCircleuo", "HamNbs", "HAMSIGNS", "SIGN2", "SIGN1", "ICFG2", "ICFG1", "NMICLIST", "NMICUNIT", "MICFG2", "MICFG1", "HDCONFIG2", "HDCONFIG1", "SPLITHDCFG2", "HDCFGTAIL2", "HSHAPE2", "HSHAPE1", "BASICHDSHP1", "BASICHDSHP", "HSCLASS", "FIBENDING", "THUMBPOS", "FINGERLIST", "FISHPLIST", "FICRSSLIST", "FSHAPE", "FCROSSING", "THSPECIAL", "EXTFIDIR2", "EXTFIDIR1", "EXTFIDIR", "PALMOR2", "PALMOR1", "LOC2", "LOC1", "LOCTNBODYARM", "LOCTNBODY", "LOCTNHAND", "LOCTNARM", "LEVBODY", "LEVHAND", "LEVARM", "HCONSTLLN", "CNTCTBODY", "CNTCTHAND", "CNTCTOFHAND", "A2TLIST", "A1TLIST", "A1LIST", "ACTION2T", "ACTION1T", "ACTION2", "ACTION1", "PARACT2T", "SEQACT2T", "SPLITACT2LOC2", "SPLITACT2T", "PARACT1T", "SEQACT1T", "NMACT1T", "PARACT1", "REPETITIONS", "SIMPLEMVMT", "STRGHTMVMT", "CRCLRMVMT", "REPLACE", "SPLITREPLACETL", "REPLACETAIL1", "HSFINGERITEM", "LOCBODY", "MOVINGREPETITION", "SEQACT1", "SEQFUSEDACT2T", "SEQFUSEDACT1T", "SEQFUSEDACT1", "CNTCTOHHAND", "CNTCTOHARM"],
FOLLOW_hamsignseq_in_hamsinglesign735: new org.antlr.runtime.BitSet([0x00000000, 0x00000000]),
FOLLOW_EOF_in_hamsinglesign745: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sign2or1_in_hamsignseq813: new org.antlr.runtime.BitSet([0x00008002, 0x00000000]),
FOLLOW_HamPlus_in_hamsignseq845: new org.antlr.runtime.BitSet([0xFC000000, 0x000043F3,0x00000000, 0x00000000,0x00000020, 0x04000008]),
FOLLOW_sign2or1_in_hamsignseq865: new org.antlr.runtime.BitSet([0x00008002, 0x00000000]),
FOLLOW_nondomsign1_in_sign2or1952: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sign2_in_sign2or1968: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_symmoperator_in_sign21009: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000008]),
FOLLOW_initialconfig2_in_sign21019: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a2tstar_in_sign21029: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_initialconfig2_in_sign21062: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21072: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_sign21138: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
FOLLOW_HamNondominant_in_sign21148: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_sign21158: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21168: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_sign21203: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_sign21213: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21223: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNondominant_in_nondomsign11275: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_nondomsign11285: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_nondomsign11295: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_symmoperator1353: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator1425: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator1441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator1468: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator1484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamAlternatingmotion_in_symmoperator1510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
FOLLOW_HamNonipsi_in_symmoperator1525: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig21562: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000008]),
FOLLOW_minitialconfig2_in_initialconfig21575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig11634: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_minitialconfig1_in_initialconfig11647: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nmicunit_in_nminitialconfig1718: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_HamSeqbegin_in_nmicunit1781: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x00000FFF]),
FOLLOW_levelbody_in_nmicunit1812: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelarm_in_nmicunit1834: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_nmicunit1854: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_nmicunit1864: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig2_in_minitialconfig21965: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_minitialconfig22021: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_minitialconfig22064: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_minitialconfig22075: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_HamPlus_in_minitialconfig22131: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_minitialconfig22146: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_minitialconfig22160: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1_in_minitialconfig22204: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_minitialconfig22218: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x00000010]),
FOLLOW_location1_in_minitialconfig22237: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_minitialconfig22254: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig12328: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_minitialconfig12340: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_handconfig22445: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_handconfigtail2_in_handconfig22455: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_handconfig22510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splithandconfig2_in_handconfig22539: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape1_in_handconfig12588: new org.antlr.runtime.BitSet([0x00000002, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfig12612: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfig12626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splithandconfig22696: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_splithandconfig22707: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splithandconfig22717: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_splithandconfig22728: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splithandconfig22738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir2_in_handconfigtail22827: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_palmor2_in_handconfigtail22837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handconfigtail22867: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22880: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfigtail22892: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handconfigtail22902: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22915: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfigtail22927: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handconfigtail22937: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape1_in_handshape23010: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handshape23039: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_handshape1_in_handshape23054: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handshape23064: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_handshape1_in_handshape23079: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handshape23089: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_basichandshape1_in_handshape13140: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_cautiousfingerlist_in_handshape13205: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13219: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13233: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_thumbbetweenexplicit_in_handshape13247: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_cautiousfingerlist_in_handshape13325: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13339: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13353: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbspecial_in_handshape13377: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerlist_in_handshape13458: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13472: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13486: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbbetweendefault_in_handshape13502: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_handshape13506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerlist_in_handshape13539: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13553: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13567: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_basichandshape_in_basichandshape13654: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_basichandshape13719: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_basichandshape_in_basichandshape13734: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshapeclass_in_basichandshape3802: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C,0x00020000, 0x00000000]),
FOLLOW_HamNondominant_in_basichandshape3826: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_basichandshape3848: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C]),
FOLLOW_handbendandthumb_in_basichandshape3861: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbpos_in_handbendandthumb3932: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C]),
FOLLOW_fingerbending_in_handbendandthumb3944: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerbending_in_handbendandthumb3963: new org.antlr.runtime.BitSet([0x00000002, 0x0000040C]),
FOLLOW_thumbpos_in_handbendandthumb3975: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingerlist_in_fingerlist4007: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_recfingerlist4116: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingerlist_in_recfingerlist4130: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_reccautiousfingerlist_in_cautiousfingerlist4170: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_reccautiousfingerlist4273: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_reccautiousfingerlist_in_reccautiousfingerlist4287: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingershapelist_in_fingershapelist4327: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingershape_in_recfingershapelist4431: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingershapelist_in_recfingershapelist4445: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingercrossinglist_in_fingercrossinglist4485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingercrossing_in_recfingercrossinglist4586: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingercrossinglist_in_recfingercrossinglist4600: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_hsfingeritem4656: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000]),
FOLLOW_HamLargemod_in_hsfingeritem4668: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_digit4728: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_digit4738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_hsdigit4788: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_hsdigit4798: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_fingershape4827: new org.antlr.runtime.BitSet([0x00000000, 0x0001BC0C]),
FOLLOW_fingerbending_in_fingershape4837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_fingercrossing4897: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7E000000]),
FOLLOW_fingerpart_in_fingercrossing4907: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_fingercrossing4921: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetween_in_thumbspecial4981: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_thumbspecial4991: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetweenexplicit_in_thumbbetween5020: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetweendefault_in_thumbbetween5030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_thumbbetweenexplicit5059: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_thumbbetweenexplicit5069: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_thumbbetweenexplicit5080: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBetween_in_thumbbetweendefault5139: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_thumbextra5205: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_thumbextra5221: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_extfidir25287: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitextfidir2_in_extfidir25303: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitextfidir25354: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_splitextfidir25366: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitextfidir25376: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_splitextfidir25388: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitextfidir25398: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir_in_extfidir15429: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x01000000]),
FOLLOW_HamBetween_in_extfidir15453: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir_in_extfidir15467: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_extfidir15502: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_palmor25574: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitpalmor2_in_palmor25590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitpalmor25641: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_splitpalmor25653: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitpalmor25663: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_splitpalmor25675: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitpalmor25685: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor_in_palmor15716: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00060000, 0x01000000]),
FOLLOW_HamBetween_in_palmor15740: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor_in_palmor15754: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamEtc_in_palmor15772: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_palmor15807: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1as2_in_location25882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location2not1_in_location25898: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1_in_location1as25933: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_location2not16011: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x000000FF]),
FOLLOW_HamNeutralspace_in_location2not16035: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000]),
FOLLOW_HamArmextended_in_location2not16051: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbody_in_location2not16080: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_location2not16128: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_location2not16138: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_location2not16148: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_location2not16158: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_location2not16168: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexuse_in_location16273: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationhand_in_location16313: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbodyarm_in_location16329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_locationindexdefine6389: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000008, 0x00000000]),
FOLLOW_HamCoreftag_in_locationindexdefine6399: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_locationindexuse6436: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamCorefref_in_locationindexuse6446: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNeutralspace_in_locationbodyarm6489: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000]),
FOLLOW_HamArmextended_in_locationbodyarm6501: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbody_in_locationbodyarm6544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationarm_in_locationbodyarm6560: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexbody_in_locationbody6614: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00018000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_HamBehind_in_locationbody6626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contactbody_in_locationbody6649: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexhand_in_locationhand6710: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contacthand_in_locationhand6728: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexarm_in_locationarm6786: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00018000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_HamBehind_in_locationarm6798: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contactbody_in_locationarm6821: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody6882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexbody6906: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_levelbody_in_levelcomplexbody6922: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand6962: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexhand6986: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_levelhand_in_levelcomplexhand7002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm7042: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexarm7066: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x00000FFF]),
FOLLOW_levelarm_in_levelcomplexarm7082: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locbody_in_levelbody7134: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000000FF]),
FOLLOW_HamEtc_in_levelbody7146: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelbody7161: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locsided_in_levelbody7199: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000000FF]),
FOLLOW_HamEtc_in_levelbody7211: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelbody7226: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelbody7264: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x0000003F]),
FOLLOW_locbody_in_levelbody7288: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_levelbody7304: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locsided_in_levelbody7331: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_levelbody7347: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_lochand_in_levelhand7429: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000180FF]),
FOLLOW_dorsalorpalmar_in_levelhand7441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelhand7456: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelhand7496: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7EFFF000]),
FOLLOW_lochand_in_levelhand7506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00018000]),
FOLLOW_dorsalorpalmar_in_levelhand7518: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locarm_in_levelarm7585: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000180FF]),
FOLLOW_HamEtc_in_levelarm7597: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000180FF]),
FOLLOW_dorsalorpalmar_in_levelarm7612: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelarm7627: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelarm7668: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000F00]),
FOLLOW_locarm_in_levelarm7678: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00018000]),
FOLLOW_HamEtc_in_levelarm7690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00018000]),
FOLLOW_dorsalorpalmar_in_levelarm7705: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_pcontact_in_contactbody7776: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArmextended_in_contactbody7792: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactofhand_in_contactbody7808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_pcontact_in_contacthand7874: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ccontact_in_contacthand7890: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactofhand_in_contacthand7906: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handconstellation7974: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_locationhand_in_handconstellation7989: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handconstellation8003: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_locationhand_in_handconstellation8018: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handconstellation8032: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contacthand_in_handconstellation8054: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_contactofhand8108: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0001E000]),
FOLLOW_pcontact_in_contactofhand8133: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_ccontact_in_contactofhand8157: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_contactohhand_in_contactofhand8223: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_contactoharm_in_contactofhand8247: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_contactofhand8267: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexhand_in_contactohhand8329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexarm_in_contactoharm8380: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handpart_in_lochand8443: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_lochand8459: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_lochand8471: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_lochand8492: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x7E3E0000]),
FOLLOW_fingerpart_in_lochand8507: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_a2tlist_in_a2tstar8548: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_a1tlist_in_a1tstar8600: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action2t_in_a2tlist8672: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a2tlist_in_a2tlist8686: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_a1tlist8746: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tlist_in_a1tlist8760: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action2t8838: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2not1_in_action2t8848: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action2t8858: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_action2t8916: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitaction2loc2_in_action2t9025: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_splitaction2t_in_action2t9090: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_paraction2t_in_action2t9114: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqaction2t_in_action2t9138: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqfusedaction2t_in_action2t9162: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action2t9182: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action1t9316: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x37C1E008]),
FOLLOW_handconstellation_in_action1t9404: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_location1_in_action1t9444: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x37C00000]),
FOLLOW_HamLargemod_in_action1t9468: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_paraction1t_in_action1t9528: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqnmoraction1t_in_action1t9552: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqfusedaction1t_in_action1t9577: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action1t9597: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_action19733: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_simplemovement_in_action19762: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_modifier_in_action19788: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x003E0000]),
FOLLOW_HamLargemod_in_action19807: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_specialfingerplaymovement_in_action19882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_paraction1_in_action19911: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_seqaction1_in_action19940: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_seqfusedaction1_in_action19969: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action1seq10005: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_action1tseq10017: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParbegin_in_paraction2t10044: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_paraction2t10057: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction2t10070: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqaction2t10123: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_seqaction2t10136: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqaction2t10149: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction2t10202: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_seqfusedaction2t10215: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction2t10228: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitaction2loc210281: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1seq_in_splitaction2loc210294: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2loc210304: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1seq_in_splitaction2loc210316: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitaction2loc210326: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_splitaction2loc210337: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitaction2t10396: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1tseq_in_splitaction2t10409: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2t10419: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1tseq_in_splitaction2t10431: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitaction2t10441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_paraction1t10505: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_paraction1t10518: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction1t10531: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqnmoraction1t10590: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB84038, 0x00000FFF,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelbody_in_seqnmoraction1t10621: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelarm_in_seqnmoraction1t10633: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_seqnmoraction1t10643: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_action1t_in_seqnmoraction1t10679: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqnmoraction1t10716: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction1t10761: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_seqfusedaction1t10774: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction1t10787: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_paraction110845: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_paraction110858: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction110871: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqaction110929: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_seqaction110942: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqaction110955: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction111013: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_seqfusedaction111026: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction111039: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_repetitions_in_repetitionsoption11154: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_repetitions11234: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_HamRepeatfromstartseveral_in_repetitions11245: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_repetitions11255: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_repetitions11265: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_repetitions11275: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_repetition_in_repetitions11322: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x33C01800]),
FOLLOW_HamEtc_in_repetitions11354: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_repetition_in_repetitions11386: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_movingrepetition_in_repetitions11425: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_sizechangenonlinear_in_repetitions11447: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11474: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11490: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11545: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11557: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_alternations11608: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_alternations11620: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_movingrepetition11658: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x23C00000]),
FOLLOW_repetition_in_movingrepetition11669: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_movingrepetition11679: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x08001800]),
FOLLOW_size_in_movingrepetition11691: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08001800]),
FOLLOW_sizechangenonlinear_in_movingrepetition11706: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_movingrepetition11719: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_straightmovement_in_simplemovement11800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0xFC000000, 0x04000003]),
FOLLOW_size_in_simplemovement11816: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0xF0000000, 0x04000003]),
FOLLOW_arckind_in_simplemovement11851: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_zigzag_in_simplemovement11883: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_circularmovement_in_simplemovement11922: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_simplemovement11938: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_revolutions_in_simplemovement11957: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_ellipse_in_simplemovement11976: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800]),
FOLLOW_sizechangenonlinear_in_simplemovement11995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_movementcross_in_simplemovement12022: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04000000]),
FOLLOW_size_in_simplemovement12038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_wristmovement_in_simplemovement12065: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04000000]),
FOLLOW_size_in_simplemovement12081: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_replacement_in_simplemovement12108: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_HamFingerplay_in_simplemovement12132: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_brushingcontact_in_simplemovement12194: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_locationindexdefine_in_simplemovement12289: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_specialfingerplaymovement12449: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_specialfingerplaymovement12462: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x00000004]),
FOLLOW_HamFingerplay_in_specialfingerplaymovement12475: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_specialfingerplaymovement12485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement12530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_straightmovement12554: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement12569: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement12622: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_circularmovement12646: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000007E0,0x03FFC000, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement12661: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_arc_in_arckind12714: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000000]),
FOLLOW_arc_in_arckind12726: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_arckind12741: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_zigzag12773: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_zigzag12833: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_zigzag12848: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_zigzag12863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sizechange_in_sizechangenonlinear12895: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_sizechangenonlinear12907: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ellipsedirection_in_ellipse12939: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_ellipse12951: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_clock_in_revolutions12995: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13019: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13035: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions13061: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13080: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13092: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions13107: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamReplace_in_replacement13145: new org.antlr.runtime.BitSet([0xF0000000, 0xFFFE43F3,0x00003FC7, 0x00000000,0x00000000, 0x00001808]),
FOLLOW_sizechange_in_replacement13158: new org.antlr.runtime.BitSet([0xF0000000, 0xFFFE43F3,0x00003FC7, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_handshape1_in_replacement13185: new org.antlr.runtime.BitSet([0x00000002, 0xFFFE0000,0x00003FC7, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_splitreplacetail_in_replacement13257: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacement13291: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacement13314: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitreplacetail_in_replacement13380: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacement13419: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacement13435: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_replacement13480: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitreplacetail13534: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00003FC7, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail13545: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitreplacetail13555: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00003FC7, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_HamNomotion_in_splitreplacetail13580: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_replacetail1_in_splitreplacetail13605: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitreplacetail13625: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacetail113689: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacetail113701: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_replacetail113720: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_brushingcontact13776: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_brushingcontact13788: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_brushingcontact13798: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_brushingcontact13808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_handshapeclasstok13844: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshapeclasstok_in_handshapeclass13980: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_fingerbendingtok14017: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerbendingtok_in_fingerbending14085: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_thumbpostok14127: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbpostok_in_thumbpos14171: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumb_in_thumb14211: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_finger0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_fingerpart0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeru_in_extfidirtok14384: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerur_in_extfidirtok14394: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerr_in_extfidirtok14404: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdr_in_extfidirtok14414: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerd_in_extfidirtok14424: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdl_in_extfidirtok14434: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerl_in_extfidirtok14444: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerul_in_extfidirtok14454: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerol_in_extfidirtok14478: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_set_in_extfidirtok14492: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingero_in_extfidirtok14563: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidirtok14587: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_set_in_extfidirtok14601: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeril_in_extfidirtok14686: new org.antlr.runtime.BitSet([0x00000002, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_set_in_extfidirtok14700: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeri_in_extfidirtok14771: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidirtok14795: new org.antlr.runtime.BitSet([0x00000002, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_set_in_extfidirtok14809: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidirtok14894: new org.antlr.runtime.BitSet([0x00000002, 0x50000000]),
FOLLOW_set_in_extfidirtok14908: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidirtok14993: new org.antlr.runtime.BitSet([0x00000002, 0x50000000]),
FOLLOW_set_in_extfidirtok15007: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidirtok15092: new org.antlr.runtime.BitSet([0x00000002, 0x0A000000]),
FOLLOW_set_in_extfidirtok15106: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidirtok15191: new org.antlr.runtime.BitSet([0x00000002, 0x0A000000]),
FOLLOW_set_in_extfidirtok15205: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidirtok_in_extfidir15286: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_palmor0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locarm0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHead_in_locbodytok15488: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHeadtop_in_locbodytok15498: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamForehead_in_locbodytok15508: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEyebrows_in_locbodytok15518: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNose_in_locbodytok15528: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNostrils_in_locbodytok15538: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTongue_in_locbodytok15548: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locbodytok15572: new org.antlr.runtime.BitSet([0x00000002, 0x00018000]),
FOLLOW_set_in_locbodytok15654: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamChin_in_locbodytok15725: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamUnderchin_in_locbodytok15735: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNeck_in_locbodytok15745: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamShouldertop_in_locbodytok15755: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamShoulders_in_locbodytok15765: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamChest_in_locbodytok15775: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStomach_in_locbodytok15785: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBelowstomach_in_locbodytok15795: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locbodytok_in_locbody15815: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locsided0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_handpart0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_side0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_dorsalorpalmar0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_pcontact0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_ccontact0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_sizechange0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_repetition0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementarrow0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementcross0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_wristmovement0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementcircle0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_ellipsedirection0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_clock0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_modifier0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_arc0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_size0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNondominant_in_synpred1_Ham4Parser928: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_synpred1_Ham4Parser930: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_synpred2_Ham4Parser1112: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
FOLLOW_HamNondominant_in_synpred2_Ham4Parser1114: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_synpred2_Ham4Parser1116: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred3_Ham4Parser1806: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig2_in_synpred4_Ham4Parser1943: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location2_in_synpred5_Ham4Parser1991: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPlus_in_synpred6_Ham4Parser2101: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_synpred7_Ham4Parser2414: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_HamParbegin_in_synpred7_Ham4Parser2418: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_synpred7_Ham4Parser2423: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_synpred8_Ham4Parser2488: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir2_in_synpred9_Ham4Parser2805: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred10_Ham4Parser3168: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x013E0000]),
FOLLOW_HamBetween_in_synpred10_Ham4Parser3173: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_synpred10_Ham4Parser3175: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsdigit_in_synpred11_Ham4Parser3282: new org.antlr.runtime.BitSet([0x00000000, 0x0001BC0C,0x00000000, 0x7E3E0000]),
FOLLOW_fingerbending_in_synpred11_Ham4Parser3289: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_synpred11_Ham4Parser3293: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbspecial_in_synpred12_Ham4Parser3371: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred13_Ham4Parser3415: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbbetweendefault_in_synpred13_Ham4Parser3422: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_synpred13_Ham4Parser3426: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBetween_in_synpred14_Ham4Parser3680: new org.antlr.runtime.BitSet([0xF0000000, 0x000003F3]),
FOLLOW_handshapeclass_in_synpred14_Ham4Parser3682: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred15_Ham4Parser4086: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred16_Ham4Parser4241: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_synpred16_Ham4Parser4243: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingershape_in_synpred17_Ham4Parser4401: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingercrossing_in_synpred18_Ham4Parser4556: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_synpred19_Ham4Parser5989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexuse_in_synpred20_Ham4Parser6231: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_synpred21_Ham4Parser6291: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred22_Ham4Parser6522: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactbody_in_synpred23_Ham4Parser6643: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contacthand_in_synpred24_Ham4Parser6723: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactbody_in_synpred25_Ham4Parser6815: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_synpred26_Ham4Parser8193: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_synpred27_Ham4Parser8814: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2not1_in_synpred27_Ham4Parser8816: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_synpred28_Ham4Parser8894: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_synpred29_Ham4Parser8961: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_synpred29_Ham4Parser8965: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamPlus_in_synpred29_Ham4Parser8970: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_synpred29_Ham4Parser8988: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_synpred29_Ham4Parser8993: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_synpred29_Ham4Parser8995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_synpred30_Ham4Parser9051: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_synpred30_Ham4Parser9055: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamPlus_in_synpred30_Ham4Parser9060: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_synpred31_Ham4Parser9268: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_synpred32_Ham4Parser9358: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred33_Ham4Parser9858: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_synpred33_Ham4Parser9860: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred34_Ham4Parser10615: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred35_Ham4Parser11115: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x23C00000]),
FOLLOW_repetition_in_synpred35_Ham4Parser11120: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_synpred35_Ham4Parser11124: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred36_Ham4Parser11208: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_HamRepeatfromstartseveral_in_synpred36_Ham4Parser11210: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_synpred36_Ham4Parser11212: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred37_Ham4Parser12166: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_synpred37_Ham4Parser12168: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexdefine_in_synpred38_Ham4Parser12263: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitreplacetail_in_synpred39_Ham4Parser13219: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});
})();//-------- js/HMLBuilder.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, Defs, HMLBuilder, cwaenv, document, logLev;
cwaenv = this.getCWAEnv();
document = this.document;
Data = cwaenv.get("Data");
Defs = cwaenv.get("HNSDefs");
logLev = 0;
HMLBuilder = (function() {
function HMLBuilder() {
this.doc = Data.toDOM("<sign/>");
HMLBuilder.trace("SiGML document created");
}
HMLBuilder.prototype.newHMLElement = function(tag) {
HMLBuilder.trace("HML: newHMLElement(" + tag + ")");
return this.doc.createElement(tag);
};
HMLBuilder.prototype.wrapperEl = function(tag, inner) {
var wel;
HMLBuilder.trace("HML: wrapperEl(" + tag + ")");
wel = this.newHMLElement(tag);
wel.appendChild(inner);
return wel;
};
HMLBuilder.prototype.wrapPair = function(tag, inner0, inner1) {
var wel;
HMLBuilder.trace("HML: wrapPair(" + tag + ")");
wel = this.wrapperEl(tag, inner0);
wel.appendChild(inner1);
return wel;
};
HMLBuilder.prototype.wrapIfNeeded = function(tag, el) {
var elIsOK;
elIsOK = el.tagName === tag && !(el.hasAttributes());
HMLBuilder.trace("HML: wrapIfNeeded(" + tag + ") Needed is " + elIsOK);
if (elIsOK) {
return el;
} else {
return this.wrapperEl(tag, el);
}
};
HMLBuilder.prototype.stripParentIfNotNeeded = function(el) {
var child, res;
HMLBuilder.trace("HML: stripParentIfNotNeeded");
res = el;
child = el.firstChild;
if (el.tagName === (child != null ? child.tagName : void 0) && !(el.hasAttributes())) {
HMLBuilder.trace("HML: stripParentIfNotNeeded removing child");
res = el.removeChild(child);
}
return res;
};
HMLBuilder.prototype.elementFromList = function(al, etag) {
var e, elmem, i, ix, len;
HMLBuilder.trace("HML: elementFromList " + etag + " length " + al.length);
if (al.length === 1) {
return al[0];
} else {
e = this.newHMLElement(etag);
for (ix = i = 0, len = al.length; i < len; ix = ++i) {
elmem = al[ix];
HMLBuilder.trace("HML: elementFromList " + etag + " append child " + ix + " " + elmem.tagName);
e.appendChild(elmem);
}
return e;
}
};
HMLBuilder.prototype.rootEl = function(inner) {
this.doc.documentElement.appendChild(inner);
return this.doc;
};
HMLBuilder.prototype.appendChildList = function(el, chl) {
var chlel, i, len, results;
results = [];
for (i = 0, len = chl.length; i < len; i++) {
chlel = chl[i];
results.push(this.checkedAppendChild(el, chlel));
}
return results;
};
HMLBuilder.prototype.checkedAppendChildList = function(el, chl) {
if (chl != null) {
return this.appendChildList(el, chl);
}
};
HMLBuilder.prototype.checkedAppendChild = function(el, ch) {
if (ch != null) {
return el.appendChild(ch);
}
};
HMLBuilder.prototype.checkedSetAttr = function(el, aname, aval) {
if (aval != null) {
HMLBuilder.trace("HML: checkedSetAttr: " + aname + " set to " + aval);
return el.setAttribute(aname, aval);
} else {
return HMLBuilder.trace("HML: checkedSetAttr: " + aname + " not set");
}
};
HMLBuilder.prototype.checkedSetFlagAttr = function(el, aname, flagIsTrue) {
if (flagIsTrue) {
return el.setAttribute(aname, "true");
}
};
HMLBuilder.prototype.checkedStringSetFlagAttr = function(el, aname, aval) {
if (aval === "true") {
HMLBuilder.trace("HML: checkedStringSetFlagAttr: " + aname + " set to true");
return el.setAttribute(aname, "true");
} else {
return HMLBuilder.trace("HML: checkedStringSetFlagAttr: " + aname + " not set for " + aval);
}
};
HMLBuilder.prototype.insertNonManual = function(signel, nmstr) {
var aid, aval, chEl, childtag, fullnmtag, i, len, nmEl, ref;
HMLBuilder.trace("HML: insertNonManual: \"" + nmstr + "\"");
if (nmstr.length > 0) {
HMLBuilder.trace("NM: <" + Defs.HNS_NONMAN_TAG + ">");
nmEl = this.newHMLElement(Defs.HNS_NONMAN_TAG);
ref = nmstr.split(/\s+/);
for (i = 0, len = ref.length; i < len; i++) {
fullnmtag = ref[i];
childtag = this._hnsNMElementTag(fullnmtag);
aid = this._hnsNMAttrName(fullnmtag);
aval = this._hnsNMAttrValueFull(fullnmtag);
HMLBuilder.trace("NM: <" + childtag + " " + aid + "=\"" + aval + "\"/>");
chEl = this.newHMLElement(childtag);
this.checkedSetAttr(chEl, aid, aval);
this.checkedAppendChild(nmEl, chEl);
}
HMLBuilder.trace("NM: </" + Defs.HNS_NONMAN_TAG + ">");
signel.insertBefore(nmEl, signel.firstChild);
return HMLBuilder.trace("NM: Inserted");
}
};
HMLBuilder.prototype._hnsNMElementTag = function(nmtag) {
var ID, ei, hnseltag, mgi, nmi, t;
t = (nmtag.charAt(0)).toLowerCase();
if (t === Defs.MOUTH_PICTURE_LETTER) {
return Defs.HNS_MOUTHPICTURE_TAG;
} else {
mgi = Defs.MOUTH_GESTURE_LETTERS.indexOf(t);
if (0 <= mgi) {
hnseltag = Defs.HNS_MOUTHGESTURE_TAG;
} else {
nmi = Defs.NON_MOUTH_RELATED_LETTERS.indexOf(t);
if (0 <= nmi) {
hnseltag = Defs.NON_MOUTH_RELATED_HML_TAGS[nmi];
if (hnseltag === null) {
ID = (nmtag.substring(1)).toUpperCase();
ei = 0;
while (ei < Defs.EYES_TAG_LISTS.length && (Defs.EYES_TAG_LISTS[ei].indexOf(ID)) < 0) {
ei++;
}
if (ei < Defs.EYES_TAG_LISTS.length) {
hnseltag = Defs.EYE_RELATED_HML_TAGS[ei];
} else {
hnseltag = Defs.HNS_EXTRA_TAG;
}
}
} else {
hnseltag = Defs.HNS_EXTRA_TAG;
}
}
return hnseltag;
}
};
HMLBuilder.prototype._hnsNMAttrName = function(nmtag) {
var tagLetter;
tagLetter = (nmtag.charAt(0)).toLowerCase();
if (tagLetter === Defs.MOUTH_PICTURE_LETTER) {
return Defs.PICTURE_ATTR;
} else {
return Defs.TAG_ATTR;
}
};
HMLBuilder.prototype._hnsNMAttrValueFull = function(nmtag) {
var htail, htailU, tlL, tlU;
tlL = (nmtag.charAt(0)).toLowerCase();
tlU = tlL.toUpperCase();
htail = nmtag.substring(1);
htailU = tlL === Defs.MOUTH_PICTURE_LETTER ? null : htail.toUpperCase();
if (tlL === Defs.MOUTH_PICTURE_LETTER) {
return htail;
} else if (0 <= Defs.MOUTH_GESTURE_LETTERS.indexOf(tlL)) {
return "" + tlU + htailU;
} else if (0 <= Defs.NON_MOUTH_RELATED_LETTERS.indexOf(tlL)) {
return htailU;
} else {
return "" + tlU + htailU;
}
};
HMLBuilder.prototype._xmlAttrValueString = function(aval) {
var abuf, ch, i, len, xs;
abuf = "";
for (i = 0, len = aval.length; i < len; i++) {
ch = aval[i];
xs = Defs.xmlSpecials.indexOf(ch);
abuf += xs < 0 ? ch : Defs.xmlEscapes[xs];
}
return abuf;
};
HMLBuilder.setLogLevel = function(lev) {
return logLev = lev;
};
HMLBuilder.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
return HMLBuilder;
})();
cwaenv.add(HMLBuilder, "HMLBuilder");
}).call(this);
//-------- js/Ham4HMLGen.js --------
// $ANTLR 3.3 Nov 30, 2010 12:50:56 Ham4HMLGen.g 2017-05-06 19:33:45
// TreeParser header
var Ham4HMLGen = function(input, state) {
if (!state) {
state = new org.antlr.runtime.RecognizerSharedState();
}
(function(){
// TreeParser members
var hBuilder = null;
var logLev = 0;
this.setLogLevel = function(lev) {
this.logLev = lev;
};
this.trace = function(str) {
if (this.logLev >= 440) {
console.log(str);
}
};
}).call(this);
Ham4HMLGen.superclass.constructor.call(this, input, state);
/* @todo only create adaptor if output=AST */
this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
};
org.antlr.lang.augmentObject(Ham4HMLGen, {
EOF: -1,
WS: 4,
HamTab: 5,
HamLinefeed: 6,
HamPagebreak: 7,
HamReturn: 8,
HamVersion40: 9,
HamSpace: 10,
HamExclaim: 11,
HamQuery: 12,
HamFullstop: 13,
HamComma: 14,
HamPlus: 15,
HamMetaalt: 16,
HamClocku: 17,
HamClockul: 18,
HamClockl: 19,
HamClockdl: 20,
HamClockd: 21,
HamClockdr: 22,
HamClockr: 23,
HamClockur: 24,
HamClockfull: 25,
HamSymmpar: 26,
HamSymmlr: 27,
HamFist: 28,
HamFlathand: 29,
HamFinger2: 30,
HamFinger23: 31,
HamFinger23spread: 32,
HamFinger2345: 33,
HamThumboutmod: 34,
HamThumbacrossmod: 35,
HamPinch12: 36,
HamPinchall: 37,
HamPinch12open: 38,
HamCee12: 39,
HamCeeall: 40,
HamCee12open: 41,
HamThumbopenmod: 42,
HamFingerstraightmod: 43,
HamFingerbendmod: 44,
HamFingerhookedmod: 45,
HamNondominant: 46,
HamDoublebent: 47,
HamDoublehooked: 48,
HamExtfingeru: 49,
HamExtfingerur: 50,
HamExtfingerr: 51,
HamExtfingerdr: 52,
HamExtfingerd: 53,
HamExtfingerdl: 54,
HamExtfingerl: 55,
HamExtfingerul: 56,
HamExtfingerol: 57,
HamExtfingero: 58,
HamExtfingeror: 59,
HamExtfingeril: 60,
HamExtfingeri: 61,
HamExtfingerir: 62,
HamExtfingerui: 63,
HamExtfingerdi: 64,
HamExtfingerdo: 65,
HamExtfingeruo: 66,
HamEarlobe: 67,
HamNostrils: 68,
HamShouldertop: 69,
HamPalmu: 70,
HamPalmur: 71,
HamPalmr: 72,
HamPalmdr: 73,
HamPalmd: 74,
HamPalmdl: 75,
HamPalml: 76,
HamPalmul: 77,
HamReplace: 78,
HamArmextended: 79,
HamBehind: 80,
HamEtc: 81,
HamOrirelative: 82,
HamTongue: 83,
HamTeeth: 84,
HamStomach: 85,
HamNeutralspace: 86,
HamHead: 87,
HamHeadtop: 88,
HamForehead: 89,
HamEyebrows: 90,
HamEyes: 91,
HamNose: 92,
HamEar: 93,
HamCheek: 94,
HamLips: 95,
HamChin: 96,
HamUnderchin: 97,
HamNeck: 98,
HamShoulders: 99,
HamChest: 100,
HamBelowstomach: 101,
HamLrbeside: 102,
HamLrat: 103,
HamUpperarm: 104,
HamElbow: 105,
HamElbowinside: 106,
HamLowerarm: 107,
HamWristback: 108,
HamWristpulse: 109,
HamThumbball: 110,
HamPalm: 111,
HamHandback: 112,
HamThumb: 113,
HamIndexfinger: 114,
HamMiddlefinger: 115,
HamRingfinger: 116,
HamPinky: 117,
HamThumbside: 118,
HamPinkyside: 119,
HamBetween: 120,
HamFingertip: 121,
HamFingernail: 122,
HamFingerpad: 123,
HamFingermidjoint: 124,
HamFingerbase: 125,
HamFingerside: 126,
HamWristtopulse: 127,
HamWristtoback: 128,
HamWristtothumb: 129,
HamWristtopinky: 130,
HamCoreftag: 131,
HamCorefref: 132,
HamNomotion: 133,
HamMoveu: 134,
HamMoveur: 135,
HamMover: 136,
HamMovedr: 137,
HamMoved: 138,
HamMovedl: 139,
HamMovel: 140,
HamMoveul: 141,
HamMoveol: 142,
HamMoveo: 143,
HamMoveor: 144,
HamMoveil: 145,
HamMovei: 146,
HamMoveir: 147,
HamMoveui: 148,
HamMovedi: 149,
HamMovedo: 150,
HamMoveuo: 151,
HamMovecross: 152,
HamMovex: 153,
HamSmallmod: 154,
HamLargemod: 155,
HamArcl: 156,
HamArcu: 157,
HamArcr: 158,
HamArcd: 159,
HamWavy: 160,
HamZigzag: 161,
HamFingerplay: 162,
HamParbegin: 163,
HamParend: 164,
HamCircleo: 165,
HamCirclei: 166,
HamCircled: 167,
HamCircleu: 168,
HamCirclel: 169,
HamCircler: 170,
HamIncreasing: 171,
HamDecreasing: 172,
HamClose: 173,
HamTouch: 174,
HamInterlock: 175,
HamCross: 176,
HamFast: 177,
HamSlow: 178,
HamTense: 179,
HamRest: 180,
HamHalt: 181,
HamRepeatfromstart: 182,
HamRepeatfromstartseveral: 183,
HamRepeatcontinue: 184,
HamRepeatcontinueseveral: 185,
HamSeqbegin: 186,
HamSeqend: 187,
HamAlternatingmotion: 188,
HamRepeatreverse: 189,
HamBrushing: 190,
HamNonipsi: 191,
HamEllipseh: 192,
HamEllipseur: 193,
HamEllipsev: 194,
HamEllipseul: 195,
HamMime: 196,
HamAltbegin: 197,
HamAltend: 198,
HamNodding: 199,
HamSwinging: 200,
HamTwisting: 201,
HamStircw: 202,
HamStirccw: 203,
HamFusionbegin: 204,
HamFusionend: 205,
HamCircleul: 206,
HamCircledr: 207,
HamCircleur: 208,
HamCircledl: 209,
HamCircleol: 210,
HamCircleir: 211,
HamCircleor: 212,
HamCircleil: 213,
HamCircledo: 214,
HamCircleui: 215,
HamCircledi: 216,
HamCircleuo: 217,
HamNbs: 218,
HAMSIGNS: 219,
SIGN2: 220,
SIGN1: 221,
ICFG2: 222,
ICFG1: 223,
NMICLIST: 224,
NMICUNIT: 225,
MICFG2: 226,
MICFG1: 227,
HDCONFIG2: 228,
HDCONFIG1: 229,
SPLITHDCFG2: 230,
HDCFGTAIL2: 231,
HSHAPE2: 232,
HSHAPE1: 233,
BASICHDSHP1: 234,
BASICHDSHP: 235,
HSCLASS: 236,
FIBENDING: 237,
THUMBPOS: 238,
FINGERLIST: 239,
FISHPLIST: 240,
FICRSSLIST: 241,
FSHAPE: 242,
FCROSSING: 243,
THSPECIAL: 244,
EXTFIDIR2: 245,
EXTFIDIR1: 246,
EXTFIDIR: 247,
PALMOR2: 248,
PALMOR1: 249,
LOC2: 250,
LOC1: 251,
LOCTNBODYARM: 252,
LOCTNBODY: 253,
LOCTNHAND: 254,
LOCTNARM: 255,
LEVBODY: 256,
LEVHAND: 257,
LEVARM: 258,
HCONSTLLN: 259,
CNTCTBODY: 260,
CNTCTHAND: 261,
CNTCTOFHAND: 262,
A2TLIST: 263,
A1TLIST: 264,
A1LIST: 265,
ACTION2T: 266,
ACTION1T: 267,
ACTION2: 268,
ACTION1: 269,
PARACT2T: 270,
SEQACT2T: 271,
SPLITACT2LOC2: 272,
SPLITACT2T: 273,
PARACT1T: 274,
SEQACT1T: 275,
NMACT1T: 276,
PARACT1: 277,
REPETITIONS: 278,
SIMPLEMVMT: 279,
STRGHTMVMT: 280,
CRCLRMVMT: 281,
REPLACE: 282,
SPLITREPLACETL: 283,
REPLACETAIL1: 284,
HSFINGERITEM: 285,
LOCBODY: 286,
MOVINGREPETITION: 287,
SEQACT1: 288,
SEQFUSEDACT2T: 289,
SEQFUSEDACT1T: 290,
SEQFUSEDACT1: 291,
CNTCTOHHAND: 292,
CNTCTOHARM: 293
});
(function(){
// public class variables
var EOF= -1,
WS= 4,
HamTab= 5,
HamLinefeed= 6,
HamPagebreak= 7,
HamReturn= 8,
HamVersion40= 9,
HamSpace= 10,
HamExclaim= 11,
HamQuery= 12,
HamFullstop= 13,
HamComma= 14,
HamPlus= 15,
HamMetaalt= 16,
HamClocku= 17,
HamClockul= 18,
HamClockl= 19,
HamClockdl= 20,
HamClockd= 21,
HamClockdr= 22,
HamClockr= 23,
HamClockur= 24,
HamClockfull= 25,
HamSymmpar= 26,
HamSymmlr= 27,
HamFist= 28,
HamFlathand= 29,
HamFinger2= 30,
HamFinger23= 31,
HamFinger23spread= 32,
HamFinger2345= 33,
HamThumboutmod= 34,
HamThumbacrossmod= 35,
HamPinch12= 36,
HamPinchall= 37,
HamPinch12open= 38,
HamCee12= 39,
HamCeeall= 40,
HamCee12open= 41,
HamThumbopenmod= 42,
HamFingerstraightmod= 43,
HamFingerbendmod= 44,
HamFingerhookedmod= 45,
HamNondominant= 46,
HamDoublebent= 47,
HamDoublehooked= 48,
HamExtfingeru= 49,
HamExtfingerur= 50,
HamExtfingerr= 51,
HamExtfingerdr= 52,
HamExtfingerd= 53,
HamExtfingerdl= 54,
HamExtfingerl= 55,
HamExtfingerul= 56,
HamExtfingerol= 57,
HamExtfingero= 58,
HamExtfingeror= 59,
HamExtfingeril= 60,
HamExtfingeri= 61,
HamExtfingerir= 62,
HamExtfingerui= 63,
HamExtfingerdi= 64,
HamExtfingerdo= 65,
HamExtfingeruo= 66,
HamEarlobe= 67,
HamNostrils= 68,
HamShouldertop= 69,
HamPalmu= 70,
HamPalmur= 71,
HamPalmr= 72,
HamPalmdr= 73,
HamPalmd= 74,
HamPalmdl= 75,
HamPalml= 76,
HamPalmul= 77,
HamReplace= 78,
HamArmextended= 79,
HamBehind= 80,
HamEtc= 81,
HamOrirelative= 82,
HamTongue= 83,
HamTeeth= 84,
HamStomach= 85,
HamNeutralspace= 86,
HamHead= 87,
HamHeadtop= 88,
HamForehead= 89,
HamEyebrows= 90,
HamEyes= 91,
HamNose= 92,
HamEar= 93,
HamCheek= 94,
HamLips= 95,
HamChin= 96,
HamUnderchin= 97,
HamNeck= 98,
HamShoulders= 99,
HamChest= 100,
HamBelowstomach= 101,
HamLrbeside= 102,
HamLrat= 103,
HamUpperarm= 104,
HamElbow= 105,
HamElbowinside= 106,
HamLowerarm= 107,
HamWristback= 108,
HamWristpulse= 109,
HamThumbball= 110,
HamPalm= 111,
HamHandback= 112,
HamThumb= 113,
HamIndexfinger= 114,
HamMiddlefinger= 115,
HamRingfinger= 116,
HamPinky= 117,
HamThumbside= 118,
HamPinkyside= 119,
HamBetween= 120,
HamFingertip= 121,
HamFingernail= 122,
HamFingerpad= 123,
HamFingermidjoint= 124,
HamFingerbase= 125,
HamFingerside= 126,
HamWristtopulse= 127,
HamWristtoback= 128,
HamWristtothumb= 129,
HamWristtopinky= 130,
HamCoreftag= 131,
HamCorefref= 132,
HamNomotion= 133,
HamMoveu= 134,
HamMoveur= 135,
HamMover= 136,
HamMovedr= 137,
HamMoved= 138,
HamMovedl= 139,
HamMovel= 140,
HamMoveul= 141,
HamMoveol= 142,
HamMoveo= 143,
HamMoveor= 144,
HamMoveil= 145,
HamMovei= 146,
HamMoveir= 147,
HamMoveui= 148,
HamMovedi= 149,
HamMovedo= 150,
HamMoveuo= 151,
HamMovecross= 152,
HamMovex= 153,
HamSmallmod= 154,
HamLargemod= 155,
HamArcl= 156,
HamArcu= 157,
HamArcr= 158,
HamArcd= 159,
HamWavy= 160,
HamZigzag= 161,
HamFingerplay= 162,
HamParbegin= 163,
HamParend= 164,
HamCircleo= 165,
HamCirclei= 166,
HamCircled= 167,
HamCircleu= 168,
HamCirclel= 169,
HamCircler= 170,
HamIncreasing= 171,
HamDecreasing= 172,
HamClose= 173,
HamTouch= 174,
HamInterlock= 175,
HamCross= 176,
HamFast= 177,
HamSlow= 178,
HamTense= 179,
HamRest= 180,
HamHalt= 181,
HamRepeatfromstart= 182,
HamRepeatfromstartseveral= 183,
HamRepeatcontinue= 184,
HamRepeatcontinueseveral= 185,
HamSeqbegin= 186,
HamSeqend= 187,
HamAlternatingmotion= 188,
HamRepeatreverse= 189,
HamBrushing= 190,
HamNonipsi= 191,
HamEllipseh= 192,
HamEllipseur= 193,
HamEllipsev= 194,
HamEllipseul= 195,
HamMime= 196,
HamAltbegin= 197,
HamAltend= 198,
HamNodding= 199,
HamSwinging= 200,
HamTwisting= 201,
HamStircw= 202,
HamStirccw= 203,
HamFusionbegin= 204,
HamFusionend= 205,
HamCircleul= 206,
HamCircledr= 207,
HamCircleur= 208,
HamCircledl= 209,
HamCircleol= 210,
HamCircleir= 211,
HamCircleor= 212,
HamCircleil= 213,
HamCircledo= 214,
HamCircleui= 215,
HamCircledi= 216,
HamCircleuo= 217,
HamNbs= 218,
HAMSIGNS= 219,
SIGN2= 220,
SIGN1= 221,
ICFG2= 222,
ICFG1= 223,
NMICLIST= 224,
NMICUNIT= 225,
MICFG2= 226,
MICFG1= 227,
HDCONFIG2= 228,
HDCONFIG1= 229,
SPLITHDCFG2= 230,
HDCFGTAIL2= 231,
HSHAPE2= 232,
HSHAPE1= 233,
BASICHDSHP1= 234,
BASICHDSHP= 235,
HSCLASS= 236,
FIBENDING= 237,
THUMBPOS= 238,
FINGERLIST= 239,
FISHPLIST= 240,
FICRSSLIST= 241,
FSHAPE= 242,
FCROSSING= 243,
THSPECIAL= 244,
EXTFIDIR2= 245,
EXTFIDIR1= 246,
EXTFIDIR= 247,
PALMOR2= 248,
PALMOR1= 249,
LOC2= 250,
LOC1= 251,
LOCTNBODYARM= 252,
LOCTNBODY= 253,
LOCTNHAND= 254,
LOCTNARM= 255,
LEVBODY= 256,
LEVHAND= 257,
LEVARM= 258,
HCONSTLLN= 259,
CNTCTBODY= 260,
CNTCTHAND= 261,
CNTCTOFHAND= 262,
A2TLIST= 263,
A1TLIST= 264,
A1LIST= 265,
ACTION2T= 266,
ACTION1T= 267,
ACTION2= 268,
ACTION1= 269,
PARACT2T= 270,
SEQACT2T= 271,
SPLITACT2LOC2= 272,
SPLITACT2T= 273,
PARACT1T= 274,
SEQACT1T= 275,
NMACT1T= 276,
PARACT1= 277,
REPETITIONS= 278,
SIMPLEMVMT= 279,
STRGHTMVMT= 280,
CRCLRMVMT= 281,
REPLACE= 282,
SPLITREPLACETL= 283,
REPLACETAIL1= 284,
HSFINGERITEM= 285,
LOCBODY= 286,
MOVINGREPETITION= 287,
SEQACT1= 288,
SEQFUSEDACT2T= 289,
SEQFUSEDACT1T= 290,
SEQFUSEDACT1= 291,
CNTCTOHHAND= 292,
CNTCTOHARM= 293;
var UP = org.antlr.runtime.Token.UP,
DOWN = org.antlr.runtime.Token.DOWN;
// public instance methods/vars
org.antlr.lang.extend(Ham4HMLGen, org.antlr.runtime.tree.TreeParser, {
getTokenNames: function() { return Ham4HMLGen.tokenNames; },
getGrammarFileName: function() { return "Ham4HMLGen.g"; }
});
org.antlr.lang.augmentObject(Ham4HMLGen.prototype, {
// Ham4HMLGen.g:45:1: hamsignseq[sb] returns [Element r = null] : ^( HAMSIGNS (s2or1= sign2or1 )* ) ;
// $ANTLR start "hamsignseq"
hamsignseq: function(sb) {
var r =  null;
var s2or1 = null;
// this.hBuilder = sb;     // Instance variable initialisation.
hBuilder = sb;     // Instance variable initialisation.
var     hss     = hBuilder.newHMLElement("hamnosys_sign");
//	Element     s2or1   = null
try {
// Ham4HMLGen.g:56:5: ( ^( HAMSIGNS (s2or1= sign2or1 )* ) )
// Ham4HMLGen.g:57:2: ^( HAMSIGNS (s2or1= sign2or1 )* )
this.match(this.input,HAMSIGNS,Ham4HMLGen.FOLLOW_HAMSIGNS_in_hamsignseq145); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:58:3: (s2or1= sign2or1 )*
loop1:
do {
var alt1=2;
var LA1_0 = this.input.LA(1);
if ( ((LA1_0>=SIGN2 && LA1_0<=SIGN1)) ) {
alt1=1;
}
switch (alt1) {
case 1 :
// Ham4HMLGen.g:59:4: s2or1= sign2or1
this.pushFollow(Ham4HMLGen.FOLLOW_sign2or1_in_hamsignseq160);
s2or1=this.sign2or1();
this.state._fsp--;
hss.appendChild(s2or1); 
break;
default :
break loop1;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
r = hBuilder.rootEl(hss);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return r;
},
// Ham4HMLGen.g:70:1: sign2or1 returns [Element rsgn = null] : (rsgn1= sign2 | rsgn2= nondomsign1 ) ;
// $ANTLR start "sign2or1"
sign2or1: function() {
var rsgn =  null;
var rsgn1 = null;
var rsgn2 = null;
try {
// Ham4HMLGen.g:74:5: ( (rsgn1= sign2 | rsgn2= nondomsign1 ) )
// Ham4HMLGen.g:75:5: (rsgn1= sign2 | rsgn2= nondomsign1 )
// Ham4HMLGen.g:75:5: (rsgn1= sign2 | rsgn2= nondomsign1 )
var alt2=2;
var LA2_0 = this.input.LA(1);
if ( (LA2_0==SIGN2) ) {
alt2=1;
}
else if ( (LA2_0==SIGN1) ) {
alt2=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 2, 0, this.input);
throw nvae;
}
switch (alt2) {
case 1 :
// Ham4HMLGen.g:76:9: rsgn1= sign2
this.pushFollow(Ham4HMLGen.FOLLOW_sign2_in_sign2or1242);
rsgn1=this.sign2();
this.state._fsp--;
rsgn = rsgn1; 
break;
case 2 :
// Ham4HMLGen.g:78:9: rsgn2= nondomsign1
this.pushFollow(Ham4HMLGen.FOLLOW_nondomsign1_in_sign2or1269);
rsgn2=this.nondomsign1();
this.state._fsp--;
rsgn = rsgn2; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:82:1: sign2 returns [Element rsgn = null] : ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) ) ;
// $ANTLR start "sign2"
sign2: function() {
var rsgn =  null;
var sym = null;
var icpair = null;
var atlst = null;
var     holdover    = false;
var     nondominant = false;
try {
// Ham4HMLGen.g:89:5: ( ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) ) )
// Ham4HMLGen.g:90:5: ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) )
this.match(this.input,SIGN2,Ham4HMLGen.FOLLOW_SIGN2_in_sign2320); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:91:9: (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar )
var alt4=3;
switch ( this.input.LA(1) ) {
case HamSymmpar:
case HamSymmlr:
alt4=1;
break;
case ICFG2:
alt4=2;
break;
case HamNomotion:
alt4=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);
throw nvae;
}
switch (alt4) {
case 1 :
// Ham4HMLGen.g:92:13: sym= symmoperator icpair= initialconfig2 atlst= a2tstar
this.pushFollow(Ham4HMLGen.FOLLOW_symmoperator_in_sign2352);
sym=this.symmoperator();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig2_in_sign2371);
icpair=this.initialconfig2();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a2tstar_in_sign2391);
atlst=this.a2tstar();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:96:13: icpair= initialconfig2 atlst= a1tstar
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig2_in_sign2420);
icpair=this.initialconfig2();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_sign2440);
atlst=this.a1tstar();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:100:13: HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar
this.match(this.input,HamNomotion,Ham4HMLGen.FOLLOW_HamNomotion_in_sign2477); 
holdover = true; 
// Ham4HMLGen.g:101:13: ( HamNondominant )?
var alt3=2;
var LA3_0 = this.input.LA(1);
if ( (LA3_0==HamNondominant) ) {
alt3=1;
}
switch (alt3) {
case 1 :
// Ham4HMLGen.g:101:15: HamNondominant
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_sign2511); 
nondominant = true; 
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig1_in_sign2546);
icpair=this.initialconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_sign2566);
atlst=this.a1tstar();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsgn = hBuilder.newHMLElement("sign2");
hBuilder.checkedAppendChild(rsgn, sym);
hBuilder.checkedAppendChild(rsgn, icpair[0]);
hBuilder.checkedAppendChild(rsgn, icpair[1]);
hBuilder.checkedAppendChildList(rsgn, atlst);
hBuilder.checkedSetFlagAttr(rsgn, "nondominant", nondominant);
hBuilder.checkedSetFlagAttr(rsgn, "holdover", holdover);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:117:1: nondomsign1 returns [Element rsgn = null] : ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar ) ;
// $ANTLR start "nondomsign1"
nondomsign1: function() {
var rsgn =  null;
var icpair = null;
var atlst = null;
try {
// Ham4HMLGen.g:121:5: ( ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar ) )
// Ham4HMLGen.g:122:5: ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar )
this.match(this.input,SIGN1,Ham4HMLGen.FOLLOW_SIGN1_in_nondomsign1620); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_nondomsign1640); 
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig1_in_nondomsign1655);
icpair=this.initialconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_nondomsign1671);
atlst=this.a1tstar();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsgn = hBuilder.newHMLElement("sign1");
hBuilder.checkedSetAttr(rsgn, "which_hand", "nondominant");
hBuilder.checkedAppendChild(rsgn, icpair[0]);
rsgn.appendChild(icpair[1]);
hBuilder.appendChildList(rsgn, atlst);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:136:1: symmoperator returns [Element rsym = null] : ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ) ;
// $ANTLR start "symmoperator"
symmoperator: function() {
var rsym =  null;
var  plr = null;
var  lg  = null;
var  fb  = null;
var alt = false;
var ni  = false;
try {
// Ham4HMLGen.g:146:5: ( ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ) )
// Ham4HMLGen.g:147:5: ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4HMLGen.g:147:5: ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4HMLGen.g:148:9: ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )?
// Ham4HMLGen.g:148:9: ( HamSymmpar | HamSymmlr )
var alt5=2;
var LA5_0 = this.input.LA(1);
if ( (LA5_0==HamSymmpar) ) {
alt5=1;
}
else if ( (LA5_0==HamSymmlr) ) {
alt5=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 5, 0, this.input);
throw nvae;
}
switch (alt5) {
case 1 :
// Ham4HMLGen.g:149:13: HamSymmpar
this.match(this.input,HamSymmpar,Ham4HMLGen.FOLLOW_HamSymmpar_in_symmoperator741); 
plr = "hamsymmpar"; 
break;
case 2 :
// Ham4HMLGen.g:151:13: HamSymmlr
this.match(this.input,HamSymmlr,Ham4HMLGen.FOLLOW_HamSymmlr_in_symmoperator776); 
plr = "hamsymmlr"; 
break;
}
// Ham4HMLGen.g:153:9: ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )?
var alt8=3;
var LA8_0 = this.input.LA(1);
if ( (LA8_0==HamLargemod) ) {
alt8=1;
}
else if ( (LA8_0==HamFingerstraightmod) ) {
alt8=2;
}
switch (alt8) {
case 1 :
// Ham4HMLGen.g:154:13: ( HamLargemod ) ( HamFingerstraightmod )?
// Ham4HMLGen.g:154:13: ( HamLargemod )
// Ham4HMLGen.g:154:15: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_symmoperator824); 
lg = "hamlargemod"; 
// Ham4HMLGen.g:155:13: ( HamFingerstraightmod )?
var alt6=2;
var LA6_0 = this.input.LA(1);
if ( (LA6_0==HamFingerstraightmod) ) {
alt6=1;
}
switch (alt6) {
case 1 :
// Ham4HMLGen.g:155:15: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_symmoperator859); 
fb = "hamfingerbent"; 
break;
}
break;
case 2 :
// Ham4HMLGen.g:157:13: ( HamFingerstraightmod ) ( HamLargemod )?
// Ham4HMLGen.g:157:13: ( HamFingerstraightmod )
// Ham4HMLGen.g:157:15: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_symmoperator893); 
fb = "hamfingerbent"; 
// Ham4HMLGen.g:158:13: ( HamLargemod )?
var alt7=2;
var LA7_0 = this.input.LA(1);
if ( (LA7_0==HamLargemod) ) {
alt7=1;
}
switch (alt7) {
case 1 :
// Ham4HMLGen.g:158:15: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_symmoperator916); 
lg = "hamlargemod"; 
break;
}
break;
}
// Ham4HMLGen.g:160:9: ( HamAlternatingmotion )?
var alt9=2;
var LA9_0 = this.input.LA(1);
if ( (LA9_0==HamAlternatingmotion) ) {
alt9=1;
}
switch (alt9) {
case 1 :
// Ham4HMLGen.g:160:13: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_symmoperator961); 
alt= true; 
break;
}
// Ham4HMLGen.g:161:9: ( HamNonipsi )?
var alt10=2;
var LA10_0 = this.input.LA(1);
if ( (LA10_0==HamNonipsi) ) {
alt10=1;
}
switch (alt10) {
case 1 :
// Ham4HMLGen.g:161:13: HamNonipsi
this.match(this.input,HamNonipsi,Ham4HMLGen.FOLLOW_HamNonipsi_in_symmoperator983); 
ni = true; 
break;
}
rsym = hBuilder.newHMLElement("symmoperator");
hBuilder.checkedSetAttr(rsym, "att_par_or_lr", plr);
hBuilder.checkedSetAttr(rsym, "attrib_oi_symm", fb);
hBuilder.checkedSetAttr(rsym, "attrib_ud_symm", lg);
hBuilder.checkedSetFlagAttr(rsym, "outofphase", alt);
hBuilder.checkedSetFlagAttr(rsym, "nonipsi", ni);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsym;
},
// Ham4HMLGen.g:176:1: initialconfig2 returns [Element[] ricpair] : ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 ) ;
// $ANTLR start "initialconfig2"
initialconfig2: function() {
var ricpair = null;
var nmic = null;
var mic = null;
try {
// Ham4HMLGen.g:181:5: ( ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 ) )
// Ham4HMLGen.g:182:5: ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 )
this.match(this.input,ICFG2,Ham4HMLGen.FOLLOW_ICFG2_in_initialconfig21044); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:183:9: (nmic= nminitialconfig )?
var alt11=2;
var LA11_0 = this.input.LA(1);
if ( (LA11_0==NMICLIST) ) {
alt11=1;
}
switch (alt11) {
case 1 :
// Ham4HMLGen.g:183:11: nmic= nminitialconfig
this.pushFollow(Ham4HMLGen.FOLLOW_nminitialconfig_in_initialconfig21061);
nmic=this.nminitialconfig();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_minitialconfig2_in_initialconfig21082);
mic=this.minitialconfig2();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ricpair = [nmic, mic];
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ricpair;
},
// Ham4HMLGen.g:191:1: initialconfig1 returns [Element[] ricpair] : ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 ) ;
// $ANTLR start "initialconfig1"
initialconfig1: function() {
var ricpair = null;
var nmic = null;
var mic = null;
try {
// Ham4HMLGen.g:196:5: ( ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 ) )
// Ham4HMLGen.g:197:5: ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 )
this.match(this.input,ICFG1,Ham4HMLGen.FOLLOW_ICFG1_in_initialconfig11123); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:198:9: (nmic= nminitialconfig )?
var alt12=2;
var LA12_0 = this.input.LA(1);
if ( (LA12_0==NMICLIST) ) {
alt12=1;
}
switch (alt12) {
case 1 :
// Ham4HMLGen.g:198:11: nmic= nminitialconfig
this.pushFollow(Ham4HMLGen.FOLLOW_nminitialconfig_in_initialconfig11140);
nmic=this.nminitialconfig();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_minitialconfig1_in_initialconfig11161);
mic=this.minitialconfig1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ricpair = [nmic, mic];
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ricpair;
},
// Ham4HMLGen.g:206:1: nminitialconfig returns [Element rnmic = null] : ^( NMICLIST (nmpair= nmicunit )+ ) ;
// $ANTLR start "nminitialconfig"
nminitialconfig: function() {
var rnmic =  null;
var nmpair = null;
rnmic = hBuilder.newHMLElement("nminitialconfig");
try {
// Ham4HMLGen.g:212:5: ( ^( NMICLIST (nmpair= nmicunit )+ ) )
// Ham4HMLGen.g:213:5: ^( NMICLIST (nmpair= nmicunit )+ )
this.match(this.input,NMICLIST,Ham4HMLGen.FOLLOW_NMICLIST_in_nminitialconfig1209); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:214:9: (nmpair= nmicunit )+
var cnt13=0;
loop13:
do {
var alt13=2;
var LA13_0 = this.input.LA(1);
if ( (LA13_0==NMICUNIT) ) {
alt13=1;
}
switch (alt13) {
case 1 :
// Ham4HMLGen.g:215:13: nmpair= nmicunit
this.pushFollow(Ham4HMLGen.FOLLOW_nmicunit_in_nminitialconfig1238);
nmpair=this.nmicunit();
this.state._fsp--;
rnmic.appendChild(nmpair[0]);
rnmic.appendChild(nmpair[1]);
break;
default :
if ( cnt13 >= 1 ) {
break loop13;
}
var eee = new org.antlr.runtime.EarlyExitException(13, this.input);
throw eee;
}
cnt13++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnmic;
},
// Ham4HMLGen.g:224:1: nmicunit returns [Element[] rnmpair = [null,null]] : ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 ) ;
// $ANTLR start "nmicunit"
nmicunit: function() {
var rnmpair =  [null,null];
var nma = null;
var nmb = null;
try {
// Ham4HMLGen.g:230:5: ( ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 ) )
// Ham4HMLGen.g:231:5: ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 )
this.match(this.input,NMICUNIT,Ham4HMLGen.FOLLOW_NMICUNIT_in_nmicunit1304); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:232:9: (nma= levelbody | nma= levelarm )
var alt14=2;
var LA14_0 = this.input.LA(1);
if ( (LA14_0==LEVBODY) ) {
alt14=1;
}
else if ( (LA14_0==LEVARM) ) {
alt14=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 14, 0, this.input);
throw nvae;
}
switch (alt14) {
case 1 :
// Ham4HMLGen.g:233:13: nma= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_nmicunit1332);
nma=this.levelbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:235:13: nma= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_nmicunit1361);
nma=this.levelarm();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_nmicunit1385);
nmb=this.action1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rnmpair[0] = nma;
rnmpair[1] = nmb;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnmpair;
},
// Ham4HMLGen.g:245:1: minitialconfig2 returns [Element rmic = null] : ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) ) ;
// $ANTLR start "minitialconfig2"
minitialconfig2: function() {
var rmic =  null;
var hc2 = null;
var loc2 = null;
var hc1 = null;
var l1dom = null;
var l1sub = null;
try {
// Ham4HMLGen.g:248:5: ( ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) ) )
// Ham4HMLGen.g:249:5: ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) )
this.match(this.input,MICFG2,Ham4HMLGen.FOLLOW_MICFG2_in_minitialconfig21425); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:250:9: (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? )
var alt18=2;
var LA18_0 = this.input.LA(1);
if ( (LA18_0==HDCONFIG2) ) {
alt18=1;
}
else if ( (LA18_0==HDCONFIG1) ) {
alt18=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 18, 0, this.input);
throw nvae;
}
switch (alt18) {
case 1 :
// Ham4HMLGen.g:251:13: hc2= handconfig2 (loc2= location2 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig2_in_minitialconfig21457);
hc2=this.handconfig2();
this.state._fsp--;
// Ham4HMLGen.g:252:13: (loc2= location2 )?
var alt15=2;
var LA15_0 = this.input.LA(1);
if ( (LA15_0==LOC2) ) {
alt15=1;
}
switch (alt15) {
case 1 :
// Ham4HMLGen.g:252:15: loc2= location2
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_minitialconfig21478);
loc2=this.location2();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:254:13: hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_minitialconfig21513);
hc1=this.handconfig1();
this.state._fsp--;
// Ham4HMLGen.g:255:13: (l1dom= location1 )?
var alt16=2;
var LA16_0 = this.input.LA(1);
if ( (LA16_0==LOC1) ) {
alt16=1;
}
switch (alt16) {
case 1 :
// Ham4HMLGen.g:255:15: l1dom= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig21533);
l1dom=this.location1();
this.state._fsp--;
break;
}
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_minitialconfig21560); 
// Ham4HMLGen.g:257:13: (l1sub= location1 )?
var alt17=2;
var LA17_0 = this.input.LA(1);
if ( (LA17_0==LOC1) ) {
alt17=1;
}
switch (alt17) {
case 1 :
// Ham4HMLGen.g:257:15: l1sub= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig21580);
l1sub=this.location1();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (hc2 == null) {
hc2 = hBuilder.newHMLElement("handconfig2");
hc2.appendChild(hc1);
loc2 = hBuilder.newHMLElement("location2");
hBuilder.checkedAppendChild(loc2, l1dom);  // ???? valid?
hBuilder.checkedAppendChild(loc2, l1sub);  // ???? valid?
}
rmic = hBuilder.newHMLElement("minitialconfig2");
rmic.appendChild(hc2);
hBuilder.checkedAppendChild(rmic, loc2);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmic;
},
// Ham4HMLGen.g:274:1: minitialconfig1 returns [Element rmic = null] : ^( MICFG1 hc1= handconfig1 (loc1= location1 )? ) ;
// $ANTLR start "minitialconfig1"
minitialconfig1: function() {
var rmic =  null;
var hc1 = null;
var loc1 = null;
try {
// Ham4HMLGen.g:277:5: ( ^( MICFG1 hc1= handconfig1 (loc1= location1 )? ) )
// Ham4HMLGen.g:278:5: ^( MICFG1 hc1= handconfig1 (loc1= location1 )? )
this.match(this.input,MICFG1,Ham4HMLGen.FOLLOW_MICFG1_in_minitialconfig11633); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_minitialconfig11651);
hc1=this.handconfig1();
this.state._fsp--;
// Ham4HMLGen.g:280:9: (loc1= location1 )?
var alt19=2;
var LA19_0 = this.input.LA(1);
if ( (LA19_0==LOC1) ) {
alt19=1;
}
switch (alt19) {
case 1 :
// Ham4HMLGen.g:280:11: loc1= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig11668);
loc1=this.location1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rmic = hBuilder.newHMLElement("minitialconfig1");
rmic.appendChild(hc1);
hBuilder.checkedAppendChild(rmic, loc1);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmic;
},
// Ham4HMLGen.g:292:1: handconfig2 returns [Element rhc = null] : ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) ) ;
// $ANTLR start "handconfig2"
handconfig2: function() {
var rhc =  null;
var hs2 = null;
var tailpair = null;
var shc = null;
try {
// Ham4HMLGen.g:295:5: ( ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) ) )
// Ham4HMLGen.g:296:5: ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) )
this.match(this.input,HDCONFIG2,Ham4HMLGen.FOLLOW_HDCONFIG2_in_handconfig21718); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:297:9: (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 )
var alt21=2;
var LA21_0 = this.input.LA(1);
if ( (LA21_0==HSHAPE2) ) {
alt21=1;
}
else if ( (LA21_0==SPLITHDCFG2) ) {
alt21=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 21, 0, this.input);
throw nvae;
}
switch (alt21) {
case 1 :
// Ham4HMLGen.g:298:13: hs2= handshape2 (tailpair= handconfigtail2 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handshape2_in_handconfig21754);
hs2=this.handshape2();
this.state._fsp--;
// Ham4HMLGen.g:299:13: (tailpair= handconfigtail2 )?
var alt20=2;
var LA20_0 = this.input.LA(1);
if ( (LA20_0==HDCFGTAIL2) ) {
alt20=1;
}
switch (alt20) {
case 1 :
// Ham4HMLGen.g:299:15: tailpair= handconfigtail2
this.pushFollow(Ham4HMLGen.FOLLOW_handconfigtail2_in_handconfig21775);
tailpair=this.handconfigtail2();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:301:13: shc= splithandconfig2
this.pushFollow(Ham4HMLGen.FOLLOW_splithandconfig2_in_handconfig21814);
shc=this.splithandconfig2();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = shc;
if (rhc == null) {
rhc = hBuilder.newHMLElement("handconfig2");
rhc.appendChild(hs2);
if (tailpair != null) {
rhc.appendChild(tailpair[0]);   // efd2
rhc.appendChild(tailpair[1]);   // po2
}
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:318:1: handconfig1 returns [Element rhc = null] : ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? ) ;
// $ANTLR start "handconfig1"
handconfig1: function() {
var rhc =  null;
var hs = null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:321:5: ( ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? ) )
// Ham4HMLGen.g:322:5: ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? )
this.match(this.input,HDCONFIG1,Ham4HMLGen.FOLLOW_HDCONFIG1_in_handconfig11868); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handconfig11887);
hs=this.handshape1();
this.state._fsp--;
// Ham4HMLGen.g:324:9: (efd= extfidir1 )?
var alt22=2;
var LA22_0 = this.input.LA(1);
if ( (LA22_0==EXTFIDIR1) ) {
alt22=1;
}
switch (alt22) {
case 1 :
// Ham4HMLGen.g:324:11: efd= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfig11905);
efd=this.extfidir1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:325:9: (po= palmor1 )?
var alt23=2;
var LA23_0 = this.input.LA(1);
if ( (LA23_0==PALMOR1) ) {
alt23=1;
}
switch (alt23) {
case 1 :
// Ham4HMLGen.g:325:11: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfig11927);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconfig1");
rhc.appendChild(hs);
hBuilder.checkedAppendChild(rhc, efd);
hBuilder.checkedAppendChild(rhc, po);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:336:1: splithandconfig2 returns [Element rhc = null] : ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 ) ;
// $ANTLR start "splithandconfig2"
splithandconfig2: function() {
var rhc =  null;
var hcdom = null;
var hcnd = null;
try {
// Ham4HMLGen.g:339:5: ( ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 ) )
// Ham4HMLGen.g:340:5: ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 )
this.match(this.input,SPLITHDCFG2,Ham4HMLGen.FOLLOW_SPLITHDCFG2_in_splithandconfig21982); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_splithandconfig21998);
hcdom=this.handconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_splithandconfig22014);
hcnd=this.handconfig1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconfig2");
rhc.appendChild(hcdom);
rhc.appendChild(hcnd);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:351:1: handconfigtail2 returns [Element[] rtlpair = [null,null]] : ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) ) ;
// $ANTLR start "handconfigtail2"
handconfigtail2: function() {
var rtlpair =  [null,null];
var tmp = null;
var efd1d = null;
var po1d = null;
var efd1s = null;
var po1s = null;
try {
// Ham4HMLGen.g:356:5: ( ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) ) )
// Ham4HMLGen.g:357:5: ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) )
this.match(this.input,HDCFGTAIL2,Ham4HMLGen.FOLLOW_HDCFGTAIL2_in_handconfigtail22058); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:358:9: (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 )
var alt24=2;
var LA24_0 = this.input.LA(1);
if ( (LA24_0==EXTFIDIR2) ) {
alt24=1;
}
else if ( (LA24_0==EXTFIDIR1) ) {
alt24=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);
throw nvae;
}
switch (alt24) {
case 1 :
// Ham4HMLGen.g:359:13: tmp= extfidir2 tmp= palmor2
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir2_in_handconfigtail22092);
tmp=this.extfidir2();
this.state._fsp--;
rtlpair[0] = tmp; 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor2_in_handconfigtail22124);
tmp=this.palmor2();
this.state._fsp--;
rtlpair[1] = tmp; 
break;
case 2 :
// Ham4HMLGen.g:362:13: efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfigtail22166);
efd1d=this.extfidir1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfigtail22189);
po1d=this.palmor1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfigtail22211);
efd1s=this.extfidir1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfigtail22234);
po1s=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (efd1d != null) {
rtlpair[0]  =  hBuilder.newHMLElement("extfidir2");
rtlpair[0].appendChild(efd1d);
rtlpair[0].appendChild(efd1s);
rtlpair[1]  =  hBuilder.newHMLElement("palmor2");
rtlpair[1].appendChild(po1d);
rtlpair[1].appendChild(po1s);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rtlpair;
},
// Ham4HMLGen.g:385:1: handshape2 returns [Element rhs = null] : ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? ) ;
// $ANTLR start "handshape2"
handshape2: function() {
var rhs =  null;
var hsa = null;
var hsb = null;
try {
// Ham4HMLGen.g:388:5: ( ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? ) )
// Ham4HMLGen.g:389:5: ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? )
this.match(this.input,HSHAPE2,Ham4HMLGen.FOLLOW_HSHAPE2_in_handshape22292); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handshape22310);
hsa=this.handshape1();
this.state._fsp--;
// Ham4HMLGen.g:391:9: (hsb= handshape1 )?
var alt25=2;
var LA25_0 = this.input.LA(1);
if ( (LA25_0==HSHAPE1) ) {
alt25=1;
}
switch (alt25) {
case 1 :
// Ham4HMLGen.g:391:11: hsb= handshape1
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handshape22328);
hsb=this.handshape1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhs = hBuilder.newHMLElement("handshape2");
rhs.appendChild(hsa);
hBuilder.checkedAppendChild(rhs, hsb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhs;
},
// Ham4HMLGen.g:400:1: handshape1 returns [Element rhs = null] : ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? ) ;
// $ANTLR start "handshape1"
handshape1: function() {
var rhs =  null;
var attr24 = null;
var fnglst = null;
var fshlst = null;
var fcrlst = null;
var thspc = null;
try {
// Ham4HMLGen.g:403:5: ( ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? ) )
// Ham4HMLGen.g:404:5: ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? )
this.match(this.input,HSHAPE1,Ham4HMLGen.FOLLOW_HSHAPE1_in_handshape12376); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape1_in_handshape12395);
attr24=this.basichandshape1();
this.state._fsp--;
// Ham4HMLGen.g:406:9: (fnglst= fingerlist )?
var alt26=2;
var LA26_0 = this.input.LA(1);
if ( (LA26_0==FINGERLIST) ) {
alt26=1;
}
switch (alt26) {
case 1 :
// Ham4HMLGen.g:406:11: fnglst= fingerlist
this.pushFollow(Ham4HMLGen.FOLLOW_fingerlist_in_handshape12414);
fnglst=this.fingerlist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:407:9: (fshlst= fingershapelist )?
var alt27=2;
var LA27_0 = this.input.LA(1);
if ( (LA27_0==FISHPLIST) ) {
alt27=1;
}
switch (alt27) {
case 1 :
// Ham4HMLGen.g:407:11: fshlst= fingershapelist
this.pushFollow(Ham4HMLGen.FOLLOW_fingershapelist_in_handshape12436);
fshlst=this.fingershapelist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:408:9: (fcrlst= fingercrossinglist )?
var alt28=2;
var LA28_0 = this.input.LA(1);
if ( (LA28_0==FICRSSLIST) ) {
alt28=1;
}
switch (alt28) {
case 1 :
// Ham4HMLGen.g:408:11: fcrlst= fingercrossinglist
this.pushFollow(Ham4HMLGen.FOLLOW_fingercrossinglist_in_handshape12458);
fcrlst=this.fingercrossinglist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:409:9: (thspc= thumbspecial )?
var alt29=2;
var LA29_0 = this.input.LA(1);
if ( (LA29_0==THSPECIAL) ) {
alt29=1;
}
switch (alt29) {
case 1 :
// Ham4HMLGen.g:409:11: thspc= thumbspecial
this.pushFollow(Ham4HMLGen.FOLLOW_thumbspecial_in_handshape12481);
thspc=this.thumbspecial();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhs = hBuilder.newHMLElement("handshape1");
hBuilder.checkedSetAttr(
rhs,    "handshapeclass",   attr24[0][0]);
hBuilder.checkedSetAttr(
rhs,    "thumbpos",         attr24[0][1]);
hBuilder.checkedSetAttr(rhs,
"fingerbending",    attr24[0][2]);
hBuilder.checkedStringSetFlagAttr(rhs,
"approx_shape",     attr24[0][3]);
if (attr24[1] != null) {
hBuilder.checkedSetAttr(
rhs,    "second_handshapeclass",    attr24[1][0]);
hBuilder.checkedSetAttr(
rhs,    "second_thumbpos",          attr24[1][1]);
hBuilder.checkedSetAttr(
rhs,    "second_fingerbending",     attr24[1][2]);
}
hBuilder.checkedAppendChildList(rhs, fnglst);
hBuilder.checkedAppendChildList(rhs, fshlst);
hBuilder.checkedAppendChildList(rhs, fcrlst);
hBuilder.checkedAppendChild(rhs, thspc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhs;
},
// Ham4HMLGen.g:436:1: basichandshape1 returns [String[][] rbh = []] : ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? ) ;
// $ANTLR start "basichandshape1"
basichandshape1: function() {
var rbh =  [];
var bha = null;
var bhb = null;
try {
// Ham4HMLGen.g:440:5: ( ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? ) )
// Ham4HMLGen.g:441:5: ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? )
this.match(this.input,BASICHDSHP1,Ham4HMLGen.FOLLOW_BASICHDSHP1_in_basichandshape12524); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape_in_basichandshape12542);
bha=this.basichandshape();
this.state._fsp--;
rbh[0] = bha; 
// Ham4HMLGen.g:443:9: (bhb= basichandshape )?
var alt30=2;
var LA30_0 = this.input.LA(1);
if ( (LA30_0==BASICHDSHP) ) {
alt30=1;
}
switch (alt30) {
case 1 :
// Ham4HMLGen.g:443:11: bhb= basichandshape
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape_in_basichandshape12565);
bhb=this.basichandshape();
this.state._fsp--;
rbh[1] = bhb; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rbh;
},
// Ham4HMLGen.g:449:1: basichandshape returns [String[] rbhquad = [null,null,null,null]] : ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) ) ;
// $ANTLR start "basichandshape"
basichandshape: function() {
var rbhquad =  [null,null,null,null];
var tmp = null;
try {
// Ham4HMLGen.g:458:5: ( ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) ) )
// Ham4HMLGen.g:459:5: ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) )
this.match(this.input,BASICHDSHP,Ham4HMLGen.FOLLOW_BASICHDSHP_in_basichandshape2614); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:460:9: (tmp= handshapeclass | HamNondominant )
var alt31=2;
var LA31_0 = this.input.LA(1);
if ( (LA31_0==HSCLASS) ) {
alt31=1;
}
else if ( (LA31_0==HamNondominant) ) {
alt31=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 31, 0, this.input);
throw nvae;
}
switch (alt31) {
case 1 :
// Ham4HMLGen.g:460:11: tmp= handshapeclass
this.pushFollow(Ham4HMLGen.FOLLOW_handshapeclass_in_basichandshape2636);
tmp=this.handshapeclass();
this.state._fsp--;
rbhquad[0] = tmp; 
break;
case 2 :
// Ham4HMLGen.g:461:23: HamNondominant
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_basichandshape2665); 
rbhquad[0] = "ham_nondominant"; 
break;
}
// Ham4HMLGen.g:463:9: ( HamEtc )?
var alt32=2;
var LA32_0 = this.input.LA(1);
if ( (LA32_0==HamEtc) ) {
alt32=1;
}
switch (alt32) {
case 1 :
// Ham4HMLGen.g:463:11: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_basichandshape2692); 
rbhquad[3] = "true";  
break;
}
// Ham4HMLGen.g:464:9: ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? )
var alt35=3;
switch ( this.input.LA(1) ) {
case UP:
alt35=1;
break;
case THUMBPOS:
alt35=2;
break;
case FIBENDING:
alt35=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 35, 0, this.input);
throw nvae;
}
switch (alt35) {
case 1 :
// Ham4HMLGen.g:466:9: 
break;
case 2 :
// Ham4HMLGen.g:467:13: tmp= thumbpos (tmp= fingerbending )?
this.pushFollow(Ham4HMLGen.FOLLOW_thumbpos_in_basichandshape2776);
tmp=this.thumbpos();
this.state._fsp--;
rbhquad[1] = tmp; 
// Ham4HMLGen.g:468:13: (tmp= fingerbending )?
var alt33=2;
var LA33_0 = this.input.LA(1);
if ( (LA33_0==FIBENDING) ) {
alt33=1;
}
switch (alt33) {
case 1 :
// Ham4HMLGen.g:468:15: tmp= fingerbending
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_basichandshape2809);
tmp=this.fingerbending();
this.state._fsp--;
rbhquad[2] = tmp; 
break;
}
break;
case 3 :
// Ham4HMLGen.g:470:13: tmp= fingerbending (tmp= thumbpos )?
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_basichandshape2850);
tmp=this.fingerbending();
this.state._fsp--;
rbhquad[2] = tmp; 
// Ham4HMLGen.g:471:13: (tmp= thumbpos )?
var alt34=2;
var LA34_0 = this.input.LA(1);
if ( (LA34_0==THUMBPOS) ) {
alt34=1;
}
switch (alt34) {
case 1 :
// Ham4HMLGen.g:471:15: tmp= thumbpos
this.pushFollow(Ham4HMLGen.FOLLOW_thumbpos_in_basichandshape2878);
tmp=this.thumbpos();
this.state._fsp--;
rbhquad[1] = tmp; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rbhquad;
},
// Ham4HMLGen.g:476:1: handshapeclass returns [String rhsc = null] : ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ) ;
// $ANTLR start "handshapeclass"
handshapeclass: function() {
var rhsc =  null;
try {
// Ham4HMLGen.g:478:5: ( ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ) )
// Ham4HMLGen.g:479:5: ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) )
this.match(this.input,HSCLASS,Ham4HMLGen.FOLLOW_HSCLASS_in_handshapeclass2937); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:480:9: ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open )
var alt36=12;
switch ( this.input.LA(1) ) {
case HamFist:
alt36=1;
break;
case HamFlathand:
alt36=2;
break;
case HamFinger2:
alt36=3;
break;
case HamFinger23:
alt36=4;
break;
case HamFinger23spread:
alt36=5;
break;
case HamFinger2345:
alt36=6;
break;
case HamPinch12:
alt36=7;
break;
case HamPinchall:
alt36=8;
break;
case HamPinch12open:
alt36=9;
break;
case HamCee12:
alt36=10;
break;
case HamCeeall:
alt36=11;
break;
case HamCee12open:
alt36=12;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 36, 0, this.input);
throw nvae;
}
switch (alt36) {
case 1 :
// Ham4HMLGen.g:480:13: HamFist
this.match(this.input,HamFist,Ham4HMLGen.FOLLOW_HamFist_in_handshapeclass2951); 
rhsc = "ham_fist"; 
break;
case 2 :
// Ham4HMLGen.g:481:13: HamFlathand
this.match(this.input,HamFlathand,Ham4HMLGen.FOLLOW_HamFlathand_in_handshapeclass2979); 
rhsc = "ham_flathand"; 
break;
case 3 :
// Ham4HMLGen.g:482:13: HamFinger2
this.match(this.input,HamFinger2,Ham4HMLGen.FOLLOW_HamFinger2_in_handshapeclass3003); 
rhsc = "ham_finger2"; 
break;
case 4 :
// Ham4HMLGen.g:483:13: HamFinger23
this.match(this.input,HamFinger23,Ham4HMLGen.FOLLOW_HamFinger23_in_handshapeclass3028); 
rhsc = "ham_finger23"; 
break;
case 5 :
// Ham4HMLGen.g:484:13: HamFinger23spread
this.match(this.input,HamFinger23spread,Ham4HMLGen.FOLLOW_HamFinger23spread_in_handshapeclass3052); 
rhsc = "ham_finger23spread"; 
break;
case 6 :
// Ham4HMLGen.g:485:13: HamFinger2345
this.match(this.input,HamFinger2345,Ham4HMLGen.FOLLOW_HamFinger2345_in_handshapeclass3070); 
rhsc = "ham_finger2345"; 
break;
case 7 :
// Ham4HMLGen.g:486:13: HamPinch12
this.match(this.input,HamPinch12,Ham4HMLGen.FOLLOW_HamPinch12_in_handshapeclass3092); 
rhsc = "ham_pinch12"; 
break;
case 8 :
// Ham4HMLGen.g:487:13: HamPinchall
this.match(this.input,HamPinchall,Ham4HMLGen.FOLLOW_HamPinchall_in_handshapeclass3117); 
rhsc = "ham_pinchall"; 
break;
case 9 :
// Ham4HMLGen.g:488:13: HamPinch12open
this.match(this.input,HamPinch12open,Ham4HMLGen.FOLLOW_HamPinch12open_in_handshapeclass3141); 
rhsc = "ham_pinch12open"; 
break;
case 10 :
// Ham4HMLGen.g:489:13: HamCee12
this.match(this.input,HamCee12,Ham4HMLGen.FOLLOW_HamCee12_in_handshapeclass3162); 
rhsc = "ham_cee12"; 
break;
case 11 :
// Ham4HMLGen.g:490:13: HamCeeall
this.match(this.input,HamCeeall,Ham4HMLGen.FOLLOW_HamCeeall_in_handshapeclass3189); 
rhsc = "ham_ceeall"; 
break;
case 12 :
// Ham4HMLGen.g:491:13: HamCee12open
this.match(this.input,HamCee12open,Ham4HMLGen.FOLLOW_HamCee12open_in_handshapeclass3215); 
rhsc = "ham_cee12open"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhsc;
},
// Ham4HMLGen.g:496:1: fingerbending returns [String rfb = null] : ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ) ;
// $ANTLR start "fingerbending"
fingerbending: function() {
var rfb =  null;
try {
// Ham4HMLGen.g:498:5: ( ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ) )
// Ham4HMLGen.g:499:5: ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) )
this.match(this.input,FIBENDING,Ham4HMLGen.FOLLOW_FIBENDING_in_fingerbending3270); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:500:9: ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked )
var alt37=5;
switch ( this.input.LA(1) ) {
case HamFingerstraightmod:
alt37=1;
break;
case HamFingerbendmod:
alt37=2;
break;
case HamFingerhookedmod:
alt37=3;
break;
case HamDoublebent:
alt37=4;
break;
case HamDoublehooked:
alt37=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 37, 0, this.input);
throw nvae;
}
switch (alt37) {
case 1 :
// Ham4HMLGen.g:500:13: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_fingerbending3284); 
rfb = "ham_finger_straight"; 
break;
case 2 :
// Ham4HMLGen.g:501:13: HamFingerbendmod
this.match(this.input,HamFingerbendmod,Ham4HMLGen.FOLLOW_HamFingerbendmod_in_fingerbending3303); 
rfb = "ham_finger_bend"; 
break;
case 3 :
// Ham4HMLGen.g:502:13: HamFingerhookedmod
this.match(this.input,HamFingerhookedmod,Ham4HMLGen.FOLLOW_HamFingerhookedmod_in_fingerbending3326); 
rfb = "ham_finger_hooked"; 
break;
case 4 :
// Ham4HMLGen.g:503:13: HamDoublebent
this.match(this.input,HamDoublebent,Ham4HMLGen.FOLLOW_HamDoublebent_in_fingerbending3347); 
rfb = "ham_finger_dblbent"; 
break;
case 5 :
// Ham4HMLGen.g:504:13: HamDoublehooked
this.match(this.input,HamDoublehooked,Ham4HMLGen.FOLLOW_HamDoublehooked_in_fingerbending3373); 
rfb = "ham_finger_dblhooked"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfb;
},
// Ham4HMLGen.g:509:1: thumbpos returns [String rtp = null] : ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ) ;
// $ANTLR start "thumbpos"
thumbpos: function() {
var rtp =  null;
try {
// Ham4HMLGen.g:511:5: ( ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ) )
// Ham4HMLGen.g:512:5: ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) )
this.match(this.input,THUMBPOS,Ham4HMLGen.FOLLOW_THUMBPOS_in_thumbpos3434); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:513:9: ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod )
var alt38=3;
switch ( this.input.LA(1) ) {
case HamThumboutmod:
alt38=1;
break;
case HamThumbacrossmod:
alt38=2;
break;
case HamThumbopenmod:
alt38=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 38, 0, this.input);
throw nvae;
}
switch (alt38) {
case 1 :
// Ham4HMLGen.g:513:13: HamThumboutmod
this.match(this.input,HamThumboutmod,Ham4HMLGen.FOLLOW_HamThumboutmod_in_thumbpos3448); 
rtp = "ham_thumb_out"; 
break;
case 2 :
// Ham4HMLGen.g:514:13: HamThumbacrossmod
this.match(this.input,HamThumbacrossmod,Ham4HMLGen.FOLLOW_HamThumbacrossmod_in_thumbpos3469); 
rtp = "ham_thumb_across"; 
break;
case 3 :
// Ham4HMLGen.g:515:13: HamThumbopenmod
this.match(this.input,HamThumbopenmod,Ham4HMLGen.FOLLOW_HamThumbopenmod_in_thumbpos3487); 
rtp = "ham_thumb_open"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rtp;
},
// Ham4HMLGen.g:520:1: thumb returns [Element rth = null] : HamThumb ;
// $ANTLR start "thumb"
thumb: function() {
var rth =  null;
try {
// Ham4HMLGen.g:523:5: ( HamThumb )
// Ham4HMLGen.g:523:9: HamThumb
this.match(this.input,HamThumb,Ham4HMLGen.FOLLOW_HamThumb_in_thumb3544); 
rth = hBuilder.newHMLElement("thumb");
rth.setAttribute("fingerid", "ham_digit_1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rth;
},
// Ham4HMLGen.g:530:1: finger returns [Element rfngr = null] : ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky ) ;
// $ANTLR start "finger"
finger: function() {
var rfngr =  null;
var fi = null;
try {
// Ham4HMLGen.g:536:5: ( ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky ) )
// Ham4HMLGen.g:537:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
// Ham4HMLGen.g:537:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
var alt39=4;
switch ( this.input.LA(1) ) {
case HamIndexfinger:
alt39=1;
break;
case HamMiddlefinger:
alt39=2;
break;
case HamRingfinger:
alt39=3;
break;
case HamPinky:
alt39=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 39, 0, this.input);
throw nvae;
}
switch (alt39) {
case 1 :
// Ham4HMLGen.g:537:9: HamIndexfinger
this.match(this.input,HamIndexfinger,Ham4HMLGen.FOLLOW_HamIndexfinger_in_finger3594); 
fi = "2"; 
break;
case 2 :
// Ham4HMLGen.g:538:9: HamMiddlefinger
this.match(this.input,HamMiddlefinger,Ham4HMLGen.FOLLOW_HamMiddlefinger_in_finger3615); 
fi = "3"; 
break;
case 3 :
// Ham4HMLGen.g:539:9: HamRingfinger
this.match(this.input,HamRingfinger,Ham4HMLGen.FOLLOW_HamRingfinger_in_finger3635); 
fi = "4"; 
break;
case 4 :
// Ham4HMLGen.g:540:9: HamPinky
this.match(this.input,HamPinky,Ham4HMLGen.FOLLOW_HamPinky_in_finger3657); 
fi = "5"; 
break;
}
rfngr = hBuilder.newHMLElement("fingernothumb");
rfngr.setAttribute("fingerid", "ham_digit_" + fi);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngr;
},
// Ham4HMLGen.g:548:1: hsfingeritem returns [Element rfngr = null] : ^( HSFINGERITEM fngr= finger ( HamLargemod )? ) ;
// $ANTLR start "hsfingeritem"
hsfingeritem: function() {
var rfngr =  null;
var fngr = null;
var opthumb = false;
try {
// Ham4HMLGen.g:554:5: ( ^( HSFINGERITEM fngr= finger ( HamLargemod )? ) )
// Ham4HMLGen.g:555:5: ^( HSFINGERITEM fngr= finger ( HamLargemod )? )
this.match(this.input,HSFINGERITEM,Ham4HMLGen.FOLLOW_HSFINGERITEM_in_hsfingeritem3721); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_hsfingeritem3735);
fngr=this.finger();
this.state._fsp--;
rfngr = fngr; 
// Ham4HMLGen.g:557:9: ( HamLargemod )?
var alt40=2;
var LA40_0 = this.input.LA(1);
if ( (LA40_0==HamLargemod) ) {
alt40=1;
}
switch (alt40) {
case 1 :
// Ham4HMLGen.g:557:11: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_hsfingeritem3755); 
opthumb = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
hBuilder.checkedSetFlagAttr(rfngr, "thumbopp", opthumb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngr;
},
// Ham4HMLGen.g:564:1: digit returns [Element rd = null] : (fi= thumb | fi= finger ) ;
// $ANTLR start "digit"
digit: function() {
var rd =  null;
var fi = null;
try {
// Ham4HMLGen.g:567:5: ( (fi= thumb | fi= finger ) )
// Ham4HMLGen.g:568:5: (fi= thumb | fi= finger )
// Ham4HMLGen.g:568:5: (fi= thumb | fi= finger )
var alt41=2;
var LA41_0 = this.input.LA(1);
if ( (LA41_0==HamThumb) ) {
alt41=1;
}
else if ( ((LA41_0>=HamIndexfinger && LA41_0<=HamPinky)) ) {
alt41=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);
throw nvae;
}
switch (alt41) {
case 1 :
// Ham4HMLGen.g:568:9: fi= thumb
this.pushFollow(Ham4HMLGen.FOLLOW_thumb_in_digit3823);
fi=this.thumb();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:569:9: fi= finger
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_digit3837);
fi=this.finger();
this.state._fsp--;
break;
}
rd = hBuilder.newHMLElement("finger");
rd.setAttribute("fingerid", fi.getAttribute("fingerid"));
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rd;
},
// Ham4HMLGen.g:577:1: fingerlist returns [Element[] rfngl = null] : ^( FINGERLIST (fng= hsfingeritem )* ) ;
// $ANTLR start "fingerlist"
fingerlist: function() {
var rfngl =  null;
var fng = null;
var      al  = [];
try {
// Ham4HMLGen.g:583:5: ( ^( FINGERLIST (fng= hsfingeritem )* ) )
// Ham4HMLGen.g:584:5: ^( FINGERLIST (fng= hsfingeritem )* )
this.match(this.input,FINGERLIST,Ham4HMLGen.FOLLOW_FINGERLIST_in_fingerlist3886); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:585:9: (fng= hsfingeritem )*
loop42:
do {
var alt42=2;
var LA42_0 = this.input.LA(1);
if ( (LA42_0==HSFINGERITEM) ) {
alt42=1;
}
switch (alt42) {
case 1 :
// Ham4HMLGen.g:585:11: fng= hsfingeritem
this.pushFollow(Ham4HMLGen.FOLLOW_hsfingeritem_in_fingerlist3902);
fng=this.hsfingeritem();
this.state._fsp--;
al.push(fng); 
break;
default :
break loop42;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfngl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngl;
},
// Ham4HMLGen.g:592:1: fingershapelist returns [Element[] rfsl = null] : ^( FISHPLIST (fs= fingershape )* ) ;
// $ANTLR start "fingershapelist"
fingershapelist: function() {
var rfsl =  null;
var fs = null;
var    al  = [];
try {
// Ham4HMLGen.g:598:5: ( ^( FISHPLIST (fs= fingershape )* ) )
// Ham4HMLGen.g:599:5: ^( FISHPLIST (fs= fingershape )* )
this.match(this.input,FISHPLIST,Ham4HMLGen.FOLLOW_FISHPLIST_in_fingershapelist3966); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:600:9: (fs= fingershape )*
loop43:
do {
var alt43=2;
var LA43_0 = this.input.LA(1);
if ( (LA43_0==FSHAPE) ) {
alt43=1;
}
switch (alt43) {
case 1 :
// Ham4HMLGen.g:600:11: fs= fingershape
this.pushFollow(Ham4HMLGen.FOLLOW_fingershape_in_fingershapelist3982);
fs=this.fingershape();
this.state._fsp--;
al.push(fs); 
break;
default :
break loop43;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfsl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfsl;
},
// Ham4HMLGen.g:607:1: fingercrossinglist returns [Element[] rfcl = null] : ^( FICRSSLIST (fc= fingercrossing )* ) ;
// $ANTLR start "fingercrossinglist"
fingercrossinglist: function() {
var rfcl =  null;
var fc = null;
var    al  = [];
try {
// Ham4HMLGen.g:613:5: ( ^( FICRSSLIST (fc= fingercrossing )* ) )
// Ham4HMLGen.g:614:5: ^( FICRSSLIST (fc= fingercrossing )* )
this.match(this.input,FICRSSLIST,Ham4HMLGen.FOLLOW_FICRSSLIST_in_fingercrossinglist4045); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:615:9: (fc= fingercrossing )*
loop44:
do {
var alt44=2;
var LA44_0 = this.input.LA(1);
if ( (LA44_0==FCROSSING) ) {
alt44=1;
}
switch (alt44) {
case 1 :
// Ham4HMLGen.g:615:11: fc= fingercrossing
this.pushFollow(Ham4HMLGen.FOLLOW_fingercrossing_in_fingercrossinglist4061);
fc=this.fingercrossing();
this.state._fsp--;
al.push(fc); 
break;
default :
break loop44;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfcl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfcl;
},
// Ham4HMLGen.g:622:1: fingershape returns [Element rfs = null] : ^( FSHAPE d= digit fb= fingerbending ) ;
// $ANTLR start "fingershape"
fingershape: function() {
var rfs =  null;
var d = null;
var fb = null;
try {
// Ham4HMLGen.g:625:5: ( ^( FSHAPE d= digit fb= fingerbending ) )
// Ham4HMLGen.g:626:5: ^( FSHAPE d= digit fb= fingerbending )
this.match(this.input,FSHAPE,Ham4HMLGen.FOLLOW_FSHAPE_in_fingershape4116); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingershape4131);
d=this.digit();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_fingershape4145);
fb=this.fingerbending();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rfs = hBuilder.newHMLElement("fingershape");
rfs.appendChild(d);
rfs.setAttribute("fingerbending", fb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfs;
},
// Ham4HMLGen.g:637:1: fingercrossing returns [Element rfc = null] : ^( FCROSSING d0= digit fip= fingerpart d1= digit ) ;
// $ANTLR start "fingercrossing"
fingercrossing: function() {
var rfc =  null;
var d0 = null;
var fip = null;
var d1 = null;
try {
// Ham4HMLGen.g:640:5: ( ^( FCROSSING d0= digit fip= fingerpart d1= digit ) )
// Ham4HMLGen.g:641:5: ^( FCROSSING d0= digit fip= fingerpart d1= digit )
this.match(this.input,FCROSSING,Ham4HMLGen.FOLLOW_FCROSSING_in_fingercrossing4186); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingercrossing4200);
d0=this.digit();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_fingercrossing4214);
fip=this.fingerpart();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingercrossing4228);
d1=this.digit();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rfc = hBuilder.newHMLElement("fingercrossing");
rfc.appendChild(d0);
rfc.appendChild(fip);
rfc.appendChild(d1);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfc;
},
// Ham4HMLGen.g:654:1: thumbspecial returns [Element rts = null] : ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) ) ;
// $ANTLR start "thumbspecial"
thumbspecial: function() {
var rts =  null;
var fng0 = null;
var fng1 = null;
var th = null;
var fp = null;
rts = hBuilder.newHMLElement("thumbspecial");
try {
// Ham4HMLGen.g:660:5: ( ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) ) )
// Ham4HMLGen.g:661:5: ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) )
this.match(this.input,THSPECIAL,Ham4HMLGen.FOLLOW_THSPECIAL_in_thumbspecial4274); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:662:9: ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart )
var alt46=3;
switch ( this.input.LA(1) ) {
case HamBetween:
alt46=1;
break;
case HamThumb:
alt46=2;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt46=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 46, 0, this.input);
throw nvae;
}
switch (alt46) {
case 1 :
// Ham4HMLGen.g:662:13: ^( HamBetween (fng0= finger fng1= finger )? )
this.match(this.input,HamBetween,Ham4HMLGen.FOLLOW_HamBetween_in_thumbspecial4289); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:663:17: (fng0= finger fng1= finger )?
var alt45=2;
var LA45_0 = this.input.LA(1);
if ( ((LA45_0>=HamIndexfinger && LA45_0<=HamPinky)) ) {
alt45=1;
}
switch (alt45) {
case 1 :
// Ham4HMLGen.g:663:21: fng0= finger fng1= finger
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_thumbspecial4315);
fng0=this.finger();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_thumbspecial4341);
fng1=this.finger();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
if (fng0 == null) {
var btwn = hBuilder.newHMLElement("hambetween");
rts.appendChild(btwn);
}
else {
rts.appendChild(fng0);
rts.appendChild(fng1);
}
break;
case 2 :
// Ham4HMLGen.g:677:13: th= thumb
this.pushFollow(Ham4HMLGen.FOLLOW_thumb_in_thumbspecial4406);
th=this.thumb();
this.state._fsp--;
rts.appendChild(th); 
break;
case 3 :
// Ham4HMLGen.g:678:13: fp= fingerpart
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_thumbspecial4439);
fp=this.fingerpart();
this.state._fsp--;
rts.appendChild(fp); 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rts;
},
// Ham4HMLGen.g:683:1: fingerpart returns [Element rfp = null] : ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside ) ;
// $ANTLR start "fingerpart"
fingerpart: function() {
var rfp =  null;
var  fp = null;
try {
// Ham4HMLGen.g:689:5: ( ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside ) )
// Ham4HMLGen.g:690:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
// Ham4HMLGen.g:690:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
var alt47=6;
switch ( this.input.LA(1) ) {
case HamFingertip:
alt47=1;
break;
case HamFingernail:
alt47=2;
break;
case HamFingerpad:
alt47=3;
break;
case HamFingermidjoint:
alt47=4;
break;
case HamFingerbase:
alt47=5;
break;
case HamFingerside:
alt47=6;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 47, 0, this.input);
throw nvae;
}
switch (alt47) {
case 1 :
// Ham4HMLGen.g:690:9: HamFingertip
this.match(this.input,HamFingertip,Ham4HMLGen.FOLLOW_HamFingertip_in_fingerpart4505); 
fp = "ham_finger_tip"; 
break;
case 2 :
// Ham4HMLGen.g:691:9: HamFingernail
this.match(this.input,HamFingernail,Ham4HMLGen.FOLLOW_HamFingernail_in_fingerpart4528); 
fp = "ham_finger_nail"; 
break;
case 3 :
// Ham4HMLGen.g:692:9: HamFingerpad
this.match(this.input,HamFingerpad,Ham4HMLGen.FOLLOW_HamFingerpad_in_fingerpart4550); 
fp = "ham_finger_pad"; 
break;
case 4 :
// Ham4HMLGen.g:693:9: HamFingermidjoint
this.match(this.input,HamFingermidjoint,Ham4HMLGen.FOLLOW_HamFingermidjoint_in_fingerpart4573); 
fp = "ham_finger_midjoint"; 
break;
case 5 :
// Ham4HMLGen.g:694:9: HamFingerbase
this.match(this.input,HamFingerbase,Ham4HMLGen.FOLLOW_HamFingerbase_in_fingerpart4591); 
fp = "ham_finger_base"; 
break;
case 6 :
// Ham4HMLGen.g:695:9: HamFingerside
this.match(this.input,HamFingerside,Ham4HMLGen.FOLLOW_HamFingerside_in_fingerpart4613); 
fp = "ham_finger_side"; 
break;
}
rfp = hBuilder.newHMLElement("fingerpart");
rfp.setAttribute("fingerpart", fp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfp;
},
// Ham4HMLGen.g:706:1: extfidir2 returns [Element refd = null] : ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? ) ;
// $ANTLR start "extfidir2"
extfidir2: function() {
var refd =  null;
var da = null;
var db = null;
try {
// Ham4HMLGen.g:709:5: ( ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? ) )
// Ham4HMLGen.g:710:5: ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? )
this.match(this.input,EXTFIDIR2,Ham4HMLGen.FOLLOW_EXTFIDIR2_in_extfidir24674); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_extfidir24693);
da=this.extfidir1();
this.state._fsp--;
// Ham4HMLGen.g:712:9: (db= extfidir1 )?
var alt48=2;
var LA48_0 = this.input.LA(1);
if ( (LA48_0==EXTFIDIR1) ) {
alt48=1;
}
switch (alt48) {
case 1 :
// Ham4HMLGen.g:712:11: db= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_extfidir24712);
db=this.extfidir1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd = hBuilder.newHMLElement("extfidir2");
refd.appendChild(da);
hBuilder.checkedAppendChild(refd, db);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd;
},
// Ham4HMLGen.g:721:1: extfidir1 returns [Element refd1 = null] : ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? ) ;
// $ANTLR start "extfidir1"
extfidir1: function() {
var refd1 =  null;
var efda = null;
var efdb = null;
var orirel = false;
try {
// Ham4HMLGen.g:727:5: ( ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? ) )
// Ham4HMLGen.g:728:5: ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? )
this.match(this.input,EXTFIDIR1,Ham4HMLGen.FOLLOW_EXTFIDIR1_in_extfidir14765); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir_in_extfidir14782);
efda=this.extfidir();
this.state._fsp--;
// Ham4HMLGen.g:730:9: (efdb= extfidir )?
var alt49=2;
var LA49_0 = this.input.LA(1);
if ( (LA49_0==EXTFIDIR) ) {
alt49=1;
}
switch (alt49) {
case 1 :
// Ham4HMLGen.g:730:11: efdb= extfidir
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir_in_extfidir14799);
efdb=this.extfidir();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:731:9: ( HamOrirelative )?
var alt50=2;
var LA50_0 = this.input.LA(1);
if ( (LA50_0==HamOrirelative) ) {
alt50=1;
}
switch (alt50) {
case 1 :
// Ham4HMLGen.g:731:19: HamOrirelative
this.match(this.input,HamOrirelative,Ham4HMLGen.FOLLOW_HamOrirelative_in_extfidir14822); 
orirel = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd1 = hBuilder.newHMLElement("extfidir1");
refd1.setAttribute("extfidir", efda);
hBuilder.checkedSetAttr(refd1, "second_extfidir", efdb);
hBuilder.checkedSetFlagAttr(refd1, "rel_extfidir", orirel);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd1;
},
// Ham4HMLGen.g:741:1: extfidir returns [String refd = null] : ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) ) ;
// $ANTLR start "extfidir"
extfidir: function() {
var refd =  null;
var dir = null;
try {
// Ham4HMLGen.g:748:5: ( ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) ) )
// Ham4HMLGen.g:749:5: ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) )
this.match(this.input,EXTFIDIR,Ham4HMLGen.FOLLOW_EXTFIDIR_in_extfidir4885); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:750:9: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) )
var alt59=18;
switch ( this.input.LA(1) ) {
case HamExtfingeru:
alt59=1;
break;
case HamExtfingerur:
alt59=2;
break;
case HamExtfingerr:
alt59=3;
break;
case HamExtfingerdr:
alt59=4;
break;
case HamExtfingerd:
alt59=5;
break;
case HamExtfingerdl:
alt59=6;
break;
case HamExtfingerl:
alt59=7;
break;
case HamExtfingerul:
alt59=8;
break;
case HamExtfingerol:
alt59=9;
break;
case HamExtfingero:
alt59=10;
break;
case HamExtfingeror:
alt59=11;
break;
case HamExtfingeril:
alt59=12;
break;
case HamExtfingeri:
alt59=13;
break;
case HamExtfingerir:
alt59=14;
break;
case HamExtfingeruo:
alt59=15;
break;
case HamExtfingerdo:
alt59=16;
break;
case HamExtfingerui:
alt59=17;
break;
case HamExtfingerdi:
alt59=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 59, 0, this.input);
throw nvae;
}
switch (alt59) {
case 1 :
// Ham4HMLGen.g:752:13: HamExtfingeru
this.match(this.input,HamExtfingeru,Ham4HMLGen.FOLLOW_HamExtfingeru_in_extfidir4919); 
dir = "u"; 
break;
case 2 :
// Ham4HMLGen.g:753:13: HamExtfingerur
this.match(this.input,HamExtfingerur,Ham4HMLGen.FOLLOW_HamExtfingerur_in_extfidir4949); 
dir = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:754:13: HamExtfingerr
this.match(this.input,HamExtfingerr,Ham4HMLGen.FOLLOW_HamExtfingerr_in_extfidir4978); 
dir = "r"; 
break;
case 4 :
// Ham4HMLGen.g:755:13: HamExtfingerdr
this.match(this.input,HamExtfingerdr,Ham4HMLGen.FOLLOW_HamExtfingerdr_in_extfidir5008); 
dir = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:756:13: HamExtfingerd
this.match(this.input,HamExtfingerd,Ham4HMLGen.FOLLOW_HamExtfingerd_in_extfidir5037); 
dir = "d"; 
break;
case 6 :
// Ham4HMLGen.g:757:13: HamExtfingerdl
this.match(this.input,HamExtfingerdl,Ham4HMLGen.FOLLOW_HamExtfingerdl_in_extfidir5067); 
dir = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:758:13: HamExtfingerl
this.match(this.input,HamExtfingerl,Ham4HMLGen.FOLLOW_HamExtfingerl_in_extfidir5096); 
dir = "l"; 
break;
case 8 :
// Ham4HMLGen.g:759:13: HamExtfingerul
this.match(this.input,HamExtfingerul,Ham4HMLGen.FOLLOW_HamExtfingerul_in_extfidir5126); 
dir = "ul"; 
break;
case 9 :
// Ham4HMLGen.g:761:13: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:761:13: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:762:17: HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )?
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir5183); 
dir = "ol"; 
// Ham4HMLGen.g:763:17: ( HamExtfingeruo | HamExtfingerdo )?
var alt51=3;
var LA51_0 = this.input.LA(1);
if ( (LA51_0==HamExtfingeruo) ) {
alt51=1;
}
else if ( (LA51_0==HamExtfingerdo) ) {
alt51=2;
}
switch (alt51) {
case 1 :
// Ham4HMLGen.g:764:21: HamExtfingeruo
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5234); 
dir = "uol"; 
break;
case 2 :
// Ham4HMLGen.g:765:21: HamExtfingerdo
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir5263); 
dir = "dol"; 
break;
}
break;
case 10 :
// Ham4HMLGen.g:768:13: HamExtfingero
this.match(this.input,HamExtfingero,Ham4HMLGen.FOLLOW_HamExtfingero_in_extfidir5317); 
dir = "o"; 
break;
case 11 :
// Ham4HMLGen.g:769:13: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:769:13: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:770:17: HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )?
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir5365); 
dir = "or"; 
// Ham4HMLGen.g:771:17: ( HamExtfingeruo | HamExtfingerdo )?
var alt52=3;
var LA52_0 = this.input.LA(1);
if ( (LA52_0==HamExtfingeruo) ) {
alt52=1;
}
else if ( (LA52_0==HamExtfingerdo) ) {
alt52=2;
}
switch (alt52) {
case 1 :
// Ham4HMLGen.g:772:21: HamExtfingeruo
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5416); 
dir = "uor"; 
break;
case 2 :
// Ham4HMLGen.g:773:21: HamExtfingerdo
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir5445); 
dir = "dor"; 
break;
}
break;
case 12 :
// Ham4HMLGen.g:776:13: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:776:13: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:777:17: HamExtfingeril ( HamExtfingerui | HamExtfingerdi )?
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir5517); 
dir = "il"; 
// Ham4HMLGen.g:778:17: ( HamExtfingerui | HamExtfingerdi )?
var alt53=3;
var LA53_0 = this.input.LA(1);
if ( (LA53_0==HamExtfingerui) ) {
alt53=1;
}
else if ( (LA53_0==HamExtfingerdi) ) {
alt53=2;
}
switch (alt53) {
case 1 :
// Ham4HMLGen.g:779:21: HamExtfingerui
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir5568); 
dir = "uil"; 
break;
case 2 :
// Ham4HMLGen.g:780:21: HamExtfingerdi
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir5597); 
dir = "dil"; 
break;
}
break;
case 13 :
// Ham4HMLGen.g:783:13: HamExtfingeri
this.match(this.input,HamExtfingeri,Ham4HMLGen.FOLLOW_HamExtfingeri_in_extfidir5651); 
dir = "i"; 
break;
case 14 :
// Ham4HMLGen.g:784:13: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:784:13: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:785:17: HamExtfingerir ( HamExtfingerui | HamExtfingerdi )?
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir5699); 
dir = "ir"; 
// Ham4HMLGen.g:786:17: ( HamExtfingerui | HamExtfingerdi )?
var alt54=3;
var LA54_0 = this.input.LA(1);
if ( (LA54_0==HamExtfingerui) ) {
alt54=1;
}
else if ( (LA54_0==HamExtfingerdi) ) {
alt54=2;
}
switch (alt54) {
case 1 :
// Ham4HMLGen.g:787:21: HamExtfingerui
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir5750); 
dir = "uir"; 
break;
case 2 :
// Ham4HMLGen.g:788:21: HamExtfingerdi
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir5779); 
dir = "dir"; 
break;
}
break;
case 15 :
// Ham4HMLGen.g:792:13: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:792:13: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:793:17: HamExtfingeruo ( HamExtfingerol | HamExtfingeror )?
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5861); 
dir = "uo"; 
// Ham4HMLGen.g:794:17: ( HamExtfingerol | HamExtfingeror )?
var alt55=3;
var LA55_0 = this.input.LA(1);
if ( (LA55_0==HamExtfingerol) ) {
alt55=1;
}
else if ( (LA55_0==HamExtfingeror) ) {
alt55=2;
}
switch (alt55) {
case 1 :
// Ham4HMLGen.g:795:21: HamExtfingerol
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir5912); 
dir = "uol"; 
break;
case 2 :
// Ham4HMLGen.g:796:21: HamExtfingeror
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir5941); 
dir = "uor"; 
break;
}
break;
case 16 :
// Ham4HMLGen.g:799:13: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:799:13: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:800:17: HamExtfingerdo ( HamExtfingerol | HamExtfingeror )?
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir6013); 
dir = "do"; 
// Ham4HMLGen.g:801:17: ( HamExtfingerol | HamExtfingeror )?
var alt56=3;
var LA56_0 = this.input.LA(1);
if ( (LA56_0==HamExtfingerol) ) {
alt56=1;
}
else if ( (LA56_0==HamExtfingeror) ) {
alt56=2;
}
switch (alt56) {
case 1 :
// Ham4HMLGen.g:802:21: HamExtfingerol
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir6064); 
dir = "dol"; 
break;
case 2 :
// Ham4HMLGen.g:803:21: HamExtfingeror
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir6093); 
dir = "dor"; 
break;
}
break;
case 17 :
// Ham4HMLGen.g:806:13: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:806:13: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:807:17: HamExtfingerui ( HamExtfingeril | HamExtfingerir )?
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir6165); 
dir = "ui"; 
// Ham4HMLGen.g:808:17: ( HamExtfingeril | HamExtfingerir )?
var alt57=3;
var LA57_0 = this.input.LA(1);
if ( (LA57_0==HamExtfingeril) ) {
alt57=1;
}
else if ( (LA57_0==HamExtfingerir) ) {
alt57=2;
}
switch (alt57) {
case 1 :
// Ham4HMLGen.g:809:21: HamExtfingeril
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir6216); 
dir = "uil"; 
break;
case 2 :
// Ham4HMLGen.g:810:21: HamExtfingerir
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir6245); 
dir = "uir"; 
break;
}
break;
case 18 :
// Ham4HMLGen.g:813:13: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:813:13: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:814:17: HamExtfingerdi ( HamExtfingeril | HamExtfingerir )?
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir6317); 
dir = "di"; 
// Ham4HMLGen.g:815:17: ( HamExtfingeril | HamExtfingerir )?
var alt58=3;
var LA58_0 = this.input.LA(1);
if ( (LA58_0==HamExtfingeril) ) {
alt58=1;
}
else if ( (LA58_0==HamExtfingerir) ) {
alt58=2;
}
switch (alt58) {
case 1 :
// Ham4HMLGen.g:816:21: HamExtfingeril
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir6368); 
dir = "dil"; 
break;
case 2 :
// Ham4HMLGen.g:817:21: HamExtfingerir
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir6397); 
dir = "dir"; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd = "direction_" + dir;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd;
},
// Ham4HMLGen.g:830:1: palmor2 returns [Element rpo = null] : ^( PALMOR2 poa= palmor1 (pob= palmor1 )? ) ;
// $ANTLR start "palmor2"
palmor2: function() {
var rpo =  null;
var poa = null;
var pob = null;
try {
// Ham4HMLGen.g:833:5: ( ^( PALMOR2 poa= palmor1 (pob= palmor1 )? ) )
// Ham4HMLGen.g:834:5: ^( PALMOR2 poa= palmor1 (pob= palmor1 )? )
this.match(this.input,PALMOR2,Ham4HMLGen.FOLLOW_PALMOR2_in_palmor26498); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_palmor26516);
poa=this.palmor1();
this.state._fsp--;
// Ham4HMLGen.g:836:9: (pob= palmor1 )?
var alt60=2;
var LA60_0 = this.input.LA(1);
if ( (LA60_0==PALMOR1) ) {
alt60=1;
}
switch (alt60) {
case 1 :
// Ham4HMLGen.g:836:11: pob= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_palmor26534);
pob=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpo = hBuilder.newHMLElement("palmor2");
rpo.appendChild(poa);
hBuilder.checkedAppendChild(rpo, pob);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo;
},
// Ham4HMLGen.g:845:1: palmor1 returns [Element rpo1 = null] : ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? ) ;
// $ANTLR start "palmor1"
palmor1: function() {
var rpo1 =  null;
var poa = null;
var pob = null;
var approxpo = false;
var orirel = false;
try {
// Ham4HMLGen.g:852:5: ( ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? ) )
// Ham4HMLGen.g:853:5: ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? )
this.match(this.input,PALMOR1,Ham4HMLGen.FOLLOW_PALMOR1_in_palmor16589); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor_in_palmor16607);
poa=this.palmor();
this.state._fsp--;
// Ham4HMLGen.g:855:9: (pob= palmor | HamEtc )?
var alt61=3;
var LA61_0 = this.input.LA(1);
if ( ((LA61_0>=HamPalmu && LA61_0<=HamPalmul)) ) {
alt61=1;
}
else if ( (LA61_0==HamEtc) ) {
alt61=2;
}
switch (alt61) {
case 1 :
// Ham4HMLGen.g:856:13: pob= palmor
this.pushFollow(Ham4HMLGen.FOLLOW_palmor_in_palmor16635);
pob=this.palmor();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:858:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_palmor16665); 
approxpo = true; 
break;
}
// Ham4HMLGen.g:860:9: ( HamOrirelative )?
var alt62=2;
var LA62_0 = this.input.LA(1);
if ( (LA62_0==HamOrirelative) ) {
alt62=1;
}
switch (alt62) {
case 1 :
// Ham4HMLGen.g:860:19: HamOrirelative
this.match(this.input,HamOrirelative,Ham4HMLGen.FOLLOW_HamOrirelative_in_palmor16707); 
orirel = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpo1 = hBuilder.newHMLElement("palmor1");
rpo1.setAttribute("palmor", poa);
hBuilder.checkedSetAttr(rpo1, "second_palmor", pob);
hBuilder.checkedSetFlagAttr(rpo1, "approx_palmor", approxpo);
hBuilder.checkedSetFlagAttr(rpo1, "rel_palmor", orirel);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo1;
},
// Ham4HMLGen.g:872:1: palmor returns [String rpo = null] : ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul ) ;
// $ANTLR start "palmor"
palmor: function() {
var rpo =  null;
var  dir = null;
try {
// Ham4HMLGen.g:879:5: ( ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul ) )
// Ham4HMLGen.g:880:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
// Ham4HMLGen.g:880:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
var alt63=8;
switch ( this.input.LA(1) ) {
case HamPalmu:
alt63=1;
break;
case HamPalmur:
alt63=2;
break;
case HamPalmr:
alt63=3;
break;
case HamPalmdr:
alt63=4;
break;
case HamPalmd:
alt63=5;
break;
case HamPalmdl:
alt63=6;
break;
case HamPalml:
alt63=7;
break;
case HamPalmul:
alt63=8;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 63, 0, this.input);
throw nvae;
}
switch (alt63) {
case 1 :
// Ham4HMLGen.g:880:9: HamPalmu
this.match(this.input,HamPalmu,Ham4HMLGen.FOLLOW_HamPalmu_in_palmor6776); 
dir = "u"; 
break;
case 2 :
// Ham4HMLGen.g:881:9: HamPalmur
this.match(this.input,HamPalmur,Ham4HMLGen.FOLLOW_HamPalmur_in_palmor6799); 
dir = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:882:9: HamPalmr
this.match(this.input,HamPalmr,Ham4HMLGen.FOLLOW_HamPalmr_in_palmor6821); 
dir = "r"; 
break;
case 4 :
// Ham4HMLGen.g:883:9: HamPalmdr
this.match(this.input,HamPalmdr,Ham4HMLGen.FOLLOW_HamPalmdr_in_palmor6844); 
dir = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:884:9: HamPalmd
this.match(this.input,HamPalmd,Ham4HMLGen.FOLLOW_HamPalmd_in_palmor6866); 
dir = "d"; 
break;
case 6 :
// Ham4HMLGen.g:885:9: HamPalmdl
this.match(this.input,HamPalmdl,Ham4HMLGen.FOLLOW_HamPalmdl_in_palmor6889); 
dir = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:886:9: HamPalml
this.match(this.input,HamPalml,Ham4HMLGen.FOLLOW_HamPalml_in_palmor6911); 
dir = "l"; 
break;
case 8 :
// Ham4HMLGen.g:887:9: HamPalmul
this.match(this.input,HamPalmul,Ham4HMLGen.FOLLOW_HamPalmul_in_palmor6934); 
dir = "ul"; 
break;
}
rpo = "ham_palm_" + dir;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo;
},
// Ham4HMLGen.g:897:1: location2 returns [Element rloc = null] : ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) ) ;
// $ANTLR start "location2"
location2: function() {
var rloc =  null;
var lc1 = null;
var lc1x = null;
var hc = null;
var lb = null;
var  ext = null;
try {
// Ham4HMLGen.g:903:5: ( ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) ) )
// Ham4HMLGen.g:904:5: ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) )
this.match(this.input,LOC2,Ham4HMLGen.FOLLOW_LOC2_in_location26999); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:905:9: (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? )
var alt66=2;
var LA66_0 = this.input.LA(1);
if ( (LA66_0==LOC1) ) {
alt66=1;
}
else if ( (LA66_0==HCONSTLLN) ) {
alt66=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 66, 0, this.input);
throw nvae;
}
switch (alt66) {
case 1 :
// Ham4HMLGen.g:906:13: lc1= location1 (lc1x= location1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_location27031);
lc1=this.location1();
this.state._fsp--;
// Ham4HMLGen.g:907:13: (lc1x= location1 )?
var alt64=2;
var LA64_0 = this.input.LA(1);
if ( (LA64_0==LOC1) ) {
alt64=1;
}
switch (alt64) {
case 1 :
// Ham4HMLGen.g:907:15: lc1x= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_location27052);
lc1x=this.location1();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:909:13: hc= handconstellation ( HamArmextended | lb= locationbody )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconstellation_in_location27088);
hc=this.handconstellation();
this.state._fsp--;
// Ham4HMLGen.g:910:13: ( HamArmextended | lb= locationbody )?
var alt65=3;
var LA65_0 = this.input.LA(1);
if ( (LA65_0==HamArmextended) ) {
alt65=1;
}
else if ( (LA65_0==LOCTNBODY) ) {
alt65=2;
}
switch (alt65) {
case 1 :
// Ham4HMLGen.g:911:23: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_location27126); 
ext = "true"; 
break;
case 2 :
// Ham4HMLGen.g:913:17: lb= locationbody
this.pushFollow(Ham4HMLGen.FOLLOW_locationbody_in_location27172);
lb=this.locationbody();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rloc = hBuilder.newHMLElement("location2");
if (lc1 != null) {
rloc.appendChild(lc1);
hBuilder.checkedAppendChild(rloc, lc1x);
}
else {
rloc.appendChild(hc);
if (lb != null) {
rloc.appendChild(lb);
}
else if (ext != null) {
var neut = hBuilder.newHMLElement("hamneutral");
hBuilder.checkedSetAttr(neut, "armextended", ext);
rloc.appendChild(neut);
}
/* else nothing */
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rloc;
},
// Ham4HMLGen.g:938:1: location1 returns [Element rloc = null] : ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) ) ;
// $ANTLR start "location1"
location1: function() {
var rloc =  null;
var dig = null;
var loc = null;
try {
// Ham4HMLGen.g:941:5: ( ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) ) )
// Ham4HMLGen.g:942:5: ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) )
this.match(this.input,LOC1,Ham4HMLGen.FOLLOW_LOC1_in_location17243); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:943:9: (dig= digit | loc= locationhand | loc= locationbodyarm )
var alt67=3;
switch ( this.input.LA(1) ) {
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt67=1;
break;
case LOCTNHAND:
alt67=2;
break;
case LOCTNBODYARM:
alt67=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 67, 0, this.input);
throw nvae;
}
switch (alt67) {
case 1 :
// Ham4HMLGen.g:944:13: dig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_location17271);
dig=this.digit();
this.state._fsp--;
var dstr = dig.getAttribute("fingerid");
var ipos = "ham_digit_".length();
var locstr = "loc" + dstr.substring(ipos);
loc = hBuilder.newHMLElement("use_locname");
loc.setAttribute("use_locname", locstr);
break;
case 2 :
// Ham4HMLGen.g:953:13: loc= locationhand
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_location17313);
loc=this.locationhand();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:955:13: loc= locationbodyarm
this.pushFollow(Ham4HMLGen.FOLLOW_locationbodyarm_in_location17341);
loc=this.locationbodyarm();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rloc = hBuilder.newHMLElement("location1");
rloc.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rloc;
},
// Ham4HMLGen.g:965:1: locationbodyarm returns [Element rlba = null] : ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) ) ;
// $ANTLR start "locationbodyarm"
locationbodyarm: function() {
var rlba =  null;
var loc = null;
var  ext = null;
try {
// Ham4HMLGen.g:971:5: ( ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) ) )
// Ham4HMLGen.g:972:5: ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) )
this.match(this.input,LOCTNBODYARM,Ham4HMLGen.FOLLOW_LOCTNBODYARM_in_locationbodyarm7395); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:973:9: (loc= locationbody | loc= locationarm | ( HamArmextended )? )
var alt69=3;
switch ( this.input.LA(1) ) {
case LOCTNBODY:
alt69=1;
break;
case LOCTNARM:
alt69=2;
break;
case UP:
case HamArmextended:
alt69=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 69, 0, this.input);
throw nvae;
}
switch (alt69) {
case 1 :
// Ham4HMLGen.g:974:13: loc= locationbody
this.pushFollow(Ham4HMLGen.FOLLOW_locationbody_in_locationbodyarm7423);
loc=this.locationbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:976:13: loc= locationarm
this.pushFollow(Ham4HMLGen.FOLLOW_locationarm_in_locationbodyarm7451);
loc=this.locationarm();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:978:13: ( HamArmextended )?
// Ham4HMLGen.g:978:13: ( HamArmextended )?
var alt68=2;
var LA68_0 = this.input.LA(1);
if ( (LA68_0==HamArmextended) ) {
alt68=1;
}
switch (alt68) {
case 1 :
// Ham4HMLGen.g:978:15: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_locationbodyarm7477); 
ext = "true"; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
if (loc == null) {
loc =  hBuilder.newHMLElement("hamneutral");
hBuilder.checkedSetAttr(loc, "armextended", ext);
}
rlba = hBuilder.newHMLElement("locationbodyarm");
rlba.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlba;
},
// Ham4HMLGen.g:991:1: locationbody returns [Element rlb = null] : ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? ) ;
// $ANTLR start "locationbody"
locationbody: function() {
var rlb =  null;
var lcb = null;
var cb = null;
var hb  = null;
try {
// Ham4HMLGen.g:997:5: ( ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? ) )
// Ham4HMLGen.g:998:5: ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? )
this.match(this.input,LOCTNBODY,Ham4HMLGen.FOLLOW_LOCTNBODY_in_locationbody7546); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexbody_in_locationbody7564);
lcb=this.levelcomplexbody();
this.state._fsp--;
// Ham4HMLGen.g:1000:9: ( HamBehind )?
var alt70=2;
var LA70_0 = this.input.LA(1);
if ( (LA70_0==HamBehind) ) {
alt70=1;
}
switch (alt70) {
case 1 :
// Ham4HMLGen.g:1000:19: HamBehind
this.match(this.input,HamBehind,Ham4HMLGen.FOLLOW_HamBehind_in_locationbody7584); 
hb = hBuilder.newHMLElement("hambehind"); 
break;
}
// Ham4HMLGen.g:1003:9: (cb= contactbody )?
var alt71=2;
var LA71_0 = this.input.LA(1);
if ( (LA71_0==CNTCTBODY) ) {
alt71=1;
}
switch (alt71) {
case 1 :
// Ham4HMLGen.g:1003:11: cb= contactbody
this.pushFollow(Ham4HMLGen.FOLLOW_contactbody_in_locationbody7640);
cb=this.contactbody();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlb = hBuilder.newHMLElement("locationbody");
rlb.appendChild(lcb);
hBuilder.checkedAppendChild(rlb, hb);
hBuilder.checkedAppendChild(rlb, cb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1013:1: locationhand returns [Element rlh = null] : ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? ) ;
// $ANTLR start "locationhand"
locationhand: function() {
var rlh =  null;
var lch = null;
var ch = null;
try {
// Ham4HMLGen.g:1016:5: ( ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? ) )
// Ham4HMLGen.g:1017:5: ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? )
this.match(this.input,LOCTNHAND,Ham4HMLGen.FOLLOW_LOCTNHAND_in_locationhand7686); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexhand_in_locationhand7704);
lch=this.levelcomplexhand();
this.state._fsp--;
// Ham4HMLGen.g:1019:9: (ch= contacthand )?
var alt72=2;
var LA72_0 = this.input.LA(1);
if ( (LA72_0==CNTCTHAND) ) {
alt72=1;
}
switch (alt72) {
case 1 :
// Ham4HMLGen.g:1019:11: ch= contacthand
this.pushFollow(Ham4HMLGen.FOLLOW_contacthand_in_locationhand7723);
ch=this.contacthand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlh = hBuilder.newHMLElement("locationhand");
rlh.appendChild(lch);
hBuilder.checkedAppendChild(rlh, ch);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlh;
},
// Ham4HMLGen.g:1028:1: locationarm returns [Element rla = null] : ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? ) ;
// $ANTLR start "locationarm"
locationarm: function() {
var rla =  null;
var lca = null;
var cb = null;
var hb  = null;
try {
// Ham4HMLGen.g:1034:5: ( ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? ) )
// Ham4HMLGen.g:1035:5: ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? )
this.match(this.input,LOCTNARM,Ham4HMLGen.FOLLOW_LOCTNARM_in_locationarm7774); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexarm_in_locationarm7792);
lca=this.levelcomplexarm();
this.state._fsp--;
// Ham4HMLGen.g:1037:9: ( HamBehind )?
var alt73=2;
var LA73_0 = this.input.LA(1);
if ( (LA73_0==HamBehind) ) {
alt73=1;
}
switch (alt73) {
case 1 :
// Ham4HMLGen.g:1037:19: HamBehind
this.match(this.input,HamBehind,Ham4HMLGen.FOLLOW_HamBehind_in_locationarm7812); 
hb = hBuilder.newHMLElement("hambehind"); 
break;
}
// Ham4HMLGen.g:1040:9: (cb= contactbody )?
var alt74=2;
var LA74_0 = this.input.LA(1);
if ( (LA74_0==CNTCTBODY) ) {
alt74=1;
}
switch (alt74) {
case 1 :
// Ham4HMLGen.g:1040:11: cb= contactbody
this.pushFollow(Ham4HMLGen.FOLLOW_contactbody_in_locationarm7868);
cb=this.contactbody();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rla = hBuilder.newHMLElement("locationarm");
rla.appendChild(lca);
hBuilder.checkedAppendChild(rla, hb);
hBuilder.checkedAppendChild(rla, cb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1050:1: levelcomplexbody returns [Element rlcb = null] : lba= levelbody (lbb= levelbody )? ;
// $ANTLR start "levelcomplexbody"
levelcomplexbody: function() {
var rlcb =  null;
var lba = null;
var lbb = null;
try {
// Ham4HMLGen.g:1053:5: (lba= levelbody (lbb= levelbody )? )
// Ham4HMLGen.g:1053:9: lba= levelbody (lbb= levelbody )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_levelcomplexbody7919);
lba=this.levelbody();
this.state._fsp--;
// Ham4HMLGen.g:1054:9: (lbb= levelbody )?
var alt75=2;
var LA75_0 = this.input.LA(1);
if ( (LA75_0==LEVBODY) ) {
alt75=1;
}
switch (alt75) {
case 1 :
// Ham4HMLGen.g:1054:11: lbb= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_levelcomplexbody7937);
lbb=this.levelbody();
this.state._fsp--;
break;
}
rlcb = hBuilder.newHMLElement("levelcomplexbody");
rlcb.appendChild(lba);
hBuilder.checkedAppendChild(rlcb, lbb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlcb;
},
// Ham4HMLGen.g:1062:1: levelcomplexhand returns [Element rlch = null] : lha= levelhand (lhb= levelhand )? ;
// $ANTLR start "levelcomplexhand"
levelcomplexhand: function() {
var rlch =  null;
var lha = null;
var lhb = null;
try {
// Ham4HMLGen.g:1065:5: (lha= levelhand (lhb= levelhand )? )
// Ham4HMLGen.g:1065:9: lha= levelhand (lhb= levelhand )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelhand_in_levelcomplexhand7982);
lha=this.levelhand();
this.state._fsp--;
// Ham4HMLGen.g:1066:9: (lhb= levelhand )?
var alt76=2;
var LA76_0 = this.input.LA(1);
if ( (LA76_0==LEVHAND) ) {
alt76=1;
}
switch (alt76) {
case 1 :
// Ham4HMLGen.g:1066:11: lhb= levelhand
this.pushFollow(Ham4HMLGen.FOLLOW_levelhand_in_levelcomplexhand8000);
lhb=this.levelhand();
this.state._fsp--;
break;
}
rlch = hBuilder.newHMLElement("levelcomplexhand");
rlch.appendChild(lha);
hBuilder.checkedAppendChild(rlch, lhb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlch;
},
// Ham4HMLGen.g:1074:1: levelcomplexarm returns [Element rlca = null] : laa= levelarm (lab= levelarm )? ;
// $ANTLR start "levelcomplexarm"
levelcomplexarm: function() {
var rlca =  null;
var laa = null;
var lab = null;
try {
// Ham4HMLGen.g:1077:5: (laa= levelarm (lab= levelarm )? )
// Ham4HMLGen.g:1077:9: laa= levelarm (lab= levelarm )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_levelcomplexarm8046);
laa=this.levelarm();
this.state._fsp--;
// Ham4HMLGen.g:1078:9: (lab= levelarm )?
var alt77=2;
var LA77_0 = this.input.LA(1);
if ( (LA77_0==LEVARM) ) {
alt77=1;
}
switch (alt77) {
case 1 :
// Ham4HMLGen.g:1078:11: lab= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_levelcomplexarm8064);
lab=this.levelarm();
this.state._fsp--;
break;
}
rlca = hBuilder.newHMLElement("levelcomplexarm");
rlca.appendChild(laa);
hBuilder.checkedAppendChild(rlca, lab);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlca;
},
// Ham4HMLGen.g:1086:1: levelbody returns [Element rlb = null] : ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelbody"
levelbody: function() {
var rlb =  null;
var sd = null;
var lb = null;
var approxlb = false;
try {
// Ham4HMLGen.g:1092:5: ( ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1093:5: ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? )
this.match(this.input,LEVBODY,Ham4HMLGen.FOLLOW_LEVBODY_in_levelbody8111); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1094:9: (sd= side[\"left\"] )?
var alt78=2;
var LA78_0 = this.input.LA(1);
if ( ((LA78_0>=HamLrbeside && LA78_0<=HamLrat)) ) {
alt78=1;
}
switch (alt78) {
case 1 :
// Ham4HMLGen.g:1094:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelbody8130);
sd=this.side("left");
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1095:9: (lb= locbody | lb= locsided )
var alt79=2;
var LA79_0 = this.input.LA(1);
if ( (LA79_0==LOCBODY) ) {
alt79=1;
}
else if ( (LA79_0==HamEarlobe||(LA79_0>=HamEar && LA79_0<=HamCheek)) ) {
alt79=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 79, 0, this.input);
throw nvae;
}
switch (alt79) {
case 1 :
// Ham4HMLGen.g:1096:13: lb= locbody
this.pushFollow(Ham4HMLGen.FOLLOW_locbody_in_levelbody8163);
lb=this.locbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1098:13: lb= locsided
this.pushFollow(Ham4HMLGen.FOLLOW_locsided_in_levelbody8192);
lb=this.locsided();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1100:9: ( HamEtc )?
var alt80=2;
var LA80_0 = this.input.LA(1);
if ( (LA80_0==HamEtc) ) {
alt80=1;
}
switch (alt80) {
case 1 :
// Ham4HMLGen.g:1100:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_levelbody8222); 
approxlb = true; 
break;
}
// Ham4HMLGen.g:1101:9: (sd= side[\"right\"] )?
var alt81=2;
var LA81_0 = this.input.LA(1);
if ( ((LA81_0>=HamLrbeside && LA81_0<=HamLrat)) ) {
alt81=1;
}
switch (alt81) {
case 1 :
// Ham4HMLGen.g:1101:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelbody8257);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlb = hBuilder.newHMLElement("levelbody");
rlb.setAttribute("locbody", lb);
hBuilder.checkedSetAttr(rlb, "side", sd);
hBuilder.checkedSetFlagAttr(rlb, "approx_location", approxlb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1111:1: levelhand returns [Element rlh = null] : ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelhand"
levelhand: function() {
var rlh =  null;
var sd = null;
var hp = null;
var fp = null;
var d = null;
var dp = null;
rlh = hBuilder.newHMLElement("levelhand");
try {
// Ham4HMLGen.g:1117:5: ( ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1118:5: ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? )
this.match(this.input,LEVHAND,Ham4HMLGen.FOLLOW_LEVHAND_in_levelhand8311); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1119:9: (sd= side[\"left\"] )?
var alt82=2;
var LA82_0 = this.input.LA(1);
if ( ((LA82_0>=HamLrbeside && LA82_0<=HamLrat)) ) {
alt82=1;
}
switch (alt82) {
case 1 :
// Ham4HMLGen.g:1119:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelhand8330);
sd=this.side("left");
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1120:9: (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? )
var alt86=3;
switch ( this.input.LA(1) ) {
case HamWristback:
case HamWristpulse:
case HamThumbball:
case HamPalm:
case HamHandback:
case HamThumbside:
case HamPinkyside:
alt86=1;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt86=2;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt86=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 86, 0, this.input);
throw nvae;
}
switch (alt86) {
case 1 :
// Ham4HMLGen.g:1121:13: hp= handpart
this.pushFollow(Ham4HMLGen.FOLLOW_handpart_in_levelhand8363);
hp=this.handpart();
this.state._fsp--;
rlh.appendChild(hp); 
break;
case 2 :
// Ham4HMLGen.g:1124:13: fp= fingerpart (d= digit )*
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_levelhand8402);
fp=this.fingerpart();
this.state._fsp--;
rlh.appendChild(fp); 
// Ham4HMLGen.g:1125:13: (d= digit )*
loop83:
do {
var alt83=2;
var LA83_0 = this.input.LA(1);
if ( ((LA83_0>=HamThumb && LA83_0<=HamPinky)) ) {
alt83=1;
}
switch (alt83) {
case 1 :
// Ham4HMLGen.g:1125:15: d= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_levelhand8433);
d=this.digit();
this.state._fsp--;
rlh.appendChild(d); 
break;
default :
break loop83;
}
} while (true);
break;
case 3 :
// Ham4HMLGen.g:1127:13: (d= digit )+ (fp= fingerpart )?
// Ham4HMLGen.g:1127:13: (d= digit )+
var cnt84=0;
loop84:
do {
var alt84=2;
var LA84_0 = this.input.LA(1);
if ( ((LA84_0>=HamThumb && LA84_0<=HamPinky)) ) {
alt84=1;
}
switch (alt84) {
case 1 :
// Ham4HMLGen.g:1127:15: d= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_levelhand8476);
d=this.digit();
this.state._fsp--;
rlh.appendChild(d); 
break;
default :
if ( cnt84 >= 1 ) {
break loop84;
}
var eee = new org.antlr.runtime.EarlyExitException(84, this.input);
throw eee;
}
cnt84++;
} while (true);
// Ham4HMLGen.g:1128:13: (fp= fingerpart )?
var alt85=2;
var LA85_0 = this.input.LA(1);
if ( ((LA85_0>=HamFingertip && LA85_0<=HamFingerside)) ) {
alt85=1;
}
switch (alt85) {
case 1 :
// Ham4HMLGen.g:1128:15: fp= fingerpart
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_levelhand8510);
fp=this.fingerpart();
this.state._fsp--;
rlh.appendChild(fp); 
break;
}
break;
}
// Ham4HMLGen.g:1139:9: (dp= dorsalorpalmar )?
var alt87=2;
var LA87_0 = this.input.LA(1);
if ( ((LA87_0>=HamPalm && LA87_0<=HamHandback)) ) {
alt87=1;
}
switch (alt87) {
case 1 :
// Ham4HMLGen.g:1139:11: dp= dorsalorpalmar
this.pushFollow(Ham4HMLGen.FOLLOW_dorsalorpalmar_in_levelhand8553);
dp=this.dorsalorpalmar();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1140:9: (sd= side[\"right\"] )?
var alt88=2;
var LA88_0 = this.input.LA(1);
if ( ((LA88_0>=HamLrbeside && LA88_0<=HamLrat)) ) {
alt88=1;
}
switch (alt88) {
case 1 :
// Ham4HMLGen.g:1140:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelhand8575);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
// Check for HNS-3 to HNS-4 conversion:
if (hp != null) {
if (hp.getAttribute("handpart") === "ham_wristpulse") {
hp.setAttribute("handpart", "ham_wristback");
rlh.setAttribute("dorsal_or_palmar", "palmar");
}
}
else
if (fp != null) {
if (fp.getAttribute("fingerpart") === "ham_finger_pad") {
fp.setAttribute("fingerpart", "ham_finger_nail");
rlh.setAttribute("dorsal_or_palmar", "palmar");
}
}
hBuilder.checkedSetAttr(rlh, "side", sd);
hBuilder.checkedSetAttr(rlh, "dorsal_or_palmar", dp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlh;
},
// Ham4HMLGen.g:1163:1: levelarm returns [Element rla = null] : ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelarm"
levelarm: function() {
var rla =  null;
var sd = null;
var la = null;
var dp = null;
var approxla = false;
try {
// Ham4HMLGen.g:1169:5: ( ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1170:5: ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? )
this.match(this.input,LEVARM,Ham4HMLGen.FOLLOW_LEVARM_in_levelarm8630); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1171:9: (sd= side[\"left\"] )?
var alt89=2;
var LA89_0 = this.input.LA(1);
if ( ((LA89_0>=HamLrbeside && LA89_0<=HamLrat)) ) {
alt89=1;
}
switch (alt89) {
case 1 :
// Ham4HMLGen.g:1171:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelarm8649);
sd=this.side("left");
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_locarm_in_levelarm8672);
la=this.locarm();
this.state._fsp--;
// Ham4HMLGen.g:1173:9: ( HamEtc )?
var alt90=2;
var LA90_0 = this.input.LA(1);
if ( (LA90_0==HamEtc) ) {
alt90=1;
}
switch (alt90) {
case 1 :
// Ham4HMLGen.g:1173:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_levelarm8692); 
approxla = true; 
break;
}
// Ham4HMLGen.g:1174:9: (dp= dorsalorpalmar )?
var alt91=2;
var LA91_0 = this.input.LA(1);
if ( ((LA91_0>=HamPalm && LA91_0<=HamHandback)) ) {
alt91=1;
}
switch (alt91) {
case 1 :
// Ham4HMLGen.g:1174:11: dp= dorsalorpalmar
this.pushFollow(Ham4HMLGen.FOLLOW_dorsalorpalmar_in_levelarm8727);
dp=this.dorsalorpalmar();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1175:9: (sd= side[\"right\"] )?
var alt92=2;
var LA92_0 = this.input.LA(1);
if ( ((LA92_0>=HamLrbeside && LA92_0<=HamLrat)) ) {
alt92=1;
}
switch (alt92) {
case 1 :
// Ham4HMLGen.g:1175:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelarm8749);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rla = hBuilder.newHMLElement("levelarm");
rla.setAttribute("locarm", la);
hBuilder.checkedSetAttr(rla, "side", sd);
hBuilder.checkedSetAttr(rla, "dorsal_or_palmar", dp);
hBuilder.checkedSetFlagAttr(rla, "approx_location", approxla);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1186:1: contactbody returns [Element rcb = null] : ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) ) ;
// $ANTLR start "contactbody"
contactbody: function() {
var rcb =  null;
var cbsub = null;
try {
// Ham4HMLGen.g:1189:5: ( ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) ) )
// Ham4HMLGen.g:1190:5: ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) )
this.match(this.input,CNTCTBODY,Ham4HMLGen.FOLLOW_CNTCTBODY_in_contactbody8797); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1191:9: (cbsub= pcontact | HamArmextended | cbsub= contactofhand )
var alt93=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt93=1;
break;
case HamArmextended:
alt93=2;
break;
case CNTCTOFHAND:
alt93=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 93, 0, this.input);
throw nvae;
}
switch (alt93) {
case 1 :
// Ham4HMLGen.g:1192:13: cbsub= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contactbody8827);
cbsub=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1194:13: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_contactbody8851); 
cbsub = hBuilder.newHMLElement("hamarmextended"); 
break;
case 3 :
// Ham4HMLGen.g:1197:13: cbsub= contactofhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactofhand_in_contactbody8903);
cbsub=this.contactofhand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcb = hBuilder.wrapperEl("contactbody", cbsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcb;
},
// Ham4HMLGen.g:1205:1: contacthand returns [Element rch = null] : ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) ) ;
// $ANTLR start "contacthand"
contacthand: function() {
var rch =  null;
var chsub = null;
try {
// Ham4HMLGen.g:1208:5: ( ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) ) )
// Ham4HMLGen.g:1209:5: ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) )
this.match(this.input,CNTCTHAND,Ham4HMLGen.FOLLOW_CNTCTHAND_in_contacthand8957); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1210:9: (chsub= pcontact | chsub= ccontact | chsub= contactofhand )
var alt94=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt94=1;
break;
case HamInterlock:
case HamCross:
alt94=2;
break;
case CNTCTOFHAND:
alt94=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 0, this.input);
throw nvae;
}
switch (alt94) {
case 1 :
// Ham4HMLGen.g:1211:13: chsub= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contacthand8987);
chsub=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1213:13: chsub= ccontact
this.pushFollow(Ham4HMLGen.FOLLOW_ccontact_in_contacthand9017);
chsub=this.ccontact();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1215:13: chsub= contactofhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactofhand_in_contacthand9047);
chsub=this.contactofhand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rch = hBuilder.wrapperEl("contacthand", chsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rch;
},
// Ham4HMLGen.g:1229:1: contactofhand returns [Element rcoh = null] : ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) ) ;
// $ANTLR start "contactofhand"
contactofhand: function() {
var rcoh =  null;
var pc = null;
var loc = null;
try {
// Ham4HMLGen.g:1232:5: ( ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) ) )
// Ham4HMLGen.g:1233:5: ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) )
this.match(this.input,CNTCTOFHAND,Ham4HMLGen.FOLLOW_CNTCTOFHAND_in_contactofhand9109); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1234:9: (pc= pcontact | pc= ccontact )
var alt95=2;
var LA95_0 = this.input.LA(1);
if ( ((LA95_0>=HamClose && LA95_0<=HamTouch)) ) {
alt95=1;
}
else if ( ((LA95_0>=HamInterlock && LA95_0<=HamCross)) ) {
alt95=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 95, 0, this.input);
throw nvae;
}
switch (alt95) {
case 1 :
// Ham4HMLGen.g:1235:13: pc= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contactofhand9142);
pc=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1237:13: pc= ccontact
this.pushFollow(Ham4HMLGen.FOLLOW_ccontact_in_contactofhand9175);
pc=this.ccontact();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1239:9: (loc= contactohhand | loc= contactoharm )
var alt96=2;
var LA96_0 = this.input.LA(1);
if ( (LA96_0==CNTCTOHHAND) ) {
alt96=1;
}
else if ( (LA96_0==CNTCTOHARM) ) {
alt96=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 96, 0, this.input);
throw nvae;
}
switch (alt96) {
case 1 :
// Ham4HMLGen.g:1240:13: loc= contactohhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactohhand_in_contactofhand9217);
loc=this.contactohhand();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1242:13: loc= contactoharm
this.pushFollow(Ham4HMLGen.FOLLOW_contactoharm_in_contactofhand9249);
loc=this.contactoharm();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcoh = hBuilder.newHMLElement("contactofhand");
rcoh.appendChild(pc);
rcoh.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcoh;
},
// Ham4HMLGen.g:1252:1: contactohhand returns [Element rcohh = null] : ^( CNTCTOHHAND cohh= levelcomplexhand ) ;
// $ANTLR start "contactohhand"
contactohhand: function() {
var rcohh =  null;
var cohh = null;
try {
// Ham4HMLGen.g:1256:5: ( ^( CNTCTOHHAND cohh= levelcomplexhand ) )
// Ham4HMLGen.g:1257:5: ^( CNTCTOHHAND cohh= levelcomplexhand )
this.match(this.input,CNTCTOHHAND,Ham4HMLGen.FOLLOW_CNTCTOHHAND_in_contactohhand9305); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexhand_in_contactohhand9319);
cohh=this.levelcomplexhand();
this.state._fsp--;
rcohh = cohh; 
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcohh;
},
// Ham4HMLGen.g:1262:1: contactoharm returns [Element rcoha = null] : ^( CNTCTOHARM coha= levelcomplexarm ) ;
// $ANTLR start "contactoharm"
contactoharm: function() {
var rcoha =  null;
var coha = null;
try {
// Ham4HMLGen.g:1266:5: ( ^( CNTCTOHARM coha= levelcomplexarm ) )
// Ham4HMLGen.g:1267:5: ^( CNTCTOHARM coha= levelcomplexarm )
this.match(this.input,CNTCTOHARM,Ham4HMLGen.FOLLOW_CNTCTOHARM_in_contactoharm9364); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexarm_in_contactoharm9378);
coha=this.levelcomplexarm();
this.state._fsp--;
rcoha = coha; 
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcoha;
},
// Ham4HMLGen.g:1272:1: handconstellation returns [Element rhc = null] : ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand ) ;
// $ANTLR start "handconstellation"
handconstellation: function() {
var rhc =  null;
var lha = null;
var lhb = null;
var ch = null;
try {
// Ham4HMLGen.g:1275:5: ( ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand ) )
// Ham4HMLGen.g:1276:5: ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand )
this.match(this.input,HCONSTLLN,Ham4HMLGen.FOLLOW_HCONSTLLN_in_handconstellation9420); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1277:9: (lha= locationhand lhb= locationhand )?
var alt97=2;
var LA97_0 = this.input.LA(1);
if ( (LA97_0==LOCTNHAND) ) {
alt97=1;
}
switch (alt97) {
case 1 :
// Ham4HMLGen.g:1278:13: lha= locationhand lhb= locationhand
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_handconstellation9448);
lha=this.locationhand();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_handconstellation9466);
lhb=this.locationhand();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_contacthand_in_handconstellation9496);
ch=this.contacthand();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconstellation");
hBuilder.checkedAppendChild(rhc, lha);
hBuilder.checkedAppendChild(rhc, lhb);
rhc.appendChild(ch);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:1294:1: locarm returns [String rla = null] : ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm ) ;
// $ANTLR start "locarm"
locarm: function() {
var rla =  null;
try {
// Ham4HMLGen.g:1296:5: ( ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm ) )
// Ham4HMLGen.g:1297:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
// Ham4HMLGen.g:1297:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
var alt98=4;
switch ( this.input.LA(1) ) {
case HamUpperarm:
alt98=1;
break;
case HamElbow:
alt98=2;
break;
case HamElbowinside:
alt98=3;
break;
case HamLowerarm:
alt98=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 98, 0, this.input);
throw nvae;
}
switch (alt98) {
case 1 :
// Ham4HMLGen.g:1297:9: HamUpperarm
this.match(this.input,HamUpperarm,Ham4HMLGen.FOLLOW_HamUpperarm_in_locarm9551); 
rla = "ham_upperarm"; 
break;
case 2 :
// Ham4HMLGen.g:1298:9: HamElbow
this.match(this.input,HamElbow,Ham4HMLGen.FOLLOW_HamElbow_in_locarm9575); 
rla = "ham_elbow"; 
break;
case 3 :
// Ham4HMLGen.g:1299:9: HamElbowinside
this.match(this.input,HamElbowinside,Ham4HMLGen.FOLLOW_HamElbowinside_in_locarm9602); 
rla = "ham_elbowinside"; 
break;
case 4 :
// Ham4HMLGen.g:1300:9: HamLowerarm
this.match(this.input,HamLowerarm,Ham4HMLGen.FOLLOW_HamLowerarm_in_locarm9623); 
rla = "ham_lowerarm"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1304:1: locbody returns [String rlb = null] : ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? ) ;
// $ANTLR start "locbody"
locbody: function() {
var rlb =  null;
var uprlwr = null;
try {
// Ham4HMLGen.g:1309:5: ( ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? ) )
// Ham4HMLGen.g:1310:5: ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? )
this.match(this.input,LOCBODY,Ham4HMLGen.FOLLOW_LOCBODY_in_locbody9683); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1311:9: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
var alt99=18;
switch ( this.input.LA(1) ) {
case HamHead:
alt99=1;
break;
case HamHeadtop:
alt99=2;
break;
case HamForehead:
alt99=3;
break;
case HamEyebrows:
alt99=4;
break;
case HamEyes:
alt99=5;
break;
case HamNose:
alt99=6;
break;
case HamNostrils:
alt99=7;
break;
case HamLips:
alt99=8;
break;
case HamTongue:
alt99=9;
break;
case HamTeeth:
alt99=10;
break;
case HamChin:
alt99=11;
break;
case HamUnderchin:
alt99=12;
break;
case HamNeck:
alt99=13;
break;
case HamShouldertop:
alt99=14;
break;
case HamShoulders:
alt99=15;
break;
case HamChest:
alt99=16;
break;
case HamStomach:
alt99=17;
break;
case HamBelowstomach:
alt99=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 99, 0, this.input);
throw nvae;
}
switch (alt99) {
case 1 :
// Ham4HMLGen.g:1311:13: HamHead
this.match(this.input,HamHead,Ham4HMLGen.FOLLOW_HamHead_in_locbody9697); 
rlb = "ham_head"; 
break;
case 2 :
// Ham4HMLGen.g:1312:13: HamHeadtop
this.match(this.input,HamHeadtop,Ham4HMLGen.FOLLOW_HamHeadtop_in_locbody9729); 
rlb = "ham_headtop"; 
break;
case 3 :
// Ham4HMLGen.g:1313:13: HamForehead
this.match(this.input,HamForehead,Ham4HMLGen.FOLLOW_HamForehead_in_locbody9758); 
rlb = "ham_forehead"; 
break;
case 4 :
// Ham4HMLGen.g:1314:13: HamEyebrows
this.match(this.input,HamEyebrows,Ham4HMLGen.FOLLOW_HamEyebrows_in_locbody9786); 
rlb = "ham_eyebrows"; 
break;
case 5 :
// Ham4HMLGen.g:1315:13: HamEyes
this.match(this.input,HamEyes,Ham4HMLGen.FOLLOW_HamEyes_in_locbody9814); 
rlb = "ham_eyes"; 
break;
case 6 :
// Ham4HMLGen.g:1316:13: HamNose
this.match(this.input,HamNose,Ham4HMLGen.FOLLOW_HamNose_in_locbody9846); 
rlb = "ham_nose"; 
break;
case 7 :
// Ham4HMLGen.g:1317:13: HamNostrils
this.match(this.input,HamNostrils,Ham4HMLGen.FOLLOW_HamNostrils_in_locbody9878); 
rlb = "ham_nostrils"; 
break;
case 8 :
// Ham4HMLGen.g:1318:13: HamLips
this.match(this.input,HamLips,Ham4HMLGen.FOLLOW_HamLips_in_locbody9906); 
rlb = "ham_lips"; 
break;
case 9 :
// Ham4HMLGen.g:1319:13: HamTongue
this.match(this.input,HamTongue,Ham4HMLGen.FOLLOW_HamTongue_in_locbody9938); 
rlb = "ham_tongue"; 
break;
case 10 :
// Ham4HMLGen.g:1320:13: HamTeeth
this.match(this.input,HamTeeth,Ham4HMLGen.FOLLOW_HamTeeth_in_locbody9968); 
rlb = "ham_teeth"; 
break;
case 11 :
// Ham4HMLGen.g:1321:13: HamChin
this.match(this.input,HamChin,Ham4HMLGen.FOLLOW_HamChin_in_locbody9999); 
rlb = "ham_chin"; 
break;
case 12 :
// Ham4HMLGen.g:1322:13: HamUnderchin
this.match(this.input,HamUnderchin,Ham4HMLGen.FOLLOW_HamUnderchin_in_locbody10031); 
rlb = "ham_underchin"; 
break;
case 13 :
// Ham4HMLGen.g:1323:13: HamNeck
this.match(this.input,HamNeck,Ham4HMLGen.FOLLOW_HamNeck_in_locbody10058); 
rlb = "ham_neck"; 
break;
case 14 :
// Ham4HMLGen.g:1324:13: HamShouldertop
this.match(this.input,HamShouldertop,Ham4HMLGen.FOLLOW_HamShouldertop_in_locbody10090); 
rlb = "ham_shouldertop"; 
break;
case 15 :
// Ham4HMLGen.g:1325:13: HamShoulders
this.match(this.input,HamShoulders,Ham4HMLGen.FOLLOW_HamShoulders_in_locbody10115); 
rlb = "ham_shoulders"; 
break;
case 16 :
// Ham4HMLGen.g:1326:13: HamChest
this.match(this.input,HamChest,Ham4HMLGen.FOLLOW_HamChest_in_locbody10142); 
rlb = "ham_chest"; 
break;
case 17 :
// Ham4HMLGen.g:1327:13: HamStomach
this.match(this.input,HamStomach,Ham4HMLGen.FOLLOW_HamStomach_in_locbody10173); 
rlb = "ham_stomach"; 
break;
case 18 :
// Ham4HMLGen.g:1328:13: HamBelowstomach
this.match(this.input,HamBelowstomach,Ham4HMLGen.FOLLOW_HamBelowstomach_in_locbody10202); 
rlb = "ham_belowstomach"; 
break;
}
// Ham4HMLGen.g:1330:9: ( HamDoublebent | HamDoublehooked )?
var alt100=3;
var LA100_0 = this.input.LA(1);
if ( (LA100_0==HamDoublebent) ) {
alt100=1;
}
else if ( (LA100_0==HamDoublehooked) ) {
alt100=2;
}
switch (alt100) {
case 1 :
// Ham4HMLGen.g:1331:13: HamDoublebent
this.match(this.input,HamDoublebent,Ham4HMLGen.FOLLOW_HamDoublebent_in_locbody10246); 
uprlwr = "ham_upper"; 
break;
case 2 :
// Ham4HMLGen.g:1332:13: HamDoublehooked
this.match(this.input,HamDoublehooked,Ham4HMLGen.FOLLOW_HamDoublehooked_in_locbody10272); 
uprlwr = "ham_lower"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (uprlwr != null) {
if (rlb === "ham_eyes") {
rlb = uprlwr + "eyelid";
}
else
if (rlb === "ham_lips") {
rlb = uprlwr + "lip";
}
else
if (rlb === "ham_teeth") {
rlb = uprlwr + "teeth";
}
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1352:1: locsided returns [String rls = null] : ( HamEar | HamEarlobe | HamCheek ) ;
// $ANTLR start "locsided"
locsided: function() {
var rls =  null;
try {
// Ham4HMLGen.g:1354:5: ( ( HamEar | HamEarlobe | HamCheek ) )
// Ham4HMLGen.g:1355:5: ( HamEar | HamEarlobe | HamCheek )
// Ham4HMLGen.g:1355:5: ( HamEar | HamEarlobe | HamCheek )
var alt101=3;
switch ( this.input.LA(1) ) {
case HamEar:
alt101=1;
break;
case HamEarlobe:
alt101=2;
break;
case HamCheek:
alt101=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 101, 0, this.input);
throw nvae;
}
switch (alt101) {
case 1 :
// Ham4HMLGen.g:1355:9: HamEar
this.match(this.input,HamEar,Ham4HMLGen.FOLLOW_HamEar_in_locsided10343); 
rls = "ham_ear"; 
break;
case 2 :
// Ham4HMLGen.g:1356:9: HamEarlobe
this.match(this.input,HamEarlobe,Ham4HMLGen.FOLLOW_HamEarlobe_in_locsided10372); 
rls = "ham_earlobe"; 
break;
case 3 :
// Ham4HMLGen.g:1357:9: HamCheek
this.match(this.input,HamCheek,Ham4HMLGen.FOLLOW_HamCheek_in_locsided10397); 
rls = "ham_cheek"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rls;
},
// Ham4HMLGen.g:1361:1: handpart returns [Element rhp = null] : ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside ) ;
// $ANTLR start "handpart"
handpart: function() {
var rhp =  null;
var  shp     = null;
try {
// Ham4HMLGen.g:1366:5: ( ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside ) )
// Ham4HMLGen.g:1367:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
// Ham4HMLGen.g:1367:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
var alt102=7;
switch ( this.input.LA(1) ) {
case HamWristback:
alt102=1;
break;
case HamWristpulse:
alt102=2;
break;
case HamThumbball:
alt102=3;
break;
case HamPalm:
alt102=4;
break;
case HamHandback:
alt102=5;
break;
case HamThumbside:
alt102=6;
break;
case HamPinkyside:
alt102=7;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 102, 0, this.input);
throw nvae;
}
switch (alt102) {
case 1 :
// Ham4HMLGen.g:1367:9: HamWristback
this.match(this.input,HamWristback,Ham4HMLGen.FOLLOW_HamWristback_in_handpart10462); 
shp = "ham_wristback"; 
break;
case 2 :
// Ham4HMLGen.g:1368:9: HamWristpulse
this.match(this.input,HamWristpulse,Ham4HMLGen.FOLLOW_HamWristpulse_in_handpart10485); 
shp = "ham_wristpulse"; 
break;
case 3 :
// Ham4HMLGen.g:1369:9: HamThumbball
this.match(this.input,HamThumbball,Ham4HMLGen.FOLLOW_HamThumbball_in_handpart10507); 
shp = "ham_thumbball"; 
break;
case 4 :
// Ham4HMLGen.g:1370:9: HamPalm
this.match(this.input,HamPalm,Ham4HMLGen.FOLLOW_HamPalm_in_handpart10530); 
shp = "ham_palm"; 
break;
case 5 :
// Ham4HMLGen.g:1371:9: HamHandback
this.match(this.input,HamHandback,Ham4HMLGen.FOLLOW_HamHandback_in_handpart10558); 
shp = "ham_handback"; 
break;
case 6 :
// Ham4HMLGen.g:1372:9: HamThumbside
this.match(this.input,HamThumbside,Ham4HMLGen.FOLLOW_HamThumbside_in_handpart10582); 
shp = "ham_thumbside"; 
break;
case 7 :
// Ham4HMLGen.g:1373:9: HamPinkyside
this.match(this.input,HamPinkyside,Ham4HMLGen.FOLLOW_HamPinkyside_in_handpart10605); 
shp = "ham_pinkyside"; 
break;
}
rhp = hBuilder.newHMLElement("handpart");
rhp.setAttribute("handpart", shp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhp;
},
// Ham4HMLGen.g:1381:1: side[lh_or_rh] returns [String rs = null] : ( HamLrbeside | HamLrat ) ;
// $ANTLR start "side"
side: function(lh_or_rh) {
var rs =  null;
try {
// Ham4HMLGen.g:1386:5: ( ( HamLrbeside | HamLrat ) )
// Ham4HMLGen.g:1387:5: ( HamLrbeside | HamLrat )
// Ham4HMLGen.g:1387:5: ( HamLrbeside | HamLrat )
var alt103=2;
var LA103_0 = this.input.LA(1);
if ( (LA103_0==HamLrbeside) ) {
alt103=1;
}
else if ( (LA103_0==HamLrat) ) {
alt103=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 103, 0, this.input);
throw nvae;
}
switch (alt103) {
case 1 :
// Ham4HMLGen.g:1387:9: HamLrbeside
this.match(this.input,HamLrbeside,Ham4HMLGen.FOLLOW_HamLrbeside_in_side10690); 
rs = "beside"; 
break;
case 2 :
// Ham4HMLGen.g:1388:9: HamLrat
this.match(this.input,HamLrat,Ham4HMLGen.FOLLOW_HamLrat_in_side10714); 
rs = "at"; 
break;
}
rs = "ham_" + lh_or_rh + "_" + rs;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rs;
},
// Ham4HMLGen.g:1395:1: dorsalorpalmar returns [String rdp = null] : ( HamHandback | HamPalm ) ;
// $ANTLR start "dorsalorpalmar"
dorsalorpalmar: function() {
var rdp =  null;
try {
// Ham4HMLGen.g:1398:5: ( ( HamHandback | HamPalm ) )
// Ham4HMLGen.g:1399:5: ( HamHandback | HamPalm )
// Ham4HMLGen.g:1399:5: ( HamHandback | HamPalm )
var alt104=2;
var LA104_0 = this.input.LA(1);
if ( (LA104_0==HamHandback) ) {
alt104=1;
}
else if ( (LA104_0==HamPalm) ) {
alt104=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 104, 0, this.input);
throw nvae;
}
switch (alt104) {
case 1 :
// Ham4HMLGen.g:1399:9: HamHandback
this.match(this.input,HamHandback,Ham4HMLGen.FOLLOW_HamHandback_in_dorsalorpalmar10776); 
rdp = "dorsal"; 
break;
case 2 :
// Ham4HMLGen.g:1400:9: HamPalm
this.match(this.input,HamPalm,Ham4HMLGen.FOLLOW_HamPalm_in_dorsalorpalmar10800); 
rdp = "palmar"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rdp;
},
// Ham4HMLGen.g:1404:1: pcontact returns [Element rpc = null] : ( HamTouch | HamClose ) ;
// $ANTLR start "pcontact"
pcontact: function() {
var rpc =  null;
var  spc     = null;
try {
// Ham4HMLGen.g:1409:5: ( ( HamTouch | HamClose ) )
// Ham4HMLGen.g:1410:5: ( HamTouch | HamClose )
// Ham4HMLGen.g:1410:5: ( HamTouch | HamClose )
var alt105=2;
var LA105_0 = this.input.LA(1);
if ( (LA105_0==HamTouch) ) {
alt105=1;
}
else if ( (LA105_0==HamClose) ) {
alt105=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 105, 0, this.input);
throw nvae;
}
switch (alt105) {
case 1 :
// Ham4HMLGen.g:1410:9: HamTouch
this.match(this.input,HamTouch,Ham4HMLGen.FOLLOW_HamTouch_in_pcontact10866); 
spc = "ham_touch"; 
break;
case 2 :
// Ham4HMLGen.g:1411:9: HamClose
this.match(this.input,HamClose,Ham4HMLGen.FOLLOW_HamClose_in_pcontact10893); 
spc = "ham_close"; 
break;
}
rpc = hBuilder.newHMLElement("pcontact");
rpc.setAttribute("where", spc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpc;
},
// Ham4HMLGen.g:1419:1: ccontact returns [Element rcc = null] : ( HamInterlock | HamCross ) ;
// $ANTLR start "ccontact"
ccontact: function() {
var rcc =  null;
var  scc     = null;
try {
// Ham4HMLGen.g:1424:5: ( ( HamInterlock | HamCross ) )
// Ham4HMLGen.g:1425:5: ( HamInterlock | HamCross )
// Ham4HMLGen.g:1425:5: ( HamInterlock | HamCross )
var alt106=2;
var LA106_0 = this.input.LA(1);
if ( (LA106_0==HamInterlock) ) {
alt106=1;
}
else if ( (LA106_0==HamCross) ) {
alt106=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 106, 0, this.input);
throw nvae;
}
switch (alt106) {
case 1 :
// Ham4HMLGen.g:1425:9: HamInterlock
this.match(this.input,HamInterlock,Ham4HMLGen.FOLLOW_HamInterlock_in_ccontact10964); 
scc = "ham_interlock"; 
break;
case 2 :
// Ham4HMLGen.g:1426:9: HamCross
this.match(this.input,HamCross,Ham4HMLGen.FOLLOW_HamCross_in_ccontact10987); 
scc = "ham_cross"; 
break;
}
rcc = hBuilder.newHMLElement("ccontact");
rcc.setAttribute("crosskind", scc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcc;
},
// Ham4HMLGen.g:1437:1: a2tstar returns [Element[] ral = null] : ^( A2TLIST (a2t= action2t )* ) ;
// $ANTLR start "a2tstar"
a2tstar: function() {
var ral =  null;
var a2t = null;
alist   = [];
try {
// Ham4HMLGen.g:1443:5: ( ^( A2TLIST (a2t= action2t )* ) )
// Ham4HMLGen.g:1444:5: ^( A2TLIST (a2t= action2t )* )
this.match(this.input,A2TLIST,Ham4HMLGen.FOLLOW_A2TLIST_in_a2tstar11059); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1445:9: (a2t= action2t )*
loop107:
do {
var alt107=2;
var LA107_0 = this.input.LA(1);
if ( (LA107_0==ACTION2T) ) {
alt107=1;
}
switch (alt107) {
case 1 :
// Ham4HMLGen.g:1445:11: a2t= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_a2tstar11077);
a2t=this.action2t();
this.state._fsp--;
alist.push(a2t); 
break;
default :
break loop107;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
ral = alist;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ral;
},
// Ham4HMLGen.g:1452:1: a1tstar returns [Element[] ral = null] : ^( A1TLIST (a1t= action1t )* ) ;
// $ANTLR start "a1tstar"
a1tstar: function() {
var ral =  null;
var a1t = null;
var alist   = [];
try {
// Ham4HMLGen.g:1458:5: ( ^( A1TLIST (a1t= action1t )* ) )
// Ham4HMLGen.g:1459:5: ^( A1TLIST (a1t= action1t )* )
this.match(this.input,A1TLIST,Ham4HMLGen.FOLLOW_A1TLIST_in_a1tstar11139); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1460:9: (a1t= action1t )*
loop108:
do {
var alt108=2;
var LA108_0 = this.input.LA(1);
if ( (LA108_0==ACTION1T) ) {
alt108=1;
}
switch (alt108) {
case 1 :
// Ham4HMLGen.g:1460:11: a1t= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_a1tstar11157);
a1t=this.action1t();
this.state._fsp--;
alist.push(a1t); 
break;
default :
break loop108;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
ral = alist;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ral;
},
// Ham4HMLGen.g:1467:1: action2t returns [Element ra = null] : ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? ) ;
// $ANTLR start "action2t"
action2t: function() {
var ra =  null;
var sub = null;
var a = null;
var loc = null;
var ra1 = null;
var ra2 = null;
try {
// Ham4HMLGen.g:1470:5: ( ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? ) )
// Ham4HMLGen.g:1471:5: ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? )
this.match(this.input,ACTION2T,Ham4HMLGen.FOLLOW_ACTION2T_in_action2t11214); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1472:9: (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t )
var alt109=7;
switch ( this.input.LA(1) ) {
case ACTION1T:
alt109=1;
break;
case ACTION1:
alt109=2;
break;
case SPLITACT2LOC2:
alt109=3;
break;
case SPLITACT2T:
alt109=4;
break;
case PARACT2T:
alt109=5;
break;
case SEQACT2T:
alt109=6;
break;
case SEQFUSEDACT2T:
alt109=7;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 109, 0, this.input);
throw nvae;
}
switch (alt109) {
case 1 :
// Ham4HMLGen.g:1473:13: sub= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_action2t11242);
sub=this.action1t();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1475:13: a= action1 loc= location2
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_action2t11272);
a=this.action1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_action2t11290);
loc=this.location2();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1478:13: ra1= splitaction2loc2
this.pushFollow(Ham4HMLGen.FOLLOW_splitaction2loc2_in_action2t11319);
ra1=this.splitaction2loc2();
this.state._fsp--;
ra = ra1; 
break;
case 4 :
// Ham4HMLGen.g:1480:13: ra2= splitaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_splitaction2t_in_action2t11354);
ra2=this.splitaction2t();
this.state._fsp--;
ra = ra2; 
break;
case 5 :
// Ham4HMLGen.g:1482:13: sub= paraction2t
this.pushFollow(Ham4HMLGen.FOLLOW_paraction2t_in_action2t11391);
sub=this.paraction2t();
this.state._fsp--;
break;
case 6 :
// Ham4HMLGen.g:1484:13: sub= seqaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction2t_in_action2t11419);
sub=this.seqaction2t();
this.state._fsp--;
break;
case 7 :
// Ham4HMLGen.g:1486:13: sub= seqfusedaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction2t_in_action2t11447);
sub=this.seqfusedaction2t();
this.state._fsp--;
break;
}
if (ra == null) {
if (sub != null) {
ra = hBuilder.wrapperEl("action2t", sub);
}
else /* a != null */ {
ra = hBuilder.wrapPair("action2t", a, loc);
}
}
// Ham4HMLGen.g:1498:9: ( repetitions[ra] )?
var alt110=2;
var LA110_0 = this.input.LA(1);
if ( (LA110_0==REPETITIONS) ) {
alt110=1;
}
switch (alt110) {
case 1 :
// Ham4HMLGen.g:1498:11: repetitions[ra]
this.pushFollow(Ham4HMLGen.FOLLOW_repetitions_in_action2t11483);
this.repetitions(ra);
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
/*  TBD: allow location2? after repetitions, and in this case
*  wrap ra and the extra loc as a new action2t;
*/
ra = hBuilder.stripParentIfNotNeeded(ra);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1508:1: action1t returns [Element ra = null] : ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? ) ;
// $ANTLR start "action1t"
action1t: function() {
var ra =  null;
var a = null;
var tl = null;
var sub = null;
var ract = null;
var     bouncing= false;
try {
// Ham4HMLGen.g:1514:5: ( ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? ) )
// Ham4HMLGen.g:1515:5: ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? )
this.match(this.input,ACTION1T,Ham4HMLGen.FOLLOW_ACTION1T_in_action1t11538); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1516:9: (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t )
var alt113=5;
switch ( this.input.LA(1) ) {
case ACTION1:
alt113=1;
break;
case PARACT1T:
alt113=2;
break;
case SEQACT1T:
alt113=3;
break;
case SEQFUSEDACT1T:
alt113=4;
break;
case NMACT1T:
alt113=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 113, 0, this.input);
throw nvae;
}
switch (alt113) {
case 1 :
// Ham4HMLGen.g:1517:13: a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )?
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_action1t11572);
a=this.action1();
this.state._fsp--;
// Ham4HMLGen.g:1518:13: (tl= location1 ( HamLargemod )? | tl= handconstellation )?
var alt112=3;
var LA112_0 = this.input.LA(1);
if ( (LA112_0==LOC1) ) {
alt112=1;
}
else if ( (LA112_0==HCONSTLLN) ) {
alt112=2;
}
switch (alt112) {
case 1 :
// Ham4HMLGen.g:1519:17: tl= location1 ( HamLargemod )?
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_action1t11609);
tl=this.location1();
this.state._fsp--;
// Ham4HMLGen.g:1520:21: ( HamLargemod )?
var alt111=2;
var LA111_0 = this.input.LA(1);
if ( (LA111_0==HamLargemod) ) {
alt111=1;
}
switch (alt111) {
case 1 :
// Ham4HMLGen.g:1520:23: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_action1t11633); 
bouncing = true; 
break;
}
break;
case 2 :
// Ham4HMLGen.g:1522:17: tl= handconstellation
this.pushFollow(Ham4HMLGen.FOLLOW_handconstellation_in_action1t11677);
tl=this.handconstellation();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1525:13: sub= paraction1t
this.pushFollow(Ham4HMLGen.FOLLOW_paraction1t_in_action1t11724);
sub=this.paraction1t();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1527:13: sub= seqaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction1t_in_action1t11756);
sub=this.seqaction1t();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1529:13: sub= seqfusedaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction1t_in_action1t11788);
sub=this.seqfusedaction1t();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1531:13: ract= nmaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_nmaction1t_in_action1t11819);
ract=this.nmaction1t();
this.state._fsp--;
ra = ract; 
break;
}
if (ra == null) {
if (sub != null) {
ra = hBuilder.wrapperEl("action1t", sub);
}
else /* a != null */ {
hBuilder.checkedSetFlagAttr(
a, "bouncing", bouncing);
ra = hBuilder.wrapperEl("action1t", a);
hBuilder.checkedAppendChild(ra, tl);
}
}
// Ham4HMLGen.g:1546:9: ( repetitions[ra] )?
var alt114=2;
var LA114_0 = this.input.LA(1);
if ( (LA114_0==REPETITIONS) ) {
alt114=1;
}
switch (alt114) {
case 1 :
// Ham4HMLGen.g:1546:11: repetitions[ra]
this.pushFollow(Ham4HMLGen.FOLLOW_repetitions_in_action1t11861);
this.repetitions(ra);
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
/*  TBD: allow location1? after repetitions, and in this case
*  wrap ra and the extra loc as a new action1t;
*/
ra = hBuilder.stripParentIfNotNeeded(ra);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1556:1: action1 returns [Element ra = null] : ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) ) ;
// $ANTLR start "action1"
action1: function() {
var ra =  null;
var sub = null;
var mod = null;
var     bouncing    = false;
try {
// Ham4HMLGen.g:1562:5: ( ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) ) )
// Ham4HMLGen.g:1563:5: ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) )
this.match(this.input,ACTION1,Ham4HMLGen.FOLLOW_ACTION1_in_action111917); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1564:9: ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 )
var alt118=5;
switch ( this.input.LA(1) ) {
case HamNomotion:
alt118=1;
break;
case SIMPLEMVMT:
alt118=2;
break;
case PARACT1:
alt118=3;
break;
case SEQACT1:
alt118=4;
break;
case SEQFUSEDACT1:
alt118=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 118, 0, this.input);
throw nvae;
}
switch (alt118) {
case 1 :
// Ham4HMLGen.g:1565:23: HamNomotion
this.match(this.input,HamNomotion,Ham4HMLGen.FOLLOW_HamNomotion_in_action111951); 
sub = hBuilder.newHMLElement("hamnomotion"); 
break;
case 2 :
// Ham4HMLGen.g:1568:13: sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )?
this.pushFollow(Ham4HMLGen.FOLLOW_simplemovement_in_action112007);
sub=this.simplemovement();
this.state._fsp--;
// Ham4HMLGen.g:1569:13: ( (mod= modifier )+ ( HamLargemod )? )?
var alt117=2;
var LA117_0 = this.input.LA(1);
if ( ((LA117_0>=HamFast && LA117_0<=HamHalt)) ) {
alt117=1;
}
switch (alt117) {
case 1 :
// Ham4HMLGen.g:1570:17: (mod= modifier )+ ( HamLargemod )?
// Ham4HMLGen.g:1570:17: (mod= modifier )+
var cnt115=0;
loop115:
do {
var alt115=2;
var LA115_0 = this.input.LA(1);
if ( ((LA115_0>=HamFast && LA115_0<=HamHalt)) ) {
alt115=1;
}
switch (alt115) {
case 1 :
// Ham4HMLGen.g:1571:17: mod= modifier
this.pushFollow(Ham4HMLGen.FOLLOW_modifier_in_action112061);
mod=this.modifier();
this.state._fsp--;
sub.setAttribute(mod, "true"); 
break;
default :
if ( cnt115 >= 1 ) {
break loop115;
}
var eee = new org.antlr.runtime.EarlyExitException(115, this.input);
throw eee;
}
cnt115++;
} while (true);
// Ham4HMLGen.g:1574:21: ( HamLargemod )?
var alt116=2;
var LA116_0 = this.input.LA(1);
if ( (LA116_0==HamLargemod) ) {
alt116=1;
}
switch (alt116) {
case 1 :
// Ham4HMLGen.g:1574:23: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_action112128); 
bouncing = true; 
break;
}
break;
}
break;
case 3 :
// Ham4HMLGen.g:1577:13: sub= paraction1
this.pushFollow(Ham4HMLGen.FOLLOW_paraction1_in_action112182);
sub=this.paraction1();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1579:13: sub= seqaction1
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction1_in_action112214);
sub=this.seqaction1();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1581:13: sub= seqfusedaction1
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction1_in_action112246);
sub=this.seqfusedaction1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ra = hBuilder.wrapIfNeeded("action1", sub);
hBuilder.checkedSetFlagAttr(ra, "bouncing", bouncing);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1593:1: paraction2t returns [Element rpa = null] : ^( PARACT2T (a= action2t )+ ) ;
// $ANTLR start "paraction2t"
paraction2t: function() {
var rpa =  null;
var a = null;
al  = [];
try {
// Ham4HMLGen.g:1599:5: ( ^( PARACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1600:5: ^( PARACT2T (a= action2t )+ )
this.match(this.input,PARACT2T,Ham4HMLGen.FOLLOW_PARACT2T_in_paraction2t12307); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1601:9: (a= action2t )+
var cnt119=0;
loop119:
do {
var alt119=2;
var LA119_0 = this.input.LA(1);
if ( (LA119_0==ACTION2T) ) {
alt119=1;
}
switch (alt119) {
case 1 :
// Ham4HMLGen.g:1602:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_paraction2t12337);
a=this.action2t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt119 >= 1 ) {
break loop119;
}
var eee = new org.antlr.runtime.EarlyExitException(119, this.input);
throw eee;
}
cnt119++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action2t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1610:1: seqaction2t returns [Element rsa = null] : ^( SEQACT2T (a= action2t )+ ) ;
// $ANTLR start "seqaction2t"
seqaction2t: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1616:5: ( ^( SEQACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1617:5: ^( SEQACT2T (a= action2t )+ )
this.match(this.input,SEQACT2T,Ham4HMLGen.FOLLOW_SEQACT2T_in_seqaction2t12403); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1618:9: (a= action2t )+
var cnt120=0;
loop120:
do {
var alt120=2;
var LA120_0 = this.input.LA(1);
if ( (LA120_0==ACTION2T) ) {
alt120=1;
}
switch (alt120) {
case 1 :
// Ham4HMLGen.g:1619:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_seqaction2t12433);
a=this.action2t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt120 >= 1 ) {
break loop120;
}
var eee = new org.antlr.runtime.EarlyExitException(120, this.input);
throw eee;
}
cnt120++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action2t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1627:1: seqfusedaction2t returns [Element rsfa = null] : ^( SEQFUSEDACT2T (a= action2t )+ ) ;
// $ANTLR start "seqfusedaction2t"
seqfusedaction2t: function() {
var rsfa =  null;
var a = null;
var al = [];
try {
// Ham4HMLGen.g:1634:5: ( ^( SEQFUSEDACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1635:5: ^( SEQFUSEDACT2T (a= action2t )+ )
this.match(this.input,SEQFUSEDACT2T,Ham4HMLGen.FOLLOW_SEQFUSEDACT2T_in_seqfusedaction2t12502); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1636:9: (a= action2t )+
var cnt121=0;
loop121:
do {
var alt121=2;
var LA121_0 = this.input.LA(1);
if ( (LA121_0==ACTION2T) ) {
alt121=1;
}
switch (alt121) {
case 1 :
// Ham4HMLGen.g:1637:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_seqfusedaction2t12532);
a=this.action2t();
this.state._fsp--;
al.add(a); 
break;
default :
if ( cnt121 >= 1 ) {
break loop121;
}
var eee = new org.antlr.runtime.EarlyExitException(121, this.input);
throw eee;
}
cnt121++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action2t");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1648:1: splitaction2loc2 returns [Element rsal = null] : ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 ) ;
// $ANTLR start "splitaction2loc2"
splitaction2loc2: function() {
var rsal =  null;
var a = null;
var loc = null;
var sadom   = hBuilder.newHMLElement("seq_action1");
var sasub   = hBuilder.newHMLElement("seq_action1");
try {
// Ham4HMLGen.g:1655:5: ( ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 ) )
// Ham4HMLGen.g:1656:5: ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 )
this.match(this.input,SPLITACT2LOC2,Ham4HMLGen.FOLLOW_SPLITACT2LOC2_in_splitaction2loc212597); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1657:9: (a= action1 )+
var cnt122=0;
loop122:
do {
var alt122=2;
var LA122_0 = this.input.LA(1);
if ( (LA122_0==ACTION1) ) {
alt122=1;
}
switch (alt122) {
case 1 :
// Ham4HMLGen.g:1657:11: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_splitaction2loc212617);
a=this.action1();
this.state._fsp--;
sadom.appendChild(a); 
break;
default :
if ( cnt122 >= 1 ) {
break loop122;
}
var eee = new org.antlr.runtime.EarlyExitException(122, this.input);
throw eee;
}
cnt122++;
} while (true);
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_splitaction2loc212640); 
// Ham4HMLGen.g:1659:9: (a= action1 )+
var cnt123=0;
loop123:
do {
var alt123=2;
var LA123_0 = this.input.LA(1);
if ( (LA123_0==ACTION1) ) {
alt123=1;
}
switch (alt123) {
case 1 :
// Ham4HMLGen.g:1659:11: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_splitaction2loc212660);
a=this.action1();
this.state._fsp--;
sasub.appendChild(a); 
break;
default :
if ( cnt123 >= 1 ) {
break loop123;
}
var eee = new org.antlr.runtime.EarlyExitException(123, this.input);
throw eee;
}
cnt123++;
} while (true);
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_splitaction2loc212691);
loc=this.location2();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
var a2  = hBuilder.newHMLElement("action2");
// A singleton sequence can be unwrapped, rather
// than being wrapped.
var adom =
sadom.childNodes.length==1 ?
sadom.firstChild :
hBuilder.wrapperEl("action1", sadom);
a2.appendChild(adom);
// Again, choose between unwrapping and wrapping.
var asub =
sasub.childNodes.length==1 ?
sasub.firstChild :
hBuilder.wrapperEl("action1", sasub);
a2.appendChild(asub);
rsal = hBuilder.newHMLElement("action2t");
rsal.appendChild(a2);
rsal.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsal;
},
// Ham4HMLGen.g:1686:1: splitaction2t returns [Element rsa = null] : ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ ) ;
// $ANTLR start "splitaction2t"
splitaction2t: function() {
var rsa =  null;
var at = null;
var satdom  = hBuilder.newHMLElement("seq_action1t");
var satsub  = hBuilder.newHMLElement("seq_action1t");
try {
// Ham4HMLGen.g:1693:5: ( ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ ) )
// Ham4HMLGen.g:1694:5: ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ )
this.match(this.input,SPLITACT2T,Ham4HMLGen.FOLLOW_SPLITACT2T_in_splitaction2t12737); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1695:9: (at= action1t )+
var cnt124=0;
loop124:
do {
var alt124=2;
var LA124_0 = this.input.LA(1);
if ( (LA124_0==ACTION1T) ) {
alt124=1;
}
switch (alt124) {
case 1 :
// Ham4HMLGen.g:1695:11: at= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_splitaction2t12756);
at=this.action1t();
this.state._fsp--;
satdom.appendChild(at); 
break;
default :
if ( cnt124 >= 1 ) {
break loop124;
}
var eee = new org.antlr.runtime.EarlyExitException(124, this.input);
throw eee;
}
cnt124++;
} while (true);
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_splitaction2t12778); 
// Ham4HMLGen.g:1697:9: (at= action1t )+
var cnt125=0;
loop125:
do {
var alt125=2;
var LA125_0 = this.input.LA(1);
if ( (LA125_0==ACTION1T) ) {
alt125=1;
}
switch (alt125) {
case 1 :
// Ham4HMLGen.g:1697:11: at= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_splitaction2t12797);
at=this.action1t();
this.state._fsp--;
satsub.appendChild(at); 
break;
default :
if ( cnt125 >= 1 ) {
break loop125;
}
var eee = new org.antlr.runtime.EarlyExitException(125, this.input);
throw eee;
}
cnt125++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.newHMLElement("action2t");
// A singleton sequence can be unwrapped, rather
// than being wrapped.
var atdom =
satdom.childNodes.length==1 ?
satdom.firstChild :
hBuilder.wrapperEl("action1t", satdom);
rsa.appendChild(atdom);
// Again, choose between unwrapping and wrapping.
var atsub =
satsub.childNodes.length==1 ?
satsub.firstChild :
hBuilder.wrapperEl("action1t", satsub);
rsa.appendChild(atsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1719:1: paraction1t returns [Element rpa = null] : ^( PARACT1T (a= action1t )+ ) ;
// $ANTLR start "paraction1t"
paraction1t: function() {
var rpa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1725:5: ( ^( PARACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1726:5: ^( PARACT1T (a= action1t )+ )
this.match(this.input,PARACT1T,Ham4HMLGen.FOLLOW_PARACT1T_in_paraction1t12857); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1727:9: (a= action1t )+
var cnt126=0;
loop126:
do {
var alt126=2;
var LA126_0 = this.input.LA(1);
if ( (LA126_0==ACTION1T) ) {
alt126=1;
}
switch (alt126) {
case 1 :
// Ham4HMLGen.g:1728:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_paraction1t12887);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt126 >= 1 ) {
break loop126;
}
var eee = new org.antlr.runtime.EarlyExitException(126, this.input);
throw eee;
}
cnt126++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action1t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1736:1: seqaction1t returns [Element rsa = null] : ^( SEQACT1T (a= action1t )+ ) ;
// $ANTLR start "seqaction1t"
seqaction1t: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1742:5: ( ^( SEQACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1743:5: ^( SEQACT1T (a= action1t )+ )
this.match(this.input,SEQACT1T,Ham4HMLGen.FOLLOW_SEQACT1T_in_seqaction1t12953); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1744:9: (a= action1t )+
var cnt127=0;
loop127:
do {
var alt127=2;
var LA127_0 = this.input.LA(1);
if ( (LA127_0==ACTION1T) ) {
alt127=1;
}
switch (alt127) {
case 1 :
// Ham4HMLGen.g:1745:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_seqaction1t12983);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt127 >= 1 ) {
break loop127;
}
var eee = new org.antlr.runtime.EarlyExitException(127, this.input);
throw eee;
}
cnt127++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action1t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1753:1: seqfusedaction1t returns [Element rsfa = null] : ^( SEQFUSEDACT1T (a= action1t )+ ) ;
// $ANTLR start "seqfusedaction1t"
seqfusedaction1t: function() {
var rsfa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1760:5: ( ^( SEQFUSEDACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1761:5: ^( SEQFUSEDACT1T (a= action1t )+ )
this.match(this.input,SEQFUSEDACT1T,Ham4HMLGen.FOLLOW_SEQFUSEDACT1T_in_seqfusedaction1t13052); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1762:9: (a= action1t )+
var cnt128=0;
loop128:
do {
var alt128=2;
var LA128_0 = this.input.LA(1);
if ( (LA128_0==ACTION1T) ) {
alt128=1;
}
switch (alt128) {
case 1 :
// Ham4HMLGen.g:1763:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_seqfusedaction1t13082);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt128 >= 1 ) {
break loop128;
}
var eee = new org.antlr.runtime.EarlyExitException(128, this.input);
throw eee;
}
cnt128++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action1t");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1774:1: nmaction1t returns [Element rnma = null] : ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t ) ;
// $ANTLR start "nmaction1t"
nmaction1t: function() {
var rnma =  null;
var hd = null;
var a = null;
try {
// Ham4HMLGen.g:1777:5: ( ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t ) )
// Ham4HMLGen.g:1778:5: ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t )
this.match(this.input,NMACT1T,Ham4HMLGen.FOLLOW_NMACT1T_in_nmaction1t13145); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1779:9: (hd= levelbody | hd= levelarm )
var alt129=2;
var LA129_0 = this.input.LA(1);
if ( (LA129_0==LEVBODY) ) {
alt129=1;
}
else if ( (LA129_0==LEVARM) ) {
alt129=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 129, 0, this.input);
throw nvae;
}
switch (alt129) {
case 1 :
// Ham4HMLGen.g:1780:13: hd= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_nmaction1t13174);
hd=this.levelbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1782:13: hd= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_nmaction1t13203);
hd=this.levelarm();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_nmaction1t13234);
a=this.action1t();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rnma = hBuilder.newHMLElement("action1t");
rnma.appendChild(hd);
rnma.appendChild(a);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnma;
},
// Ham4HMLGen.g:1794:1: paraction1 returns [Element rpa = null] : ^( PARACT1 (a= action1 )+ ) ;
// $ANTLR start "paraction1"
paraction1: function() {
var rpa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1800:5: ( ^( PARACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1801:5: ^( PARACT1 (a= action1 )+ )
this.match(this.input,PARACT1,Ham4HMLGen.FOLLOW_PARACT1_in_paraction113283); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1802:9: (a= action1 )+
var cnt130=0;
loop130:
do {
var alt130=2;
var LA130_0 = this.input.LA(1);
if ( (LA130_0==ACTION1) ) {
alt130=1;
}
switch (alt130) {
case 1 :
// Ham4HMLGen.g:1803:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_paraction113313);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt130 >= 1 ) {
break loop130;
}
var eee = new org.antlr.runtime.EarlyExitException(130, this.input);
throw eee;
}
cnt130++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1811:1: seqaction1 returns [Element rsa = null] : ^( SEQACT1 (a= action1 )+ ) ;
// $ANTLR start "seqaction1"
seqaction1: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1817:5: ( ^( SEQACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1818:5: ^( SEQACT1 (a= action1 )+ )
this.match(this.input,SEQACT1,Ham4HMLGen.FOLLOW_SEQACT1_in_seqaction113385); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1819:9: (a= action1 )+
var cnt131=0;
loop131:
do {
var alt131=2;
var LA131_0 = this.input.LA(1);
if ( (LA131_0==ACTION1) ) {
alt131=1;
}
switch (alt131) {
case 1 :
// Ham4HMLGen.g:1820:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_seqaction113415);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt131 >= 1 ) {
break loop131;
}
var eee = new org.antlr.runtime.EarlyExitException(131, this.input);
throw eee;
}
cnt131++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1828:1: seqfusedaction1 returns [Element rsfa = null] : ^( SEQFUSEDACT1 (a= action1 )+ ) ;
// $ANTLR start "seqfusedaction1"
seqfusedaction1: function() {
var rsfa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1835:5: ( ^( SEQFUSEDACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1836:5: ^( SEQFUSEDACT1 (a= action1 )+ )
this.match(this.input,SEQFUSEDACT1,Ham4HMLGen.FOLLOW_SEQFUSEDACT1_in_seqfusedaction113490); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1837:9: (a= action1 )+
var cnt132=0;
loop132:
do {
var alt132=2;
var LA132_0 = this.input.LA(1);
if ( (LA132_0==ACTION1) ) {
alt132=1;
}
switch (alt132) {
case 1 :
// Ham4HMLGen.g:1838:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_seqfusedaction113520);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt132 >= 1 ) {
break loop132;
}
var eee = new org.antlr.runtime.EarlyExitException(132, this.input);
throw eee;
}
cnt132++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action1");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1849:1: repetitions[action] : ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) ) ;
// $ANTLR start "repetitions"
repetitions: function(action) {
var r0 = null;
var ed = null;
var r1 = null;
var sc = null;
var sz = null;
var     approxrpt = false;
var     alta    = false;
var     altb    = false;
try {
// Ham4HMLGen.g:1856:5: ( ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) ) )
// Ham4HMLGen.g:1857:5: ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) )
this.match(this.input,REPETITIONS,Ham4HMLGen.FOLLOW_REPETITIONS_in_repetitions13593); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1858:9: ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? )
var alt141=2;
var LA141_0 = this.input.LA(1);
if ( ((LA141_0>=HamRepeatfromstart && LA141_0<=HamRepeatcontinueseveral)||LA141_0==HamRepeatreverse||LA141_0==MOVINGREPETITION) ) {
alt141=1;
}
else if ( (LA141_0==HamAlternatingmotion) ) {
alt141=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 141, 0, this.input);
throw nvae;
}
switch (alt141) {
case 1 :
// Ham4HMLGen.g:1859:13: (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )?
// Ham4HMLGen.g:1859:13: (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] )
var alt135=2;
var LA135_0 = this.input.LA(1);
if ( ((LA135_0>=HamRepeatfromstart && LA135_0<=HamRepeatcontinueseveral)||LA135_0==HamRepeatreverse) ) {
alt135=1;
}
else if ( (LA135_0==MOVINGREPETITION) ) {
alt135=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);
throw nvae;
}
switch (alt135) {
case 1 :
// Ham4HMLGen.g:1860:21: r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )?
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_repetitions13644);
r0=this.repetition();
this.state._fsp--;
// Ham4HMLGen.g:1861:17: ( HamEtc (ed= ellipsedirection )? | r1= repetition )?
var alt134=3;
var LA134_0 = this.input.LA(1);
if ( (LA134_0==HamEtc) ) {
alt134=1;
}
else if ( ((LA134_0>=HamRepeatfromstart && LA134_0<=HamRepeatcontinueseveral)||LA134_0==HamRepeatreverse) ) {
alt134=2;
}
switch (alt134) {
case 1 :
// Ham4HMLGen.g:1862:27: HamEtc (ed= ellipsedirection )?
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_repetitions13690); 
approxrpt = true; 
// Ham4HMLGen.g:1863:20: (ed= ellipsedirection )?
var alt133=2;
var LA133_0 = this.input.LA(1);
if ( ((LA133_0>=HamEllipseh && LA133_0<=HamEllipseul)) ) {
alt133=1;
}
switch (alt133) {
case 1 :
// Ham4HMLGen.g:1863:22: ed= ellipsedirection
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_repetitions13734);
ed=this.ellipsedirection();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1865:22: r1= repetition
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_repetitions13782);
r1=this.repetition();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1868:27: movingrepetition[action]
this.pushFollow(Ham4HMLGen.FOLLOW_movingrepetition_in_repetitions13843);
this.movingrepetition(action);
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1870:13: (sc= sizechange (sz= size )? )?
var alt137=2;
var LA137_0 = this.input.LA(1);
if ( ((LA137_0>=HamIncreasing && LA137_0<=HamDecreasing)) ) {
alt137=1;
}
switch (alt137) {
case 1 :
// Ham4HMLGen.g:1871:17: sc= sizechange (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_repetitions13899);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:1872:17: (sz= size )?
var alt136=2;
var LA136_0 = this.input.LA(1);
if ( ((LA136_0>=HamSmallmod && LA136_0<=HamLargemod)) ) {
alt136=1;
}
switch (alt136) {
case 1 :
// Ham4HMLGen.g:1872:19: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_repetitions13926);
sz=this.size();
this.state._fsp--;
break;
}
break;
}
// Ham4HMLGen.g:1874:13: ( HamAlternatingmotion ( HamAlternatingmotion )? )?
var alt139=2;
var LA139_0 = this.input.LA(1);
if ( (LA139_0==HamAlternatingmotion) ) {
alt139=1;
}
switch (alt139) {
case 1 :
// Ham4HMLGen.g:1875:27: HamAlternatingmotion ( HamAlternatingmotion )?
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions13986); 
alta = true; 
// Ham4HMLGen.g:1876:7: ( HamAlternatingmotion )?
var alt138=2;
var LA138_0 = this.input.LA(1);
if ( (LA138_0==HamAlternatingmotion) ) {
alt138=1;
}
switch (alt138) {
case 1 :
// Ham4HMLGen.g:1876:9: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions13999); 
altb = true; 
break;
}
break;
}
break;
case 2 :
// Ham4HMLGen.g:1879:13: HamAlternatingmotion ( HamAlternatingmotion )?
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14044); 
alta = true; 
// Ham4HMLGen.g:1880:13: ( HamAlternatingmotion )?
var alt140=2;
var LA140_0 = this.input.LA(1);
if ( (LA140_0==HamAlternatingmotion) ) {
alt140=1;
}
switch (alt140) {
case 1 :
// Ham4HMLGen.g:1880:15: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14065); 
altb = true; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (r0 != null) {
hBuilder.checkedSetAttr(action, "repetition", r0);
hBuilder.checkedSetAttr(action, "second_repetition", r1);
if (approxrpt && r0.endsWith("fromstartseveral")) {
hBuilder.checkedSetAttr(action, "approx_repetition", "true");
hBuilder.checkedSetAttr(action, "ellipsedirection", ed);
}
}
hBuilder.checkedSetAttr(action, "repetition_incrdecr", sc);
hBuilder.checkedSetAttr(action, "repetition_incrdecr_size", sz);
hBuilder.checkedSetFlagAttr(action, "alternating", alta);
hBuilder.checkedSetFlagAttr(action, "second_alternating", altb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:1899:1: movingrepetition[action] : ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? ) ;
// $ANTLR start "movingrepetition"
movingrepetition: function(action) {
var r = null;
var ma = null;
var sz = null;
var sc = null;
var idsz = null;
try {
// Ham4HMLGen.g:1901:5: ( ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? ) )
// Ham4HMLGen.g:1902:5: ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? )
this.match(this.input,MOVINGREPETITION,Ham4HMLGen.FOLLOW_MOVINGREPETITION_in_movingrepetition14122); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_movingrepetition14146);
r=this.repetition();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_movingrepetition14169);
ma=this.movementarrow();
this.state._fsp--;
// Ham4HMLGen.g:1905:9: (sz= size )?
var alt142=2;
var LA142_0 = this.input.LA(1);
if ( ((LA142_0>=HamSmallmod && LA142_0<=HamLargemod)) ) {
alt142=1;
}
switch (alt142) {
case 1 :
// Ham4HMLGen.g:1905:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_movingrepetition14192);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1906:9: (sc= sizechange (idsz= size )? )?
var alt144=2;
var LA144_0 = this.input.LA(1);
if ( ((LA144_0>=HamIncreasing && LA144_0<=HamDecreasing)) ) {
alt144=1;
}
switch (alt144) {
case 1 :
// Ham4HMLGen.g:1907:13: sc= sizechange (idsz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_movingrepetition14228);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:1908:13: (idsz= size )?
var alt143=2;
var LA143_0 = this.input.LA(1);
if ( ((LA143_0>=HamSmallmod && LA143_0<=HamLargemod)) ) {
alt143=1;
}
switch (alt143) {
case 1 :
// Ham4HMLGen.g:1908:15: idsz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_movingrepetition14249);
idsz=this.size();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
hBuilder.checkedSetAttr(action, "repetition", r);
hBuilder.checkedSetAttr(action, "repetition_baseshift", ma);
hBuilder.checkedSetAttr(action, "baseshift_size", sz);
hBuilder.checkedSetAttr(action, "baseshift_incrdecr", sc);
hBuilder.checkedSetAttr(action, "baseshift_incrdecr_size", idsz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:1923:1: simplemovement returns [rsm = null] : ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? ) ;
// $ANTLR start "simplemovement"
simplemovement: function() {
var rsm =  null;
var mv = null;
var tmpdig = null;
var bl = null;
var dig = null;
var dl = null;
try {
// Ham4HMLGen.g:1929:5: ( ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? ) )
// Ham4HMLGen.g:1930:5: ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? )
this.match(this.input,SIMPLEMVMT,Ham4HMLGen.FOLLOW_SIMPLEMVMT_in_simplemovement14311); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1931:9: (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay )
var alt146=6;
switch ( this.input.LA(1) ) {
case STRGHTMVMT:
alt146=1;
break;
case CRCLRMVMT:
alt146=2;
break;
case HamNodding:
case HamSwinging:
case HamTwisting:
case HamStircw:
case HamStirccw:
alt146=3;
break;
case HamMovecross:
case HamMovex:
alt146=4;
break;
case REPLACE:
alt146=5;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
case HamFingerplay:
alt146=6;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 146, 0, this.input);
throw nvae;
}
switch (alt146) {
case 1 :
// Ham4HMLGen.g:1932:13: mv= fullstraightmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullstraightmovement_in_simplemovement14340);
mv=this.fullstraightmovement();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1934:13: mv= fullcircularmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullcircularmovement_in_simplemovement14369);
mv=this.fullcircularmovement();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1936:13: mv= fullwristmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullwristmovement_in_simplemovement14398);
mv=this.fullwristmovement();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1938:13: mv= fullmovementcross
this.pushFollow(Ham4HMLGen.FOLLOW_fullmovementcross_in_simplemovement14427);
mv=this.fullmovementcross();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1940:13: mv= replacement
this.pushFollow(Ham4HMLGen.FOLLOW_replacement_in_simplemovement14456);
mv=this.replacement();
this.state._fsp--;
break;
case 6 :
// Ham4HMLGen.g:1942:19: (tmpdig= digit )* HamFingerplay
// Ham4HMLGen.g:1942:19: (tmpdig= digit )*
loop145:
do {
var alt145=2;
var LA145_0 = this.input.LA(1);
if ( ((LA145_0>=HamThumb && LA145_0<=HamPinky)) ) {
alt145=1;
}
switch (alt145) {
case 1 :
// Ham4HMLGen.g:1943:23: tmpdig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_simplemovement14514);
tmpdig=this.digit();
this.state._fsp--;
if (dl == null) { dl = []; }
dl.push(tmpdig); 
break;
default :
break loop145;
}
} while (true);
this.match(this.input,HamFingerplay,Ham4HMLGen.FOLLOW_HamFingerplay_in_simplemovement14579); 
mv = hBuilder.newHMLElement("hamfingerplay"); 
break;
}
// Ham4HMLGen.g:1952:9: ( HamBrushing bl= location1 )?
var alt147=2;
var LA147_0 = this.input.LA(1);
if ( (LA147_0==HamBrushing) ) {
alt147=1;
}
switch (alt147) {
case 1 :
// Ham4HMLGen.g:1953:19: HamBrushing bl= location1
this.match(this.input,HamBrushing,Ham4HMLGen.FOLLOW_HamBrushing_in_simplemovement14639); 
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_simplemovement14658);
bl=this.location1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1956:9: (dig= digit )?
var alt148=2;
var LA148_0 = this.input.LA(1);
if ( ((LA148_0>=HamThumb && LA148_0<=HamPinky)) ) {
alt148=1;
}
switch (alt148) {
case 1 :
// Ham4HMLGen.g:1956:13: dig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_simplemovement14687);
dig=this.digit();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsm = hBuilder.newHMLElement("simplemovement");
if (dl != null) {
for (var i = 0; i < dl.length; i++) { mv.appendChild(dl[i]); }
}
rsm.appendChild(mv);
hBuilder.checkedAppendChild(rsm, bl);
if (dig != null) {
var dstr = dig.getAttribute("fingerid");
var ipos = "ham_digit_".length();
var locstr = "loc" + dstr.substring(ipos);
hBuilder.checkedSetAttr(rsm, "def_locname", locstr);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsm;
},
// Ham4HMLGen.g:1974:1: fullstraightmovement returns [Element rfsm = null] : (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? ) ;
// $ANTLR start "fullstraightmovement"
fullstraightmovement: function() {
var rfsm =  null;
var fsm = null;
var sz = null;
try {
// Ham4HMLGen.g:1978:5: ( (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? ) )
// Ham4HMLGen.g:1979:5: (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? )
// Ham4HMLGen.g:1979:5: (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? )
// Ham4HMLGen.g:1980:9: fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )?
this.pushFollow(Ham4HMLGen.FOLLOW_straightmovement_in_fullstraightmovement14750);
fsm=this.straightmovement();
this.state._fsp--;
rfsm = fsm; 
// Ham4HMLGen.g:1981:9: (sz= size )?
var alt149=2;
var LA149_0 = this.input.LA(1);
if ( ((LA149_0>=HamSmallmod && LA149_0<=HamLargemod)) ) {
alt149=1;
}
switch (alt149) {
case 1 :
// Ham4HMLGen.g:1981:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullstraightmovement14775);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1982:9: ( arckind[rfsm] | zigzag[rfsm] )?
var alt150=3;
var LA150_0 = this.input.LA(1);
if ( ((LA150_0>=HamArcl && LA150_0<=HamArcd)) ) {
alt150=1;
}
else if ( ((LA150_0>=HamWavy && LA150_0<=HamZigzag)) ) {
alt150=2;
}
switch (alt150) {
case 1 :
// Ham4HMLGen.g:1983:19: arckind[rfsm]
this.pushFollow(Ham4HMLGen.FOLLOW_arckind_in_fullstraightmovement14808);
this.arckind(rfsm);
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1985:19: zigzag[rfsm]
this.pushFollow(Ham4HMLGen.FOLLOW_zigzag_in_fullstraightmovement14839);
this.zigzag(rfsm);
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(rfsm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfsm;
},
// Ham4HMLGen.g:1993:1: straightmovement returns [Element rsm = null] : ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? ) ;
// $ANTLR start "straightmovement"
straightmovement: function() {
var rsm =  null;
var ma = null;
var mb = null;
try {
// Ham4HMLGen.g:1996:5: ( ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? ) )
// Ham4HMLGen.g:1997:5: ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? )
this.match(this.input,STRGHTMVMT,Ham4HMLGen.FOLLOW_STRGHTMVMT_in_straightmovement14894); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_straightmovement14913);
ma=this.movementarrow();
this.state._fsp--;
// Ham4HMLGen.g:1999:9: (mb= movementarrow )?
var alt151=2;
var LA151_0 = this.input.LA(1);
if ( ((LA151_0>=HamMoveu && LA151_0<=HamMoveuo)) ) {
alt151=1;
}
switch (alt151) {
case 1 :
// Ham4HMLGen.g:1999:11: mb= movementarrow
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_straightmovement14932);
mb=this.movementarrow();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsm = hBuilder.newHMLElement("straightmovement");
hBuilder.checkedSetAttr(rsm, "movement", ma);
hBuilder.checkedSetAttr(rsm, "second_movement", mb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsm;
},
// Ham4HMLGen.g:2008:1: arckind[ake] : (aa= arc (ab= arc )? (sz= size )? ) ;
// $ANTLR start "arckind"
arckind: function(ake) {
var aa = null;
var ab = null;
var sz = null;
try {
// Ham4HMLGen.g:2012:5: ( (aa= arc (ab= arc )? (sz= size )? ) )
// Ham4HMLGen.g:2013:5: (aa= arc (ab= arc )? (sz= size )? )
// Ham4HMLGen.g:2013:5: (aa= arc (ab= arc )? (sz= size )? )
// Ham4HMLGen.g:2014:9: aa= arc (ab= arc )? (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_arc_in_arckind14999);
aa=this.arc();
this.state._fsp--;
// Ham4HMLGen.g:2015:9: (ab= arc )?
var alt152=2;
var LA152_0 = this.input.LA(1);
if ( ((LA152_0>=HamArcl && LA152_0<=HamArcd)) ) {
alt152=1;
}
switch (alt152) {
case 1 :
// Ham4HMLGen.g:2015:11: ab= arc
this.pushFollow(Ham4HMLGen.FOLLOW_arc_in_arckind15018);
ab=this.arc();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2016:9: (sz= size )?
var alt153=2;
var LA153_0 = this.input.LA(1);
if ( ((LA153_0>=HamSmallmod && LA153_0<=HamLargemod)) ) {
alt153=1;
}
switch (alt153) {
case 1 :
// Ham4HMLGen.g:2016:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_arckind15041);
sz=this.size();
this.state._fsp--;
break;
}
if (ab != null) {
var   aax = aa.charAt(aa.length()-1);
var   abx = ab.charAt(ab.length()-1);
if (aax=='u' || aax=='d') {
if (abx=='l' || abx=='r') {
aa = aa + abx;
}
}
}
ake.setAttribute("arc", aa);
hBuilder.checkedSetAttr(ake, "arc_size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2033:1: zigzag[zze] : ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? ) ;
// $ANTLR start "zigzag"
zigzag: function(zze) {
var sz = null;
var ed = null;
var  style   = null;
try {
// Ham4HMLGen.g:2040:5: ( ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? ) )
// Ham4HMLGen.g:2041:5: ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? )
// Ham4HMLGen.g:2041:5: ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? )
// Ham4HMLGen.g:2042:9: ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )?
// Ham4HMLGen.g:2042:9: ( HamZigzag | HamWavy )
var alt154=2;
var LA154_0 = this.input.LA(1);
if ( (LA154_0==HamZigzag) ) {
alt154=1;
}
else if ( (LA154_0==HamWavy) ) {
alt154=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 154, 0, this.input);
throw nvae;
}
switch (alt154) {
case 1 :
// Ham4HMLGen.g:2043:19: HamZigzag
this.match(this.input,HamZigzag,Ham4HMLGen.FOLLOW_HamZigzag_in_zigzag15124); 
style = "ham_zigzag"; 
break;
case 2 :
// Ham4HMLGen.g:2045:19: HamWavy
this.match(this.input,HamWavy,Ham4HMLGen.FOLLOW_HamWavy_in_zigzag15160); 
style = "ham_wavy"; 
break;
}
// Ham4HMLGen.g:2047:9: (sz= size )?
var alt155=2;
var LA155_0 = this.input.LA(1);
if ( ((LA155_0>=HamSmallmod && LA155_0<=HamLargemod)) ) {
alt155=1;
}
switch (alt155) {
case 1 :
// Ham4HMLGen.g:2047:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_zigzag15197);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2048:9: (ed= ellipsedirection )?
var alt156=2;
var LA156_0 = this.input.LA(1);
if ( ((LA156_0>=HamEllipseh && LA156_0<=HamEllipseul)) ) {
alt156=1;
}
switch (alt156) {
case 1 :
// Ham4HMLGen.g:2048:11: ed= ellipsedirection
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_zigzag15219);
ed=this.ellipsedirection();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2049:9: ( sizechangenonlinear[zze] )?
var alt157=2;
var LA157_0 = this.input.LA(1);
if ( ((LA157_0>=HamIncreasing && LA157_0<=HamDecreasing)) ) {
alt157=1;
}
switch (alt157) {
case 1 :
// Ham4HMLGen.g:2049:19: sizechangenonlinear[zze]
this.pushFollow(Ham4HMLGen.FOLLOW_sizechangenonlinear_in_zigzag15242);
this.sizechangenonlinear(zze);
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(zze, "zigzagstyle", style);
hBuilder.checkedSetAttr(zze, "zigzag_size", sz);
hBuilder.checkedSetAttr(zze, "ellipsedirection", ed);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2058:1: sizechangenonlinear[sce] : (sc= sizechange (sz= size )? ) ;
// $ANTLR start "sizechangenonlinear"
sizechangenonlinear: function(sce) {
var sc = null;
var sz = null;
try {
// Ham4HMLGen.g:2062:5: ( (sc= sizechange (sz= size )? ) )
// Ham4HMLGen.g:2063:5: (sc= sizechange (sz= size )? )
// Ham4HMLGen.g:2063:5: (sc= sizechange (sz= size )? )
// Ham4HMLGen.g:2064:9: sc= sizechange (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_sizechangenonlinear15306);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:2065:9: (sz= size )?
var alt158=2;
var LA158_0 = this.input.LA(1);
if ( ((LA158_0>=HamSmallmod && LA158_0<=HamLargemod)) ) {
alt158=1;
}
switch (alt158) {
case 1 :
// Ham4HMLGen.g:2065:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_sizechangenonlinear15325);
sz=this.size();
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(sce, "incrdecr", sc);
hBuilder.checkedSetAttr(sce, "incrdecr_size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2073:1: fullcircularmovement returns [Element rfcm = null] : (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? ) ;
// $ANTLR start "fullcircularmovement"
fullcircularmovement: function() {
var rfcm =  null;
var fcm = null;
var sz = null;
var el = null;
try {
// Ham4HMLGen.g:2077:5: ( (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? ) )
// Ham4HMLGen.g:2078:5: (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? )
// Ham4HMLGen.g:2078:5: (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? )
// Ham4HMLGen.g:2079:9: fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )?
this.pushFollow(Ham4HMLGen.FOLLOW_circularmovement_in_fullcircularmovement15388);
fcm=this.circularmovement();
this.state._fsp--;
rfcm = fcm; 
// Ham4HMLGen.g:2080:9: (sz= size )?
var alt159=2;
var LA159_0 = this.input.LA(1);
if ( ((LA159_0>=HamSmallmod && LA159_0<=HamLargemod)) ) {
alt159=1;
}
switch (alt159) {
case 1 :
// Ham4HMLGen.g:2080:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullcircularmovement15413);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2081:9: ( revolutions[rfcm] )?
var alt160=2;
var LA160_0 = this.input.LA(1);
if ( ((LA160_0>=HamClocku && LA160_0<=HamClockfull)) ) {
alt160=1;
}
switch (alt160) {
case 1 :
// Ham4HMLGen.g:2081:19: revolutions[rfcm]
this.pushFollow(Ham4HMLGen.FOLLOW_revolutions_in_fullcircularmovement15436);
this.revolutions(rfcm);
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2082:9: (el= ellipse )?
var alt161=2;
var LA161_0 = this.input.LA(1);
if ( ((LA161_0>=HamEllipseh && LA161_0<=HamEllipseul)) ) {
alt161=1;
}
switch (alt161) {
case 1 :
// Ham4HMLGen.g:2082:11: el= ellipse
this.pushFollow(Ham4HMLGen.FOLLOW_ellipse_in_fullcircularmovement15459);
el=this.ellipse();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2083:9: ( sizechangenonlinear[rfcm] )?
var alt162=2;
var LA162_0 = this.input.LA(1);
if ( ((LA162_0>=HamIncreasing && LA162_0<=HamDecreasing)) ) {
alt162=1;
}
switch (alt162) {
case 1 :
// Ham4HMLGen.g:2083:19: sizechangenonlinear[rfcm]
this.pushFollow(Ham4HMLGen.FOLLOW_sizechangenonlinear_in_fullcircularmovement15482);
this.sizechangenonlinear(rfcm);
this.state._fsp--;
break;
}
hBuilder.checkedAppendChild(rfcm, el);
hBuilder.checkedSetAttr(rfcm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfcm;
},
// Ham4HMLGen.g:2091:1: circularmovement returns [Element rcm = null] : ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? ) ;
// $ANTLR start "circularmovement"
circularmovement: function() {
var rcm =  null;
var mca = null;
var mcb = null;
try {
// Ham4HMLGen.g:2094:5: ( ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? ) )
// Ham4HMLGen.g:2095:5: ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? )
this.match(this.input,CRCLRMVMT,Ham4HMLGen.FOLLOW_CRCLRMVMT_in_circularmovement15529); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_movementcircle_in_circularmovement15547);
mca=this.movementcircle();
this.state._fsp--;
// Ham4HMLGen.g:2097:9: (mcb= movementcircle )?
var alt163=2;
var LA163_0 = this.input.LA(1);
if ( ((LA163_0>=HamCircleo && LA163_0<=HamCircler)||(LA163_0>=HamCircleul && LA163_0<=HamCircleuo)) ) {
alt163=1;
}
switch (alt163) {
case 1 :
// Ham4HMLGen.g:2097:11: mcb= movementcircle
this.pushFollow(Ham4HMLGen.FOLLOW_movementcircle_in_circularmovement15565);
mcb=this.movementcircle();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcm = hBuilder.newHMLElement("circularmovement");
hBuilder.checkedSetAttr(rcm, "movement", mca);
hBuilder.checkedSetAttr(rcm, "second_movement", mcb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcm;
},
// Ham4HMLGen.g:2106:1: ellipse returns [Element rell = null] : (ed= ellipsedirection (sz= size )? ) ;
// $ANTLR start "ellipse"
ellipse: function() {
var rell =  null;
var ed = null;
var sz = null;
try {
// Ham4HMLGen.g:2110:5: ( (ed= ellipsedirection (sz= size )? ) )
// Ham4HMLGen.g:2111:5: (ed= ellipsedirection (sz= size )? )
// Ham4HMLGen.g:2111:5: (ed= ellipsedirection (sz= size )? )
// Ham4HMLGen.g:2112:9: ed= ellipsedirection (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_ellipse15634);
ed=this.ellipsedirection();
this.state._fsp--;
// Ham4HMLGen.g:2113:9: (sz= size )?
var alt164=2;
var LA164_0 = this.input.LA(1);
if ( ((LA164_0>=HamSmallmod && LA164_0<=HamLargemod)) ) {
alt164=1;
}
switch (alt164) {
case 1 :
// Ham4HMLGen.g:2113:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_ellipse15653);
sz=this.size();
this.state._fsp--;
break;
}
rell = hBuilder.newHMLElement("ellipse");
hBuilder.checkedSetAttr(rell, "ellipsedirection", ed);
hBuilder.checkedSetAttr(rell, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rell;
},
// Ham4HMLGen.g:2122:1: revolutions[reve] : ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? ) ;
// $ANTLR start "revolutions"
revolutions: function(reve) {
var cs = null;
var ce = null;
var cfa = false;
var cfb = false;
try {
// Ham4HMLGen.g:2130:5: ( ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? ) )
// Ham4HMLGen.g:2131:5: ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? )
// Ham4HMLGen.g:2131:5: ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? )
// Ham4HMLGen.g:2132:9: (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )?
// Ham4HMLGen.g:2132:9: (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? )
var alt168=2;
var LA168_0 = this.input.LA(1);
if ( ((LA168_0>=HamClocku && LA168_0<=HamClockur)) ) {
alt168=1;
}
else if ( (LA168_0==HamClockfull) ) {
alt168=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 168, 0, this.input);
throw nvae;
}
switch (alt168) {
case 1 :
// Ham4HMLGen.g:2133:13: cs= clock ( HamClockfull ( HamClockfull )? )?
this.pushFollow(Ham4HMLGen.FOLLOW_clock_in_revolutions15734);
cs=this.clock();
this.state._fsp--;
// Ham4HMLGen.g:2134:13: ( HamClockfull ( HamClockfull )? )?
var alt166=2;
var LA166_0 = this.input.LA(1);
if ( (LA166_0==HamClockfull) ) {
alt166=1;
}
switch (alt166) {
case 1 :
// Ham4HMLGen.g:2135:17: HamClockfull ( HamClockfull )?
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15766); 
cfa = true; 
// Ham4HMLGen.g:2136:17: ( HamClockfull )?
var alt165=2;
var LA165_0 = this.input.LA(1);
if ( (LA165_0==HamClockfull) ) {
alt165=1;
}
switch (alt165) {
case 1 :
// Ham4HMLGen.g:2136:19: HamClockfull
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15795); 
cfb = true; 
break;
}
break;
}
break;
case 2 :
// Ham4HMLGen.g:2139:13: HamClockfull ( HamClockfull )?
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15844); 
cfa = true; 
// Ham4HMLGen.g:2140:13: ( HamClockfull )?
var alt167=2;
var LA167_0 = this.input.LA(1);
if ( (LA167_0==HamClockfull) ) {
alt167=1;
}
switch (alt167) {
case 1 :
// Ham4HMLGen.g:2140:15: HamClockfull
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15873); 
cfb = true; 
break;
}
break;
}
// Ham4HMLGen.g:2142:9: (ce= clock )?
var alt169=2;
var LA169_0 = this.input.LA(1);
if ( ((LA169_0>=HamClocku && LA169_0<=HamClockur)) ) {
alt169=1;
}
switch (alt169) {
case 1 :
// Ham4HMLGen.g:2142:13: ce= clock
this.pushFollow(Ham4HMLGen.FOLLOW_clock_in_revolutions15920);
ce=this.clock();
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(reve, "start", cs);
if (cfa) {
hBuilder.checkedSetAttr(reve, "clockfull", "true");
if (cfb) {
hBuilder.checkedSetAttr(reve, "second_clockfull", "true");
}
}
hBuilder.checkedSetAttr(reve, "end", ce);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2156:1: fullwristmovement returns [Element rfwm = null] : (wm= wristmovement (sz= size )? ) ;
// $ANTLR start "fullwristmovement"
fullwristmovement: function() {
var rfwm =  null;
var wm = null;
var sz = null;
try {
// Ham4HMLGen.g:2159:5: ( (wm= wristmovement (sz= size )? ) )
// Ham4HMLGen.g:2160:5: (wm= wristmovement (sz= size )? )
// Ham4HMLGen.g:2160:5: (wm= wristmovement (sz= size )? )
// Ham4HMLGen.g:2161:9: wm= wristmovement (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_wristmovement_in_fullwristmovement15983);
wm=this.wristmovement();
this.state._fsp--;
// Ham4HMLGen.g:2162:9: (sz= size )?
var alt170=2;
var LA170_0 = this.input.LA(1);
if ( ((LA170_0>=HamSmallmod && LA170_0<=HamLargemod)) ) {
alt170=1;
}
switch (alt170) {
case 1 :
// Ham4HMLGen.g:2162:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullwristmovement16002);
sz=this.size();
this.state._fsp--;
break;
}
rfwm = hBuilder.newHMLElement("wristmovement");
hBuilder.checkedSetAttr(rfwm, "movement", wm);
hBuilder.checkedSetAttr(rfwm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfwm;
},
// Ham4HMLGen.g:2171:1: fullmovementcross returns [Element rfmc = null] : (smc= movementcross (sz= size )? ) ;
// $ANTLR start "fullmovementcross"
fullmovementcross: function() {
var rfmc =  null;
var smc = null;
var sz = null;
try {
// Ham4HMLGen.g:2175:5: ( (smc= movementcross (sz= size )? ) )
// Ham4HMLGen.g:2176:5: (smc= movementcross (sz= size )? )
// Ham4HMLGen.g:2176:5: (smc= movementcross (sz= size )? )
// Ham4HMLGen.g:2177:9: smc= movementcross (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_movementcross_in_fullmovementcross16065);
smc=this.movementcross();
this.state._fsp--;
// Ham4HMLGen.g:2178:9: (sz= size )?
var alt171=2;
var LA171_0 = this.input.LA(1);
if ( ((LA171_0>=HamSmallmod && LA171_0<=HamLargemod)) ) {
alt171=1;
}
switch (alt171) {
case 1 :
// Ham4HMLGen.g:2178:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullmovementcross16084);
sz=this.size();
this.state._fsp--;
break;
}
rfmc = hBuilder.newHMLElement("movementcross");
hBuilder.checkedSetAttr(rfmc, "movementcross", smc);
hBuilder.checkedSetAttr(rfmc, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfmc;
},
// Ham4HMLGen.g:2188:1: replacement returns [Element rr = null] : ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? ) ;
// $ANTLR start "replacement"
replacement: function() {
var rr =  null;
var sc = null;
var hs = null;
var srt = null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:2191:5: ( ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? ) )
// Ham4HMLGen.g:2192:5: ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? )
this.match(this.input,REPLACE,Ham4HMLGen.FOLLOW_REPLACE_in_replacement16144); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:2193:9: (sc= sizechange )?
var alt172=2;
var LA172_0 = this.input.LA(1);
if ( ((LA172_0>=HamIncreasing && LA172_0<=HamDecreasing)) ) {
alt172=1;
}
switch (alt172) {
case 1 :
// Ham4HMLGen.g:2193:11: sc= sizechange
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_replacement16163);
sc=this.sizechange();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2194:9: (hs= handshape1 )?
var alt173=2;
var LA173_0 = this.input.LA(1);
if ( (LA173_0==HSHAPE1) ) {
alt173=1;
}
switch (alt173) {
case 1 :
// Ham4HMLGen.g:2194:11: hs= handshape1
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_replacement16185);
hs=this.handshape1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2195:9: (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )?
var alt175=4;
switch ( this.input.LA(1) ) {
case SPLITREPLACETL:
alt175=1;
break;
case EXTFIDIR1:
alt175=2;
break;
case PALMOR1:
alt175=3;
break;
}
switch (alt175) {
case 1 :
// Ham4HMLGen.g:2196:13: srt= splitreplacetail
this.pushFollow(Ham4HMLGen.FOLLOW_splitreplacetail_in_replacement16220);
srt=this.splitreplacetail();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:2198:13: efd= extfidir1 (po= palmor1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_replacement16252);
efd=this.extfidir1();
this.state._fsp--;
// Ham4HMLGen.g:2199:13: (po= palmor1 )?
var alt174=2;
var LA174_0 = this.input.LA(1);
if ( (LA174_0==PALMOR1) ) {
alt174=1;
}
switch (alt174) {
case 1 :
// Ham4HMLGen.g:2199:15: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacement16275);
po=this.palmor1();
this.state._fsp--;
break;
}
break;
case 3 :
// Ham4HMLGen.g:2201:13: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacement16311);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rr = hBuilder.newHMLElement("replacement");
hBuilder.checkedSetAttr(rr, "replace_incrdecr", sc);
hBuilder.checkedAppendChild(rr, hs);
if (srt == null) {
hBuilder.checkedAppendChild(rr, efd);
hBuilder.checkedAppendChild(rr, po);
}
else {
rr.appendChild(srt);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rr;
},
// Ham4HMLGen.g:2218:1: splitreplacetail returns [Element rsrt = null] : ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? ) ;
// $ANTLR start "splitreplacetail"
splitreplacetail: function() {
var rsrt =  null;
var drt = null;
var srt = null;
try {
// Ham4HMLGen.g:2221:5: ( ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? ) )
// Ham4HMLGen.g:2222:5: ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? )
this.match(this.input,SPLITREPLACETL,Ham4HMLGen.FOLLOW_SPLITREPLACETL_in_splitreplacetail16365); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_replacetail1_in_splitreplacetail16383);
drt=this.replacetail1();
this.state._fsp--;
// Ham4HMLGen.g:2224:9: (srt= replacetail1 )?
var alt176=2;
var LA176_0 = this.input.LA(1);
if ( (LA176_0==REPLACETAIL1) ) {
alt176=1;
}
switch (alt176) {
case 1 :
// Ham4HMLGen.g:2224:11: srt= replacetail1
this.pushFollow(Ham4HMLGen.FOLLOW_replacetail1_in_splitreplacetail16401);
srt=this.replacetail1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsrt = hBuilder.newHMLElement("splitreplacetail");
hBuilder.checkedAppendChild(rsrt, drt);
hBuilder.checkedAppendChild(rsrt, srt);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsrt;
},
// Ham4HMLGen.g:2233:1: replacetail1 returns [Element rrt = null] : ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) ) ;
// $ANTLR start "replacetail1"
replacetail1: function() {
var rrt =  null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:2236:5: ( ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) ) )
// Ham4HMLGen.g:2237:5: ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) )
this.match(this.input,REPLACETAIL1,Ham4HMLGen.FOLLOW_REPLACETAIL1_in_replacetail116451); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:2238:9: ( (efd= extfidir1 )? (po= palmor1 )? )
// Ham4HMLGen.g:2239:13: (efd= extfidir1 )? (po= palmor1 )?
// Ham4HMLGen.g:2239:13: (efd= extfidir1 )?
var alt177=2;
var LA177_0 = this.input.LA(1);
if ( (LA177_0==EXTFIDIR1) ) {
alt177=1;
}
switch (alt177) {
case 1 :
// Ham4HMLGen.g:2239:15: efd= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_replacetail116483);
efd=this.extfidir1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2240:13: (po= palmor1 )?
var alt178=2;
var LA178_0 = this.input.LA(1);
if ( (LA178_0==PALMOR1) ) {
alt178=1;
}
switch (alt178) {
case 1 :
// Ham4HMLGen.g:2240:15: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacetail116509);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rrt = hBuilder.newHMLElement("replacetail1");
hBuilder.checkedAppendChild(rrt, efd);
hBuilder.checkedAppendChild(rrt, po);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rrt;
},
// Ham4HMLGen.g:2253:1: repetition returns [String rr = null] : ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse ) ;
// $ANTLR start "repetition"
repetition: function() {
var rr =  null;
try {
// Ham4HMLGen.g:2255:5: ( ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse ) )
// Ham4HMLGen.g:2256:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
// Ham4HMLGen.g:2256:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
var alt179=5;
switch ( this.input.LA(1) ) {
case HamRepeatfromstart:
alt179=1;
break;
case HamRepeatfromstartseveral:
alt179=2;
break;
case HamRepeatcontinue:
alt179=3;
break;
case HamRepeatcontinueseveral:
alt179=4;
break;
case HamRepeatreverse:
alt179=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 179, 0, this.input);
throw nvae;
}
switch (alt179) {
case 1 :
// Ham4HMLGen.g:2256:9: HamRepeatfromstart
this.match(this.input,HamRepeatfromstart,Ham4HMLGen.FOLLOW_HamRepeatfromstart_in_repetition16573); 
rr = "ham_repeat_fromstart"; 
break;
case 2 :
// Ham4HMLGen.g:2257:9: HamRepeatfromstartseveral
this.match(this.input,HamRepeatfromstartseveral,Ham4HMLGen.FOLLOW_HamRepeatfromstartseveral_in_repetition16586); 
rr = "ham_repeat_fromstartseveral"; 
break;
case 3 :
// Ham4HMLGen.g:2259:9: HamRepeatcontinue
this.match(this.input,HamRepeatcontinue,Ham4HMLGen.FOLLOW_HamRepeatcontinue_in_repetition16626); 
rr = "ham_repeat_continue"; 
break;
case 4 :
// Ham4HMLGen.g:2260:9: HamRepeatcontinueseveral
this.match(this.input,HamRepeatcontinueseveral,Ham4HMLGen.FOLLOW_HamRepeatcontinueseveral_in_repetition16640); 
rr = "ham_repeat_continueseveral"; 
break;
case 5 :
// Ham4HMLGen.g:2262:9: HamRepeatreverse
this.match(this.input,HamRepeatreverse,Ham4HMLGen.FOLLOW_HamRepeatreverse_in_repetition16680); 
rr = "ham_repeat_reverse"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rr;
},
// Ham4HMLGen.g:2266:1: movementarrow returns [String rma = null] : ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo ) ;
// $ANTLR start "movementarrow"
movementarrow: function() {
var rma =  null;
try {
// Ham4HMLGen.g:2268:5: ( ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo ) )
// Ham4HMLGen.g:2269:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
// Ham4HMLGen.g:2269:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
var alt180=18;
switch ( this.input.LA(1) ) {
case HamMoveu:
alt180=1;
break;
case HamMoveur:
alt180=2;
break;
case HamMover:
alt180=3;
break;
case HamMovedr:
alt180=4;
break;
case HamMoved:
alt180=5;
break;
case HamMovedl:
alt180=6;
break;
case HamMovel:
alt180=7;
break;
case HamMoveul:
alt180=8;
break;
case HamMoveol:
alt180=9;
break;
case HamMoveo:
alt180=10;
break;
case HamMoveor:
alt180=11;
break;
case HamMoveil:
alt180=12;
break;
case HamMovei:
alt180=13;
break;
case HamMoveir:
alt180=14;
break;
case HamMoveui:
alt180=15;
break;
case HamMovedi:
alt180=16;
break;
case HamMovedo:
alt180=17;
break;
case HamMoveuo:
alt180=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 180, 0, this.input);
throw nvae;
}
switch (alt180) {
case 1 :
// Ham4HMLGen.g:2269:9: HamMoveu
this.match(this.input,HamMoveu,Ham4HMLGen.FOLLOW_HamMoveu_in_movementarrow16724); 
rma = "u"; 
break;
case 2 :
// Ham4HMLGen.g:2270:9: HamMoveur
this.match(this.input,HamMoveur,Ham4HMLGen.FOLLOW_HamMoveur_in_movementarrow16747); 
rma = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:2271:9: HamMover
this.match(this.input,HamMover,Ham4HMLGen.FOLLOW_HamMover_in_movementarrow16769); 
rma = "r"; 
break;
case 4 :
// Ham4HMLGen.g:2272:9: HamMovedr
this.match(this.input,HamMovedr,Ham4HMLGen.FOLLOW_HamMovedr_in_movementarrow16792); 
rma = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:2273:9: HamMoved
this.match(this.input,HamMoved,Ham4HMLGen.FOLLOW_HamMoved_in_movementarrow16814); 
rma = "d"; 
break;
case 6 :
// Ham4HMLGen.g:2274:9: HamMovedl
this.match(this.input,HamMovedl,Ham4HMLGen.FOLLOW_HamMovedl_in_movementarrow16837); 
rma = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:2275:9: HamMovel
this.match(this.input,HamMovel,Ham4HMLGen.FOLLOW_HamMovel_in_movementarrow16859); 
rma = "l"; 
break;
case 8 :
// Ham4HMLGen.g:2276:9: HamMoveul
this.match(this.input,HamMoveul,Ham4HMLGen.FOLLOW_HamMoveul_in_movementarrow16882); 
rma = "ul"; 
break;
case 9 :
// Ham4HMLGen.g:2277:9: HamMoveol
this.match(this.input,HamMoveol,Ham4HMLGen.FOLLOW_HamMoveol_in_movementarrow16904); 
rma = "ol"; 
break;
case 10 :
// Ham4HMLGen.g:2278:9: HamMoveo
this.match(this.input,HamMoveo,Ham4HMLGen.FOLLOW_HamMoveo_in_movementarrow16926); 
rma = "o"; 
break;
case 11 :
// Ham4HMLGen.g:2279:9: HamMoveor
this.match(this.input,HamMoveor,Ham4HMLGen.FOLLOW_HamMoveor_in_movementarrow16949); 
rma = "or"; 
break;
case 12 :
// Ham4HMLGen.g:2280:9: HamMoveil
this.match(this.input,HamMoveil,Ham4HMLGen.FOLLOW_HamMoveil_in_movementarrow16971); 
rma = "il"; 
break;
case 13 :
// Ham4HMLGen.g:2281:9: HamMovei
this.match(this.input,HamMovei,Ham4HMLGen.FOLLOW_HamMovei_in_movementarrow16993); 
rma = "i"; 
break;
case 14 :
// Ham4HMLGen.g:2282:9: HamMoveir
this.match(this.input,HamMoveir,Ham4HMLGen.FOLLOW_HamMoveir_in_movementarrow17016); 
rma = "ir"; 
break;
case 15 :
// Ham4HMLGen.g:2283:9: HamMoveui
this.match(this.input,HamMoveui,Ham4HMLGen.FOLLOW_HamMoveui_in_movementarrow17038); 
rma = "ui"; 
break;
case 16 :
// Ham4HMLGen.g:2284:9: HamMovedi
this.match(this.input,HamMovedi,Ham4HMLGen.FOLLOW_HamMovedi_in_movementarrow17060); 
rma = "di"; 
break;
case 17 :
// Ham4HMLGen.g:2285:9: HamMovedo
this.match(this.input,HamMovedo,Ham4HMLGen.FOLLOW_HamMovedo_in_movementarrow17082); 
rma = "do"; 
break;
case 18 :
// Ham4HMLGen.g:2286:9: HamMoveuo
this.match(this.input,HamMoveuo,Ham4HMLGen.FOLLOW_HamMoveuo_in_movementarrow17104); 
rma = "uo"; 
break;
}
rma = "ham_move_" + rma;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rma;
},
// Ham4HMLGen.g:2293:1: movementcross returns [String rmc = null] : ( HamMovecross | HamMovex ) ;
// $ANTLR start "movementcross"
movementcross: function() {
var rmc =  null;
try {
// Ham4HMLGen.g:2295:5: ( ( HamMovecross | HamMovex ) )
// Ham4HMLGen.g:2296:5: ( HamMovecross | HamMovex )
// Ham4HMLGen.g:2296:5: ( HamMovecross | HamMovex )
var alt181=2;
var LA181_0 = this.input.LA(1);
if ( (LA181_0==HamMovecross) ) {
alt181=1;
}
else if ( (LA181_0==HamMovex) ) {
alt181=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 181, 0, this.input);
throw nvae;
}
switch (alt181) {
case 1 :
// Ham4HMLGen.g:2296:9: HamMovecross
this.match(this.input,HamMovecross,Ham4HMLGen.FOLLOW_HamMovecross_in_movementcross17161); 
rmc = "ham_move_cross"; 
break;
case 2 :
// Ham4HMLGen.g:2297:9: HamMovex
this.match(this.input,HamMovex,Ham4HMLGen.FOLLOW_HamMovex_in_movementcross17180); 
rmc = "ham_move_x"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmc;
},
// Ham4HMLGen.g:2301:1: wristmovement returns [String rwm = null] : ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw ) ;
// $ANTLR start "wristmovement"
wristmovement: function() {
var rwm =  null;
try {
// Ham4HMLGen.g:2303:5: ( ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw ) )
// Ham4HMLGen.g:2304:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
// Ham4HMLGen.g:2304:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
var alt182=5;
switch ( this.input.LA(1) ) {
case HamNodding:
alt182=1;
break;
case HamSwinging:
alt182=2;
break;
case HamTwisting:
alt182=3;
break;
case HamStircw:
alt182=4;
break;
case HamStirccw:
alt182=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 182, 0, this.input);
throw nvae;
}
switch (alt182) {
case 1 :
// Ham4HMLGen.g:2304:9: HamNodding
this.match(this.input,HamNodding,Ham4HMLGen.FOLLOW_HamNodding_in_wristmovement17232); 
rwm = "ham_wrist_nodding"; 
break;
case 2 :
// Ham4HMLGen.g:2305:9: HamSwinging
this.match(this.input,HamSwinging,Ham4HMLGen.FOLLOW_HamSwinging_in_wristmovement17253); 
rwm = "ham_wrist_swinging"; 
break;
case 3 :
// Ham4HMLGen.g:2306:9: HamTwisting
this.match(this.input,HamTwisting,Ham4HMLGen.FOLLOW_HamTwisting_in_wristmovement17273); 
rwm = "ham_wrist_twisting"; 
break;
case 4 :
// Ham4HMLGen.g:2307:9: HamStircw
this.match(this.input,HamStircw,Ham4HMLGen.FOLLOW_HamStircw_in_wristmovement17293); 
rwm = "ham_wrist_stircw"; 
break;
case 5 :
// Ham4HMLGen.g:2308:9: HamStirccw
this.match(this.input,HamStirccw,Ham4HMLGen.FOLLOW_HamStirccw_in_wristmovement17315); 
rwm = "ham_wrist_stirccw"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rwm;
},
// Ham4HMLGen.g:2312:1: movementcircle returns [String rmc = null] : ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo ) ;
// $ANTLR start "movementcircle"
movementcircle: function() {
var rmc =  null;
try {
// Ham4HMLGen.g:2316:5: ( ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo ) )
// Ham4HMLGen.g:2317:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
// Ham4HMLGen.g:2317:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
var alt183=18;
switch ( this.input.LA(1) ) {
case HamCircleo:
alt183=1;
break;
case HamCirclei:
alt183=2;
break;
case HamCircled:
alt183=3;
break;
case HamCircleu:
alt183=4;
break;
case HamCirclel:
alt183=5;
break;
case HamCircler:
alt183=6;
break;
case HamCircleul:
alt183=7;
break;
case HamCircledr:
alt183=8;
break;
case HamCircleur:
alt183=9;
break;
case HamCircledl:
alt183=10;
break;
case HamCircleol:
alt183=11;
break;
case HamCircleir:
alt183=12;
break;
case HamCircleor:
alt183=13;
break;
case HamCircleil:
alt183=14;
break;
case HamCircleui:
alt183=15;
break;
case HamCircledo:
alt183=16;
break;
case HamCircledi:
alt183=17;
break;
case HamCircleuo:
alt183=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 183, 0, this.input);
throw nvae;
}
switch (alt183) {
case 1 :
// Ham4HMLGen.g:2317:9: HamCircleo
this.match(this.input,HamCircleo,Ham4HMLGen.FOLLOW_HamCircleo_in_movementcircle17364); 
rmc = "o"; 
break;
case 2 :
// Ham4HMLGen.g:2318:9: HamCirclei
this.match(this.input,HamCirclei,Ham4HMLGen.FOLLOW_HamCirclei_in_movementcircle17385); 
rmc = "i"; 
break;
case 3 :
// Ham4HMLGen.g:2319:9: HamCircled
this.match(this.input,HamCircled,Ham4HMLGen.FOLLOW_HamCircled_in_movementcircle17406); 
rmc = "d"; 
break;
case 4 :
// Ham4HMLGen.g:2320:9: HamCircleu
this.match(this.input,HamCircleu,Ham4HMLGen.FOLLOW_HamCircleu_in_movementcircle17427); 
rmc = "u"; 
break;
case 5 :
// Ham4HMLGen.g:2321:9: HamCirclel
this.match(this.input,HamCirclel,Ham4HMLGen.FOLLOW_HamCirclel_in_movementcircle17448); 
rmc = "l"; 
break;
case 6 :
// Ham4HMLGen.g:2322:9: HamCircler
this.match(this.input,HamCircler,Ham4HMLGen.FOLLOW_HamCircler_in_movementcircle17469); 
rmc = "r"; 
break;
case 7 :
// Ham4HMLGen.g:2323:9: HamCircleul
this.match(this.input,HamCircleul,Ham4HMLGen.FOLLOW_HamCircleul_in_movementcircle17490); 
rmc = "ul"; 
break;
case 8 :
// Ham4HMLGen.g:2324:9: HamCircledr
this.match(this.input,HamCircledr,Ham4HMLGen.FOLLOW_HamCircledr_in_movementcircle17510); 
rmc = "dr"; 
break;
case 9 :
// Ham4HMLGen.g:2325:9: HamCircleur
this.match(this.input,HamCircleur,Ham4HMLGen.FOLLOW_HamCircleur_in_movementcircle17530); 
rmc = "ur"; 
break;
case 10 :
// Ham4HMLGen.g:2326:9: HamCircledl
this.match(this.input,HamCircledl,Ham4HMLGen.FOLLOW_HamCircledl_in_movementcircle17550); 
rmc = "dl"; 
break;
case 11 :
// Ham4HMLGen.g:2327:9: HamCircleol
this.match(this.input,HamCircleol,Ham4HMLGen.FOLLOW_HamCircleol_in_movementcircle17570); 
rmc = "ol"; 
break;
case 12 :
// Ham4HMLGen.g:2328:9: HamCircleir
this.match(this.input,HamCircleir,Ham4HMLGen.FOLLOW_HamCircleir_in_movementcircle17590); 
rmc = "ir"; 
break;
case 13 :
// Ham4HMLGen.g:2329:9: HamCircleor
this.match(this.input,HamCircleor,Ham4HMLGen.FOLLOW_HamCircleor_in_movementcircle17610); 
rmc = "or"; 
break;
case 14 :
// Ham4HMLGen.g:2330:9: HamCircleil
this.match(this.input,HamCircleil,Ham4HMLGen.FOLLOW_HamCircleil_in_movementcircle17630); 
rmc = "il"; 
break;
case 15 :
// Ham4HMLGen.g:2331:9: HamCircleui
this.match(this.input,HamCircleui,Ham4HMLGen.FOLLOW_HamCircleui_in_movementcircle17650); 
rmc = "ui"; 
break;
case 16 :
// Ham4HMLGen.g:2332:9: HamCircledo
this.match(this.input,HamCircledo,Ham4HMLGen.FOLLOW_HamCircledo_in_movementcircle17670); 
rmc = "do"; 
break;
case 17 :
// Ham4HMLGen.g:2333:9: HamCircledi
this.match(this.input,HamCircledi,Ham4HMLGen.FOLLOW_HamCircledi_in_movementcircle17690); 
rmc = "di"; 
break;
case 18 :
// Ham4HMLGen.g:2334:9: HamCircleuo
this.match(this.input,HamCircleuo,Ham4HMLGen.FOLLOW_HamCircleuo_in_movementcircle17710); 
rmc = "uo"; 
break;
}
rmc = "ham_circle_" + rmc;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmc;
},
// Ham4HMLGen.g:2341:1: ellipsedirection returns [String red = null] : ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul ) ;
// $ANTLR start "ellipsedirection"
ellipsedirection: function() {
var red =  null;
try {
// Ham4HMLGen.g:2345:5: ( ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul ) )
// Ham4HMLGen.g:2346:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
// Ham4HMLGen.g:2346:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
var alt184=4;
switch ( this.input.LA(1) ) {
case HamEllipseh:
alt184=1;
break;
case HamEllipseur:
alt184=2;
break;
case HamEllipsev:
alt184=3;
break;
case HamEllipseul:
alt184=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);
throw nvae;
}
switch (alt184) {
case 1 :
// Ham4HMLGen.g:2346:9: HamEllipseh
this.match(this.input,HamEllipseh,Ham4HMLGen.FOLLOW_HamEllipseh_in_ellipsedirection17766); 
red = "h"; 
break;
case 2 :
// Ham4HMLGen.g:2347:9: HamEllipseur
this.match(this.input,HamEllipseur,Ham4HMLGen.FOLLOW_HamEllipseur_in_ellipsedirection17786); 
red = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:2348:9: HamEllipsev
this.match(this.input,HamEllipsev,Ham4HMLGen.FOLLOW_HamEllipsev_in_ellipsedirection17805); 
red = "v"; 
break;
case 4 :
// Ham4HMLGen.g:2349:9: HamEllipseul
this.match(this.input,HamEllipseul,Ham4HMLGen.FOLLOW_HamEllipseul_in_ellipsedirection17825); 
red = "ul"; 
break;
}
red = "ham_ellipse_" + red;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return red;
},
// Ham4HMLGen.g:2356:1: clock returns [String rclk = null] : ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur ) ;
// $ANTLR start "clock"
clock: function() {
var rclk =  null;
try {
// Ham4HMLGen.g:2360:5: ( ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur ) )
// Ham4HMLGen.g:2361:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
// Ham4HMLGen.g:2361:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
var alt185=8;
switch ( this.input.LA(1) ) {
case HamClocku:
alt185=1;
break;
case HamClockul:
alt185=2;
break;
case HamClockl:
alt185=3;
break;
case HamClockdl:
alt185=4;
break;
case HamClockd:
alt185=5;
break;
case HamClockdr:
alt185=6;
break;
case HamClockr:
alt185=7;
break;
case HamClockur:
alt185=8;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 185, 0, this.input);
throw nvae;
}
switch (alt185) {
case 1 :
// Ham4HMLGen.g:2361:9: HamClocku
this.match(this.input,HamClocku,Ham4HMLGen.FOLLOW_HamClocku_in_clock17887); 
rclk = "u"; 
break;
case 2 :
// Ham4HMLGen.g:2362:9: HamClockul
this.match(this.input,HamClockul,Ham4HMLGen.FOLLOW_HamClockul_in_clock17909); 
rclk = "ul"; 
break;
case 3 :
// Ham4HMLGen.g:2363:9: HamClockl
this.match(this.input,HamClockl,Ham4HMLGen.FOLLOW_HamClockl_in_clock17930); 
rclk = "l"; 
break;
case 4 :
// Ham4HMLGen.g:2364:9: HamClockdl
this.match(this.input,HamClockdl,Ham4HMLGen.FOLLOW_HamClockdl_in_clock17952); 
rclk = "dl"; 
break;
case 5 :
// Ham4HMLGen.g:2365:9: HamClockd
this.match(this.input,HamClockd,Ham4HMLGen.FOLLOW_HamClockd_in_clock17973); 
rclk = "d"; 
break;
case 6 :
// Ham4HMLGen.g:2366:9: HamClockdr
this.match(this.input,HamClockdr,Ham4HMLGen.FOLLOW_HamClockdr_in_clock17995); 
rclk = "dr"; 
break;
case 7 :
// Ham4HMLGen.g:2367:9: HamClockr
this.match(this.input,HamClockr,Ham4HMLGen.FOLLOW_HamClockr_in_clock18016); 
rclk = "r"; 
break;
case 8 :
// Ham4HMLGen.g:2368:9: HamClockur
this.match(this.input,HamClockur,Ham4HMLGen.FOLLOW_HamClockur_in_clock18038); 
rclk = "ur"; 
break;
}
rclk = "ham_clock_" + rclk;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rclk;
},
// Ham4HMLGen.g:2375:1: modifier returns [String rmod = null] : ( HamFast | HamSlow | HamTense | HamRest | HamHalt ) ;
// $ANTLR start "modifier"
modifier: function() {
var rmod =  null;
try {
// Ham4HMLGen.g:2377:5: ( ( HamFast | HamSlow | HamTense | HamRest | HamHalt ) )
// Ham4HMLGen.g:2378:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
// Ham4HMLGen.g:2378:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
var alt186=5;
switch ( this.input.LA(1) ) {
case HamFast:
alt186=1;
break;
case HamSlow:
alt186=2;
break;
case HamTense:
alt186=3;
break;
case HamRest:
alt186=4;
break;
case HamHalt:
alt186=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 186, 0, this.input);
throw nvae;
}
switch (alt186) {
case 1 :
// Ham4HMLGen.g:2378:9: HamFast
this.match(this.input,HamFast,Ham4HMLGen.FOLLOW_HamFast_in_modifier18099); 
rmod = "ham_fast"; 
break;
case 2 :
// Ham4HMLGen.g:2379:9: HamSlow
this.match(this.input,HamSlow,Ham4HMLGen.FOLLOW_HamSlow_in_modifier18123); 
rmod = "ham_slow"; 
break;
case 3 :
// Ham4HMLGen.g:2380:9: HamTense
this.match(this.input,HamTense,Ham4HMLGen.FOLLOW_HamTense_in_modifier18147); 
rmod = "ham_tense"; 
break;
case 4 :
// Ham4HMLGen.g:2381:9: HamRest
this.match(this.input,HamRest,Ham4HMLGen.FOLLOW_HamRest_in_modifier18170); 
rmod = "ham_rest"; 
break;
case 5 :
// Ham4HMLGen.g:2382:9: HamHalt
this.match(this.input,HamHalt,Ham4HMLGen.FOLLOW_HamHalt_in_modifier18194); 
rmod = "ham_halt"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmod;
},
// Ham4HMLGen.g:2386:1: arc returns [String ra = null] : ( HamArcl | HamArcu | HamArcr | HamArcd ) ;
// $ANTLR start "arc"
arc: function() {
var ra =  null;
try {
// Ham4HMLGen.g:2388:5: ( ( HamArcl | HamArcu | HamArcr | HamArcd ) )
// Ham4HMLGen.g:2389:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
// Ham4HMLGen.g:2389:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
var alt187=4;
switch ( this.input.LA(1) ) {
case HamArcl:
alt187=1;
break;
case HamArcu:
alt187=2;
break;
case HamArcr:
alt187=3;
break;
case HamArcd:
alt187=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 187, 0, this.input);
throw nvae;
}
switch (alt187) {
case 1 :
// Ham4HMLGen.g:2389:9: HamArcl
this.match(this.input,HamArcl,Ham4HMLGen.FOLLOW_HamArcl_in_arc18257); 
ra = "ham_arc_l"; 
break;
case 2 :
// Ham4HMLGen.g:2390:9: HamArcu
this.match(this.input,HamArcu,Ham4HMLGen.FOLLOW_HamArcu_in_arc18281); 
ra = "ham_arc_u"; 
break;
case 3 :
// Ham4HMLGen.g:2391:9: HamArcr
this.match(this.input,HamArcr,Ham4HMLGen.FOLLOW_HamArcr_in_arc18305); 
ra = "ham_arc_r"; 
break;
case 4 :
// Ham4HMLGen.g:2392:9: HamArcd
this.match(this.input,HamArcd,Ham4HMLGen.FOLLOW_HamArcd_in_arc18329); 
ra = "ham_arc_d"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:2396:1: size returns [String rsz = null] : ( HamSmallmod | HamLargemod ) ;
// $ANTLR start "size"
size: function() {
var rsz =  null;
try {
// Ham4HMLGen.g:2400:5: ( ( HamSmallmod | HamLargemod ) )
// Ham4HMLGen.g:2401:5: ( HamSmallmod | HamLargemod )
// Ham4HMLGen.g:2401:5: ( HamSmallmod | HamLargemod )
var alt188=2;
var LA188_0 = this.input.LA(1);
if ( (LA188_0==HamSmallmod) ) {
alt188=1;
}
else if ( (LA188_0==HamLargemod) ) {
alt188=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 188, 0, this.input);
throw nvae;
}
switch (alt188) {
case 1 :
// Ham4HMLGen.g:2401:9: HamSmallmod
this.match(this.input,HamSmallmod,Ham4HMLGen.FOLLOW_HamSmallmod_in_size18391); 
rsz = "small"; 
break;
case 2 :
// Ham4HMLGen.g:2402:9: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_size18411); 
rsz = "large"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsz;
},
// Ham4HMLGen.g:2406:1: sizechange returns [String rsc = null] : ( HamIncreasing | HamDecreasing ) ;
// $ANTLR start "sizechange"
sizechange: function() {
var rsc =  null;
try {
// Ham4HMLGen.g:2408:5: ( ( HamIncreasing | HamDecreasing ) )
// Ham4HMLGen.g:2409:5: ( HamIncreasing | HamDecreasing )
// Ham4HMLGen.g:2409:5: ( HamIncreasing | HamDecreasing )
var alt189=2;
var LA189_0 = this.input.LA(1);
if ( (LA189_0==HamIncreasing) ) {
alt189=1;
}
else if ( (LA189_0==HamDecreasing) ) {
alt189=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 189, 0, this.input);
throw nvae;
}
switch (alt189) {
case 1 :
// Ham4HMLGen.g:2409:9: HamIncreasing
this.match(this.input,HamIncreasing,Ham4HMLGen.FOLLOW_HamIncreasing_in_sizechange18463); 
rsc = "ham_increasing"; 
break;
case 2 :
// Ham4HMLGen.g:2410:9: HamDecreasing
this.match(this.input,HamDecreasing,Ham4HMLGen.FOLLOW_HamDecreasing_in_sizechange18481); 
rsc = "ham_decreasing"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsc;
}
// Delegated rules
}, true); // important to pass true to overwrite default implementations
// public class variables
org.antlr.lang.augmentObject(Ham4HMLGen, {
tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "WS", "HamTab", "HamLinefeed", "HamPagebreak", "HamReturn", "HamVersion40", "HamSpace", "HamExclaim", "HamQuery", "HamFullstop", "HamComma", "HamPlus", "HamMetaalt", "HamClocku", "HamClockul", "HamClockl", "HamClockdl", "HamClockd", "HamClockdr", "HamClockr", "HamClockur", "HamClockfull", "HamSymmpar", "HamSymmlr", "HamFist", "HamFlathand", "HamFinger2", "HamFinger23", "HamFinger23spread", "HamFinger2345", "HamThumboutmod", "HamThumbacrossmod", "HamPinch12", "HamPinchall", "HamPinch12open", "HamCee12", "HamCeeall", "HamCee12open", "HamThumbopenmod", "HamFingerstraightmod", "HamFingerbendmod", "HamFingerhookedmod", "HamNondominant", "HamDoublebent", "HamDoublehooked", "HamExtfingeru", "HamExtfingerur", "HamExtfingerr", "HamExtfingerdr", "HamExtfingerd", "HamExtfingerdl", "HamExtfingerl", "HamExtfingerul", "HamExtfingerol", "HamExtfingero", "HamExtfingeror", "HamExtfingeril", "HamExtfingeri", "HamExtfingerir", "HamExtfingerui", "HamExtfingerdi", "HamExtfingerdo", "HamExtfingeruo", "HamEarlobe", "HamNostrils", "HamShouldertop", "HamPalmu", "HamPalmur", "HamPalmr", "HamPalmdr", "HamPalmd", "HamPalmdl", "HamPalml", "HamPalmul", "HamReplace", "HamArmextended", "HamBehind", "HamEtc", "HamOrirelative", "HamTongue", "HamTeeth", "HamStomach", "HamNeutralspace", "HamHead", "HamHeadtop", "HamForehead", "HamEyebrows", "HamEyes", "HamNose", "HamEar", "HamCheek", "HamLips", "HamChin", "HamUnderchin", "HamNeck", "HamShoulders", "HamChest", "HamBelowstomach", "HamLrbeside", "HamLrat", "HamUpperarm", "HamElbow", "HamElbowinside", "HamLowerarm", "HamWristback", "HamWristpulse", "HamThumbball", "HamPalm", "HamHandback", "HamThumb", "HamIndexfinger", "HamMiddlefinger", "HamRingfinger", "HamPinky", "HamThumbside", "HamPinkyside", "HamBetween", "HamFingertip", "HamFingernail", "HamFingerpad", "HamFingermidjoint", "HamFingerbase", "HamFingerside", "HamWristtopulse", "HamWristtoback", "HamWristtothumb", "HamWristtopinky", "HamCoreftag", "HamCorefref", "HamNomotion", "HamMoveu", "HamMoveur", "HamMover", "HamMovedr", "HamMoved", "HamMovedl", "HamMovel", "HamMoveul", "HamMoveol", "HamMoveo", "HamMoveor", "HamMoveil", "HamMovei", "HamMoveir", "HamMoveui", "HamMovedi", "HamMovedo", "HamMoveuo", "HamMovecross", "HamMovex", "HamSmallmod", "HamLargemod", "HamArcl", "HamArcu", "HamArcr", "HamArcd", "HamWavy", "HamZigzag", "HamFingerplay", "HamParbegin", "HamParend", "HamCircleo", "HamCirclei", "HamCircled", "HamCircleu", "HamCirclel", "HamCircler", "HamIncreasing", "HamDecreasing", "HamClose", "HamTouch", "HamInterlock", "HamCross", "HamFast", "HamSlow", "HamTense", "HamRest", "HamHalt", "HamRepeatfromstart", "HamRepeatfromstartseveral", "HamRepeatcontinue", "HamRepeatcontinueseveral", "HamSeqbegin", "HamSeqend", "HamAlternatingmotion", "HamRepeatreverse", "HamBrushing", "HamNonipsi", "HamEllipseh", "HamEllipseur", "HamEllipsev", "HamEllipseul", "HamMime", "HamAltbegin", "HamAltend", "HamNodding", "HamSwinging", "HamTwisting", "HamStircw", "HamStirccw", "HamFusionbegin", "HamFusionend", "HamCircleul", "HamCircledr", "HamCircleur", "HamCircledl", "HamCircleol", "HamCircleir", "HamCircleor", "HamCircleil", "HamCircledo", "HamCircleui", "HamCircledi", "HamCircleuo", "HamNbs", "HAMSIGNS", "SIGN2", "SIGN1", "ICFG2", "ICFG1", "NMICLIST", "NMICUNIT", "MICFG2", "MICFG1", "HDCONFIG2", "HDCONFIG1", "SPLITHDCFG2", "HDCFGTAIL2", "HSHAPE2", "HSHAPE1", "BASICHDSHP1", "BASICHDSHP", "HSCLASS", "FIBENDING", "THUMBPOS", "FINGERLIST", "FISHPLIST", "FICRSSLIST", "FSHAPE", "FCROSSING", "THSPECIAL", "EXTFIDIR2", "EXTFIDIR1", "EXTFIDIR", "PALMOR2", "PALMOR1", "LOC2", "LOC1", "LOCTNBODYARM", "LOCTNBODY", "LOCTNHAND", "LOCTNARM", "LEVBODY", "LEVHAND", "LEVARM", "HCONSTLLN", "CNTCTBODY", "CNTCTHAND", "CNTCTOFHAND", "A2TLIST", "A1TLIST", "A1LIST", "ACTION2T", "ACTION1T", "ACTION2", "ACTION1", "PARACT2T", "SEQACT2T", "SPLITACT2LOC2", "SPLITACT2T", "PARACT1T", "SEQACT1T", "NMACT1T", "PARACT1", "REPETITIONS", "SIMPLEMVMT", "STRGHTMVMT", "CRCLRMVMT", "REPLACE", "SPLITREPLACETL", "REPLACETAIL1", "HSFINGERITEM", "LOCBODY", "MOVINGREPETITION", "SEQACT1", "SEQFUSEDACT2T", "SEQFUSEDACT1T", "SEQFUSEDACT1", "CNTCTOHHAND", "CNTCTOHARM"],
FOLLOW_HAMSIGNS_in_hamsignseq145: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_sign2or1_in_hamsignseq160: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x30000000, 0x00000000]),
FOLLOW_sign2_in_sign2or1242: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nondomsign1_in_sign2or1269: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_SIGN2_in_sign2320: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_symmoperator_in_sign2352: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
FOLLOW_initialconfig2_in_sign2371: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
FOLLOW_a2tstar_in_sign2391: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_initialconfig2_in_sign2420: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_sign2440: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamNomotion_in_sign2477: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_HamNondominant_in_sign2511: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_initialconfig1_in_sign2546: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_sign2566: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SIGN1_in_nondomsign1620: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamNondominant_in_nondomsign1640: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_initialconfig1_in_nondomsign1655: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_nondomsign1671: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamSymmpar_in_symmoperator741: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamSymmlr_in_symmoperator776: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator824: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator859: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator893: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator916: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamAlternatingmotion_in_symmoperator961: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
FOLLOW_HamNonipsi_in_symmoperator983: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ICFG2_in_initialconfig21044: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig21061: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
FOLLOW_minitialconfig2_in_initialconfig21082: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ICFG1_in_initialconfig11123: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig11140: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_minitialconfig1_in_initialconfig11161: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_NMICLIST_in_nminitialconfig1209: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nmicunit_in_nminitialconfig1238: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
FOLLOW_NMICUNIT_in_nmicunit1304: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelbody_in_nmicunit1332: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_levelarm_in_nmicunit1361: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_action1_in_nmicunit1385: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MICFG2_in_minitialconfig21425: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig2_in_minitialconfig21457: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_location2_in_minitialconfig21478: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig21513: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig21533: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_minitialconfig21560: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig21580: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MICFG1_in_minitialconfig11633: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig11651: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig11668: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCONFIG2_in_handconfig21718: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape2_in_handconfig21754: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000080]),
FOLLOW_handconfigtail2_in_handconfig21775: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_splithandconfig2_in_handconfig21814: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCONFIG1_in_handconfig11868: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape1_in_handconfig11887: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400000]),
FOLLOW_extfidir1_in_handconfig11905: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfig11927: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITHDCFG2_in_splithandconfig21982: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig1_in_splithandconfig21998: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
FOLLOW_handconfig1_in_splithandconfig22014: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCFGTAIL2_in_handconfigtail22058: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir2_in_handconfigtail22092: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_palmor2_in_handconfigtail22124: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22166: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfigtail22189: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00400000]),
FOLLOW_extfidir1_in_handconfigtail22211: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfigtail22234: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSHAPE2_in_handshape22292: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape1_in_handshape22310: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000200]),
FOLLOW_handshape1_in_handshape22328: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSHAPE1_in_handshape12376: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_basichandshape1_in_handshape12395: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00138000]),
FOLLOW_fingerlist_in_handshape12414: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00130000]),
FOLLOW_fingershapelist_in_handshape12436: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00120000]),
FOLLOW_fingercrossinglist_in_handshape12458: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00100000]),
FOLLOW_thumbspecial_in_handshape12481: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_BASICHDSHP1_in_basichandshape12524: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_basichandshape_in_basichandshape12542: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000800]),
FOLLOW_basichandshape_in_basichandshape12565: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_BASICHDSHP_in_basichandshape2614: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshapeclass_in_basichandshape2636: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_HamNondominant_in_basichandshape2665: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_HamEtc_in_basichandshape2692: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_thumbpos_in_basichandshape2776: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_fingerbending_in_basichandshape2809: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_fingerbending_in_basichandshape2850: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00004000]),
FOLLOW_thumbpos_in_basichandshape2878: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSCLASS_in_handshapeclass2937: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamFist_in_handshapeclass2951: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFlathand_in_handshapeclass2979: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger2_in_handshapeclass3003: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger23_in_handshapeclass3028: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger23spread_in_handshapeclass3052: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger2345_in_handshapeclass3070: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinch12_in_handshapeclass3092: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinchall_in_handshapeclass3117: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinch12open_in_handshapeclass3141: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCee12_in_handshapeclass3162: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCeeall_in_handshapeclass3189: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCee12open_in_handshapeclass3215: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_FIBENDING_in_fingerbending3270: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamFingerstraightmod_in_fingerbending3284: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingerbendmod_in_fingerbending3303: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingerhookedmod_in_fingerbending3326: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublebent_in_fingerbending3347: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublehooked_in_fingerbending3373: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_THUMBPOS_in_thumbpos3434: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamThumboutmod_in_thumbpos3448: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumbacrossmod_in_thumbpos3469: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumbopenmod_in_thumbpos3487: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumb_in_thumb3544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamIndexfinger_in_finger3594: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMiddlefinger_in_finger3615: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRingfinger_in_finger3635: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPinky_in_finger3657: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HSFINGERITEM_in_hsfingeritem3721: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_finger_in_hsfingeritem3735: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000]),
FOLLOW_HamLargemod_in_hsfingeritem3755: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_thumb_in_digit3823: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_digit3837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_FINGERLIST_in_fingerlist3886: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_hsfingeritem_in_fingerlist3902: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
FOLLOW_FISHPLIST_in_fingershapelist3966: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fingershape_in_fingershapelist3982: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00040000]),
FOLLOW_FICRSSLIST_in_fingercrossinglist4045: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fingercrossing_in_fingercrossinglist4061: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00080000]),
FOLLOW_FSHAPE_in_fingershape4116: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_fingershape4131: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_fingerbending_in_fingershape4145: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_FCROSSING_in_fingercrossing4186: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_fingercrossing4200: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7E000000]),
FOLLOW_fingerpart_in_fingercrossing4214: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_fingercrossing4228: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_THSPECIAL_in_thumbspecial4274: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamBetween_in_thumbspecial4289: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_finger_in_thumbspecial4315: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_thumbspecial4341: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_thumb_in_thumbspecial4406: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_fingerpart_in_thumbspecial4439: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingertip_in_fingerpart4505: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingernail_in_fingerpart4528: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerpad_in_fingerpart4550: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingermidjoint_in_fingerpart4573: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerbase_in_fingerpart4591: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerside_in_fingerpart4613: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_EXTFIDIR2_in_extfidir24674: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir1_in_extfidir24693: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00400000]),
FOLLOW_extfidir1_in_extfidir24712: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_EXTFIDIR1_in_extfidir14765: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir_in_extfidir14782: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_extfidir_in_extfidir14799: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_extfidir14822: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_EXTFIDIR_in_extfidir4885: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamExtfingeru_in_extfidir4919: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerur_in_extfidir4949: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerr_in_extfidir4978: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdr_in_extfidir5008: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerd_in_extfidir5037: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdl_in_extfidir5067: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerl_in_extfidir5096: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerul_in_extfidir5126: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerol_in_extfidir5183: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5234: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir5263: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingero_in_extfidir5317: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir5365: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5416: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir5445: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeril_in_extfidir5517: new org.antlr.runtime.BitSet([0x00000008, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir5568: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir5597: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeri_in_extfidir5651: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir5699: new org.antlr.runtime.BitSet([0x00000008, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir5750: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir5779: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5861: new org.antlr.runtime.BitSet([0x00000008, 0x0A000000]),
FOLLOW_HamExtfingerol_in_extfidir5912: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir5941: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir6013: new org.antlr.runtime.BitSet([0x00000008, 0x0A000000]),
FOLLOW_HamExtfingerol_in_extfidir6064: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir6093: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir6165: new org.antlr.runtime.BitSet([0x00000008, 0x50000000]),
FOLLOW_HamExtfingeril_in_extfidir6216: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir6245: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir6317: new org.antlr.runtime.BitSet([0x00000008, 0x50000000]),
FOLLOW_HamExtfingeril_in_extfidir6368: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir6397: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PALMOR2_in_palmor26498: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_palmor1_in_palmor26516: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_palmor26534: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PALMOR1_in_palmor16589: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_palmor_in_palmor16607: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00063FC0, 0x00000000]),
FOLLOW_palmor_in_palmor16635: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamEtc_in_palmor16665: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_palmor16707: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPalmu_in_palmor6776: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmur_in_palmor6799: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmr_in_palmor6821: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmdr_in_palmor6844: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmd_in_palmor6866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmdl_in_palmor6889: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalml_in_palmor6911: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmul_in_palmor6934: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LOC2_in_location26999: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_location1_in_location27031: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_location27052: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_handconstellation_in_location27088: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
FOLLOW_HamArmextended_in_location27126: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationbody_in_location27172: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOC1_in_location17243: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_location17271: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationhand_in_location17313: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationbodyarm_in_location17341: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNBODYARM_in_locationbodyarm7395: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_locationbody_in_locationbodyarm7423: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationarm_in_locationbodyarm7451: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamArmextended_in_locationbodyarm7477: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNBODY_in_locationbody7546: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexbody_in_locationbody7564: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00010000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamBehind_in_locationbody7584: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_contactbody_in_locationbody7640: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNHAND_in_locationhand7686: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexhand_in_locationhand7704: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_contacthand_in_locationhand7723: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNARM_in_locationarm7774: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexarm_in_locationarm7792: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00010000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamBehind_in_locationarm7812: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_contactbody_in_locationarm7868: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody7919: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000001, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody7937: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand7982: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand8000: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm8046: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000004, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm8064: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LEVBODY_in_levelbody8111: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelbody8130: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x60000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
FOLLOW_locbody_in_levelbody8163: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000000C0]),
FOLLOW_locsided_in_levelbody8192: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000000C0]),
FOLLOW_HamEtc_in_levelbody8222: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelbody8257: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LEVHAND_in_levelhand8311: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelhand8330: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7EFFF000]),
FOLLOW_handpart_in_levelhand8363: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_fingerpart_in_levelhand8402: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003F80C0]),
FOLLOW_digit_in_levelhand8433: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003F80C0]),
FOLLOW_digit_in_levelhand8476: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x7E3F80C0]),
FOLLOW_fingerpart_in_levelhand8510: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_dorsalorpalmar_in_levelhand8553: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelhand8575: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LEVARM_in_levelarm8630: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelarm8649: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000F00]),
FOLLOW_locarm_in_levelarm8672: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000180C0]),
FOLLOW_HamEtc_in_levelarm8692: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_dorsalorpalmar_in_levelarm8727: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelarm8749: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTBODY_in_contactbody8797: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contactbody8827: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamArmextended_in_contactbody8851: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactofhand_in_contactbody8903: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTHAND_in_contacthand8957: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contacthand8987: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ccontact_in_contacthand9017: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactofhand_in_contacthand9047: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOFHAND_in_contactofhand9109: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contactofhand9142: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000030]),
FOLLOW_ccontact_in_contactofhand9175: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000030]),
FOLLOW_contactohhand_in_contactofhand9217: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactoharm_in_contactofhand9249: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOHHAND_in_contactohhand9305: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexhand_in_contactohhand9319: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOHARM_in_contactoharm9364: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexarm_in_contactoharm9378: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HCONSTLLN_in_handconstellation9420: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_locationhand_in_handconstellation9448: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_locationhand_in_handconstellation9466: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_contacthand_in_handconstellation9496: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamUpperarm_in_locarm9551: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamElbow_in_locarm9575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamElbowinside_in_locarm9602: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLowerarm_in_locarm9623: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LOCBODY_in_locbody9683: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamHead_in_locbody9697: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamHeadtop_in_locbody9729: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamForehead_in_locbody9758: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamEyebrows_in_locbody9786: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamEyes_in_locbody9814: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNose_in_locbody9846: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNostrils_in_locbody9878: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamLips_in_locbody9906: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamTongue_in_locbody9938: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamTeeth_in_locbody9968: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamChin_in_locbody9999: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamUnderchin_in_locbody10031: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNeck_in_locbody10058: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamShouldertop_in_locbody10090: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamShoulders_in_locbody10115: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamChest_in_locbody10142: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamStomach_in_locbody10173: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamBelowstomach_in_locbody10202: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamDoublebent_in_locbody10246: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublehooked_in_locbody10272: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamEar_in_locsided10343: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEarlobe_in_locsided10372: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCheek_in_locsided10397: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamWristback_in_handpart10462: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamWristpulse_in_handpart10485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumbball_in_handpart10507: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalm_in_handpart10530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHandback_in_handpart10558: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumbside_in_handpart10582: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPinkyside_in_handpart10605: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLrbeside_in_side10690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLrat_in_side10714: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHandback_in_dorsalorpalmar10776: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalm_in_dorsalorpalmar10800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTouch_in_pcontact10866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClose_in_pcontact10893: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamInterlock_in_ccontact10964: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCross_in_ccontact10987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_A2TLIST_in_a2tstar11059: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_a2tstar11077: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_A1TLIST_in_a1tstar11139: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_a1tstar11157: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_ACTION2T_in_action2t11214: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_action2t11242: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_action1_in_action2t11272: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_location2_in_action2t11290: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_splitaction2loc2_in_action2t11319: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_splitaction2t_in_action2t11354: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_paraction2t_in_action2t11391: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqaction2t_in_action2t11419: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqfusedaction2t_in_action2t11447: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_repetitions_in_action2t11483: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ACTION1T_in_action1t11538: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_action1t11572: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000,0x00400008, 0x00000000]),
FOLLOW_location1_in_action1t11609: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_HamLargemod_in_action1t11633: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_handconstellation_in_action1t11677: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_paraction1t_in_action1t11724: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqaction1t_in_action1t11756: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqfusedaction1t_in_action1t11788: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_nmaction1t_in_action1t11819: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_repetitions_in_action1t11861: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ACTION1_in_action111917: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamNomotion_in_action111951: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_simplemovement_in_action112007: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_modifier_in_action112061: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x003E0000]),
FOLLOW_HamLargemod_in_action112128: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_paraction1_in_action112182: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_seqaction1_in_action112214: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_seqfusedaction1_in_action112246: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PARACT2T_in_paraction2t12307: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_paraction2t12337: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SEQACT2T_in_seqaction2t12403: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_seqaction2t12433: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SEQFUSEDACT2T_in_seqfusedaction2t12502: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_seqfusedaction2t12532: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SPLITACT2LOC2_in_splitaction2loc212597: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_splitaction2loc212617: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2loc212640: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_action1_in_splitaction2loc212660: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000,0x00002000, 0x00000000]),
FOLLOW_location2_in_splitaction2loc212691: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITACT2T_in_splitaction2t12737: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_splitaction2t12756: new org.antlr.runtime.BitSet([0x00008008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2t12778: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_action1t_in_splitaction2t12797: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_PARACT1T_in_paraction1t12857: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_paraction1t12887: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_SEQACT1T_in_seqaction1t12953: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_seqaction1t12983: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_SEQFUSEDACT1T_in_seqfusedaction1t13052: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_seqfusedaction1t13082: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_NMACT1T_in_nmaction1t13145: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelbody_in_nmaction1t13174: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_levelarm_in_nmaction1t13203: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_action1t_in_nmaction1t13234: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PARACT1_in_paraction113283: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_paraction113313: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_SEQACT1_in_seqaction113385: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_seqaction113415: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_SEQFUSEDACT1_in_seqfusedaction113490: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_seqfusedaction113520: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_REPETITIONS_in_repetitions13593: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_repetition_in_repetitions13644: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x33C01800]),
FOLLOW_HamEtc_in_repetitions13690: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_repetitions13734: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_repetition_in_repetitions13782: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_movingrepetition_in_repetitions13843: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_sizechange_in_repetitions13899: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x10000000]),
FOLLOW_size_in_repetitions13926: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions13986: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions13999: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14044: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14065: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MOVINGREPETITION_in_movingrepetition14122: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_repetition_in_movingrepetition14146: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_movingrepetition14169: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800]),
FOLLOW_size_in_movingrepetition14192: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechange_in_movingrepetition14228: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_movingrepetition14249: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SIMPLEMVMT_in_simplemovement14311: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fullstraightmovement_in_simplemovement14340: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullcircularmovement_in_simplemovement14369: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullwristmovement_in_simplemovement14398: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullmovementcross_in_simplemovement14427: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_replacement_in_simplemovement14456: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_digit_in_simplemovement14514: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x00000004]),
FOLLOW_HamFingerplay_in_simplemovement14579: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_simplemovement14639: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_simplemovement14658: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_simplemovement14687: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_straightmovement_in_fullstraightmovement14750: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000003]),
FOLLOW_size_in_fullstraightmovement14775: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xF0000000, 0x00000003]),
FOLLOW_arckind_in_fullstraightmovement14808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_zigzag_in_fullstraightmovement14839: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_STRGHTMVMT_in_straightmovement14894: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement14913: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement14932: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_arc_in_arckind14999: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000000]),
FOLLOW_arc_in_arckind15018: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_arckind15041: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamZigzag_in_zigzag15124: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_HamWavy_in_zigzag15160: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_zigzag15197: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_zigzag15219: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_zigzag15242: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sizechange_in_sizechangenonlinear15306: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_sizechangenonlinear15325: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_circularmovement_in_fullcircularmovement15388: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_fullcircularmovement15413: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_revolutions_in_fullcircularmovement15436: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipse_in_fullcircularmovement15459: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_fullcircularmovement15482: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_CRCLRMVMT_in_circularmovement15529: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement15547: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000007E0,0x03FFC000, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement15565: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ellipsedirection_in_ellipse15634: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_ellipse15653: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_clock_in_revolutions15734: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15766: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15795: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15844: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15873: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions15920: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_wristmovement_in_fullwristmovement15983: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_fullwristmovement16002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementcross_in_fullmovementcross16065: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_fullmovementcross16084: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_REPLACE_in_replacement16144: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_sizechange_in_replacement16163: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400200,0x08000000, 0x00000000]),
FOLLOW_handshape1_in_replacement16185: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400000,0x08000000, 0x00000000]),
FOLLOW_splitreplacetail_in_replacement16220: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_extfidir1_in_replacement16252: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_replacement16275: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_palmor1_in_replacement16311: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITREPLACETL_in_splitreplacetail16365: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail16383: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x10000000, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail16401: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_REPLACETAIL1_in_replacetail116451: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir1_in_replacetail116483: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_replacetail116509: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamRepeatfromstart_in_repetition16573: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatfromstartseveral_in_repetition16586: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatcontinue_in_repetition16626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatcontinueseveral_in_repetition16640: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatreverse_in_repetition16680: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveu_in_movementarrow16724: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveur_in_movementarrow16747: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMover_in_movementarrow16769: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedr_in_movementarrow16792: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoved_in_movementarrow16814: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedl_in_movementarrow16837: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovel_in_movementarrow16859: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveul_in_movementarrow16882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveol_in_movementarrow16904: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveo_in_movementarrow16926: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveor_in_movementarrow16949: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveil_in_movementarrow16971: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovei_in_movementarrow16993: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveir_in_movementarrow17016: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveui_in_movementarrow17038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedi_in_movementarrow17060: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedo_in_movementarrow17082: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveuo_in_movementarrow17104: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovecross_in_movementcross17161: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovex_in_movementcross17180: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNodding_in_wristmovement17232: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSwinging_in_wristmovement17253: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTwisting_in_wristmovement17273: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStircw_in_wristmovement17293: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStirccw_in_wristmovement17315: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleo_in_movementcircle17364: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCirclei_in_movementcircle17385: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircled_in_movementcircle17406: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleu_in_movementcircle17427: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCirclel_in_movementcircle17448: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircler_in_movementcircle17469: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleul_in_movementcircle17490: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledr_in_movementcircle17510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleur_in_movementcircle17530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledl_in_movementcircle17550: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleol_in_movementcircle17570: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleir_in_movementcircle17590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleor_in_movementcircle17610: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleil_in_movementcircle17630: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleui_in_movementcircle17650: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledo_in_movementcircle17670: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledi_in_movementcircle17690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleuo_in_movementcircle17710: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseh_in_ellipsedirection17766: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseur_in_ellipsedirection17786: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipsev_in_ellipsedirection17805: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseul_in_ellipsedirection17825: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClocku_in_clock17887: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockul_in_clock17909: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockl_in_clock17930: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockdl_in_clock17952: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockd_in_clock17973: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockdr_in_clock17995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockr_in_clock18016: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockur_in_clock18038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFast_in_modifier18099: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSlow_in_modifier18123: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTense_in_modifier18147: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRest_in_modifier18170: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHalt_in_modifier18194: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcl_in_arc18257: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcu_in_arc18281: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcr_in_arc18305: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcd_in_arc18329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSmallmod_in_size18391: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLargemod_in_size18411: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamIncreasing_in_sizechange18463: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamDecreasing_in_sizechange18481: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});
})();//-------- js/Coffee-fix.js --------
// Exports
this.getCWAEnv().add(Ham4Parser, "Ham4Parser");
//-------- js/HamLexer.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var CommonToken, EOF, HamLexer, Token, cwaenv, document, hamLimit, ttMap, ttUnused;
cwaenv = this.getCWAEnv();
document = this.document;
EOF = 1;
ttUnused = -1;
hamLimit = 256;
ttMap = [ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamTab, Ham4Parser.HamLinefeed, ttUnused, Ham4Parser.HamPagebreak, Ham4Parser.HamReturn, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamVersion40, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamSpace, Ham4Parser.HamExclaim, Ham4Parser.HamQuery, Ham4Parser.HamFullstop, Ham4Parser.HamComma, Ham4Parser.HamPlus, Ham4Parser.HamMetaalt, Ham4Parser.HamClocku, Ham4Parser.HamClockul, Ham4Parser.HamClockl, Ham4Parser.HamClockdl, Ham4Parser.HamClockd, Ham4Parser.HamClockdr, Ham4Parser.HamClockr, Ham4Parser.HamClockur, Ham4Parser.HamClockfull, Ham4Parser.HamSymmpar, Ham4Parser.HamSymmlr, Ham4Parser.HamFist, Ham4Parser.HamFlathand, Ham4Parser.HamFinger2, Ham4Parser.HamFinger23, Ham4Parser.HamFinger23spread, Ham4Parser.HamFinger2345, Ham4Parser.HamThumboutmod, Ham4Parser.HamThumbacrossmod, Ham4Parser.HamPinch12, Ham4Parser.HamPinchall, Ham4Parser.HamPinch12open, Ham4Parser.HamCee12, Ham4Parser.HamCeeall, Ham4Parser.HamCee12open, Ham4Parser.HamThumbopenmod, Ham4Parser.HamFingerstraightmod, Ham4Parser.HamFingerbendmod, Ham4Parser.HamFingerhookedmod, Ham4Parser.HamNondominant, Ham4Parser.HamDoublebent, Ham4Parser.HamDoublehooked, ttUnused, Ham4Parser.HamExtfingeru, Ham4Parser.HamExtfingerur, Ham4Parser.HamExtfingerr, Ham4Parser.HamExtfingerdr, Ham4Parser.HamExtfingerd, Ham4Parser.HamExtfingerdl, Ham4Parser.HamExtfingerl, Ham4Parser.HamExtfingerul, Ham4Parser.HamExtfingerol, Ham4Parser.HamExtfingero, Ham4Parser.HamExtfingeror, Ham4Parser.HamExtfingeril, Ham4Parser.HamExtfingeri, Ham4Parser.HamExtfingerir, Ham4Parser.HamExtfingerui, Ham4Parser.HamExtfingerdi, Ham4Parser.HamExtfingerdo, Ham4Parser.HamExtfingeruo, ttUnused, ttUnused, ttUnused, Ham4Parser.HamEarlobe, Ham4Parser.HamNostrils, Ham4Parser.HamShouldertop, Ham4Parser.HamPalmu, Ham4Parser.HamPalmur, Ham4Parser.HamPalmr, Ham4Parser.HamPalmdr, Ham4Parser.HamPalmd, Ham4Parser.HamPalmdl, Ham4Parser.HamPalml, Ham4Parser.HamPalmul, Ham4Parser.HamReplace, Ham4Parser.HamArmextended, Ham4Parser.HamBehind, Ham4Parser.HamEtc, Ham4Parser.HamOrirelative, Ham4Parser.HamTongue, Ham4Parser.HamTeeth, Ham4Parser.HamStomach, Ham4Parser.HamNeutralspace, Ham4Parser.HamHead, Ham4Parser.HamHeadtop, Ham4Parser.HamForehead, Ham4Parser.HamEyebrows, Ham4Parser.HamEyes, Ham4Parser.HamNose, Ham4Parser.HamEar, Ham4Parser.HamCheek, Ham4Parser.HamLips, Ham4Parser.HamChin, Ham4Parser.HamUnderchin, Ham4Parser.HamNeck, Ham4Parser.HamShoulders, Ham4Parser.HamChest, Ham4Parser.HamStomach, Ham4Parser.HamBelowstomach, Ham4Parser.HamLrbeside, Ham4Parser.HamLrat, Ham4Parser.HamUpperarm, Ham4Parser.HamElbow, Ham4Parser.HamElbowinside, Ham4Parser.HamLowerarm, Ham4Parser.HamWristback, Ham4Parser.HamWristpulse, Ham4Parser.HamThumbball, Ham4Parser.HamPalm, Ham4Parser.HamHandback, Ham4Parser.HamThumb, Ham4Parser.HamIndexfinger, Ham4Parser.HamMiddlefinger, Ham4Parser.HamRingfinger, Ham4Parser.HamPinky, Ham4Parser.HamThumbside, Ham4Parser.HamPinkyside, Ham4Parser.HamBetween, Ham4Parser.HamFingertip, Ham4Parser.HamFingernail, Ham4Parser.HamFingerpad, Ham4Parser.HamFingermidjoint, Ham4Parser.HamFingerbase, Ham4Parser.HamFingerside, Ham4Parser.HamWristtopulse, Ham4Parser.HamWristtoback, Ham4Parser.HamWristtothumb, Ham4Parser.HamWristtopinky, Ham4Parser.HamCoreftag, Ham4Parser.HamCorefref, Ham4Parser.HamNomotion, Ham4Parser.HamMoveu, Ham4Parser.HamMoveur, Ham4Parser.HamMover, Ham4Parser.HamMovedr, Ham4Parser.HamMoved, Ham4Parser.HamMovedl, Ham4Parser.HamMovel, Ham4Parser.HamMoveul, Ham4Parser.HamMoveol, Ham4Parser.HamMoveo, Ham4Parser.HamMoveor, Ham4Parser.HamMoveil, Ham4Parser.HamMovei, Ham4Parser.HamMoveir, Ham4Parser.HamMoveui, Ham4Parser.HamMovedi, Ham4Parser.HamMovedo, Ham4Parser.HamMoveuo, Ham4Parser.HamMovecross, Ham4Parser.HamMovex, Ham4Parser.HamSmallmod, Ham4Parser.HamLargemod, Ham4Parser.HamArcl, Ham4Parser.HamArcu, Ham4Parser.HamArcr, Ham4Parser.HamArcd, Ham4Parser.HamWavy, Ham4Parser.HamZigzag, Ham4Parser.HamFingerplay, Ham4Parser.HamParbegin, Ham4Parser.HamParend, Ham4Parser.HamCircleo, Ham4Parser.HamCirclei, Ham4Parser.HamCircled, Ham4Parser.HamCircleu, Ham4Parser.HamCirclel, Ham4Parser.HamCircler, Ham4Parser.HamIncreasing, Ham4Parser.HamDecreasing, Ham4Parser.HamClose, Ham4Parser.HamTouch, Ham4Parser.HamInterlock, Ham4Parser.HamCross, Ham4Parser.HamFast, Ham4Parser.HamSlow, Ham4Parser.HamTense, Ham4Parser.HamRest, Ham4Parser.HamHalt, Ham4Parser.HamRepeatfromstart, Ham4Parser.HamRepeatfromstartseveral, Ham4Parser.HamRepeatcontinue, Ham4Parser.HamRepeatcontinueseveral, Ham4Parser.HamSeqbegin, Ham4Parser.HamSeqend, Ham4Parser.HamAlternatingmotion, Ham4Parser.HamRepeatreverse, Ham4Parser.HamBrushing, Ham4Parser.HamNonipsi, ttUnused, Ham4Parser.HamEllipseh, Ham4Parser.HamEllipseur, Ham4Parser.HamEllipsev, Ham4Parser.HamEllipseul, Ham4Parser.HamMime, Ham4Parser.HamAltbegin, Ham4Parser.HamAltend, Ham4Parser.HamNodding, Ham4Parser.HamSwinging, Ham4Parser.HamTwisting, Ham4Parser.HamStircw, Ham4Parser.HamStirccw, ttUnused, ttUnused, ttUnused, ttUnused, Ham4Parser.HamFusionbegin, Ham4Parser.HamFusionend, ttUnused, ttUnused, Ham4Parser.HamCircleul, Ham4Parser.HamCircledr, Ham4Parser.HamCircleur, Ham4Parser.HamCircledl, Ham4Parser.HamCircleol, Ham4Parser.HamCircleir, Ham4Parser.HamCircleor, Ham4Parser.HamCircleil, Ham4Parser.HamCircledo, Ham4Parser.HamCircleui, Ham4Parser.HamCircledi, Ham4Parser.HamCircleuo, ttUnused, ttUnused, Ham4Parser.HamNbs, ttUnused];
Token = org.antlr.runtime.Token;
CommonToken = org.antlr.runtime.CommonToken;
HamLexer = (function() {
function HamLexer(hamSignCharCodes, tokenNames, logLev) {
this.hamSignCharCodes = hamSignCharCodes;
this.tokenNames = tokenNames;
this.logLev = logLev != null ? logLev : 0;
this.hamSignLength = this.hamSignCharCodes.length;
this.trace("HamLexer Overridden Input: " + this.hamSignCharCodes + " length=" + this.hamSignLength);
this.trace("HamLexer Tokens: " + this.tokenNames);
this.iScan = 0;
this.lMark = -1;
}
HamLexer.prototype.setLogLevel = function(lev) {
return this.logLev = lev;
};
HamLexer.prototype.trace = function(str) {
if (this.logLev >= 440) {
return console.log(str);
}
};
HamLexer.prototype.seek = function(ix) {
this.trace("Lex: seek(" + ix + ") called");
return this.iScan = ix;
};
HamLexer.prototype.rewind = function(ix) {
if (ix != null) {
this.trace("Lex: rewind(" + ix + ") called");
return this.iScan = ix;
} else {
this.trace("Lex: rewind() called");
if (this.lMark >= 0) {
return this.iScan = this.lMark;
}
}
};
HamLexer.prototype.mark = function() {
this.trace("Lex: mark() yeilds " + this.iScan);
this.lMark = this.iScan;
return this.iScan;
};
HamLexer.prototype.index = function() {
this.trace("Lex: index() yeilds " + this.iScan);
return this.iScan;
};
HamLexer.prototype.tokName = function(i) {
if (i === EOF) {
return "<EOF>";
} else if (i === ttUnused) {
return "<UNUSED>";
} else {
return this.tokenNames[i];
}
};
HamLexer.prototype.getType = function(i, tag) {
var ich, res;
res = Token.EOF;
if (i >= 0 && i < this.hamSignLength) {
ich = this.hamSignCharCodes.charCodeAt(i);
res = ich < hamLimit ? ttMap[ich] : ttUnused;
}
this.trace("Lex: at " + this.iScan + " getType(" + i + ") for " + tag + " yeilds " + res + "=" + (this.tokName(res)));
return res;
};
HamLexer.prototype.getToken = function(i) {
var ttype;
ttype = this.getType(i, "getToken");
return new CommonToken(ttype, (this.tokName(ttype)) + "{" + i + "}");
};
HamLexer.prototype.LA = function(ah) {
var typ;
typ = ah === 0 ? EOF : ah < 0 ? getType(this.iScan + ah, "LA") : this.getType(this.iScan + ah - 1, "LA");
this.trace("Lex: LA(" + ah + ") yeilds " + typ);
return typ;
};
HamLexer.prototype.LT = function(ah) {
this.trace("Lex: LT(" + ah + ") calls getToken");
if (ah === 0 || (this.iScan + ah) < 0) {
return null;
} else if (ah < 0) {
return this.getToken(this.iScan + ah);
} else {
return this.getToken(this.iScan + ah - 1);
}
};
HamLexer.prototype.consume = function() {
this.iScan++;
return this.trace("Lex: consume() now " + this.iScan);
};
return HamLexer;
})();
cwaenv.add(HamLexer, "HamLexer");
}).call(this);
//-------- js/HNSSign.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Defs, HNSSign, Node, cwaenv, logLev;
cwaenv = this.getCWAEnv();
Node = cwaenv.get("Node");
Defs = cwaenv.get("HNSDefs");
logLev = 0;
HNSSign = (function() {
function HNSSign(hnsEl, lev) {
this.hnsEl = hnsEl;
if (lev != null) {
logLev = lev;
}
this.hnsMan = "";
this.hnsNonMan = "";
this.hnsGloss = null;
this.hnsDuration = null;
this.hnsSpeed = null;
this.hnsTimeScale = null;
this.hnsSignElText = null;
this.hnsErr = null;
HNSSign.trace("HNS Sign object created");
this.scanRoot();
HNSSign.trace("Gloss:     [" + this.hnsGloss + "]");
HNSSign.trace("Manual:    [" + this.hnsMan + "]");
HNSSign.trace("Nonmanual: [" + this.hnsNonMan + "]");
}
HNSSign.prototype.scanRoot = function() {
var ref, ref1, ref2, ref3;
HNSSign.trace("Root Name " + this.hnsEl.nodeName);
if (this.hnsEl.nodeName === "hns_sign") {
this.hnsGloss = (ref = this.hnsEl.attributes.getNamedItem("gloss")) != null ? ref.value : void 0;
this.hnsDuration = (ref1 = this.hnsEl.attributes.getNamedItem("duration")) != null ? ref1.value : void 0;
this.hnsSpeed = (ref2 = this.hnsEl.attributes.getNamedItem("speed")) != null ? ref2.value : void 0;
this.hnsTimeScale = (ref3 = this.hnsEl.attributes.getNamedItem("timescale")) != null ? ref3.value : void 0;
return this._scanSign(this.hnsEl);
}
};
HNSSign.prototype._scanSign = function(el) {
var i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
HNSSign.trace("Sign Name " + nd.nodeName);
if (nd.nodeName === "hamnosys_manual") {
results.push(this._scanMan(nd));
} else if (nd.nodeName === "hamnosys_nonmanual") {
results.push(this._scanNonMan(nd));
} else {
results.push(void 0);
}
}
return results;
};
HNSSign.prototype._scanMan = function(el) {
var hamVal, i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (!(nd.nodeType === Node.ELEMENT_NODE)) {
continue;
}
hamVal = Defs.hamMap[nd.nodeName];
if (hamVal != null) {
HNSSign.trace("Man Element Name " + nd.nodeName + "=" + (hamVal.charCodeAt(0)));
this.hnsMan += hamVal;
} else {
console.warn("Manual Element not recognised: " + nd.nodeName);
}
results.push(this._scanMan(nd));
}
return results;
};
HNSSign.prototype._nonManVal = function(el) {
var currTag, i, ix, j, k, len, len1, len2, newTok, ref, ref1, tagMatch, tagVal, tags, testTag, theTag, tok;
theTag = el.tagName;
if (theTag === Defs.HNS_MOUTHPICTURE_TAG) {
tok = Defs.MOUTH_PICTURE_LETTER + el.getAttribute(Defs.PICTURE_ATTR);
} else {
tagVal = el.getAttribute(Defs.TAG_ATTR);
if (theTag === Defs.HNS_MOUTHGESTURE_TAG) {
tok = tagVal;
} else {
tok = "";
tags = (tagVal.replace(/\s/g, "")).split("|");
for (i = 0, len = tags.length; i < len; i++) {
currTag = tags[i];
tagMatch = -1;
ref = Defs.EYE_RELATED_HML_TAGS;
for (ix = j = 0, len1 = ref.length; j < len1; ix = ++j) {
testTag = ref[ix];
if (theTag === testTag) {
tagMatch = ix;
}
}
if (tagMatch >= 0) {
newTok = Defs.EYES_LETTER + currTag;
} else {
ref1 = Defs.NON_MOUTH_RELATED_HML_TAGS;
for (ix = k = 0, len2 = ref1.length; k < len2; ix = ++k) {
testTag = ref1[ix];
if (theTag === testTag) {
tagMatch = ix;
}
}
if (tagMatch >= 0) {
newTok = (Defs.NON_MOUTH_RELATED_LETTERS.charAt(tagMatch)) + currTag;
} else {
newTok = currTag;
}
}
tok = (tok === "" ? "" : tok + " ") + newTok;
}
}
}
return tok;
};
HNSSign.prototype._scanNonMan = function(el) {
var hamVal, i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (!(nd.nodeType === Node.ELEMENT_NODE)) {
continue;
}
hamVal = this._nonManVal(nd);
HNSSign.trace("NonMan Element Name " + nd.nodeName + ": " + hamVal);
if (this.hnsNonMan.length > 0) {
this.hnsNonMan += " ";
}
this.hnsNonMan += hamVal;
results.push(this._scanNonMan(nd));
}
return results;
};
HNSSign.prototype.man = function() {
return this.hnsMan;
};
HNSSign.prototype.nonman = function() {
return this.hnsNonMan;
};
HNSSign.prototype.gloss = function() {
return this.hnsGloss;
};
HNSSign.prototype.duration = function() {
return this.hnsDuration;
};
HNSSign.prototype.speed = function() {
return this.hnsSpeed;
};
HNSSign.prototype.timeScale = function() {
return this.hnsTimeScale;
};
HNSSign.setLogLevel = function(lev) {
return logLev = lev;
};
HNSSign.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
return HNSSign;
})();
cwaenv.add(HNSSign, "HNSSign");
}).call(this);
//-------- js/XSLT.Node.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, LibXSLT, XSLT, cwaenv, logLev;
cwaenv = this.getCWAEnv();
Data = cwaenv.get("Data");
LibXSLT = require("libxslt");
logLev = 0;
XSLT = (function() {
function XSLT(xslURI, lev) {
this.xslURI = xslURI;
if (lev != null) {
logLev = lev;
}
this.xslStyleSheet = null;
XSLT.trace("XSLT processor created for " + this.xslURI);
}
XSLT.prototype.applyXSLT = function(theXML) {
var err, txtRes, txtXML;
XSLT.trace("XSLT stylesheet " + this.xslURI + " apply");
txtXML = Data.mnDOM(theXML);
if (this.xslStyleSheet) {
try {
txtRes = this.xslStyleSheet.apply(txtXML);
return Data.toDOM(txtRes);
} catch (error) {
err = error;
console.warn("XSLT transform failure: " + err);
return null;
}
} else {
return null;
}
};
XSLT.prototype.syncXSLT = function(theCB) {
var ssCB;
if (this.xslStyleSheet) {
return theCB();
} else {
ssCB = (function(_this) {
return function(ssDoc, errC, errT) {
var ssResCB;
ssResCB = function(err, res) {
if (err) {
XSLT.trace("XSLT stylesheet " + _this.xslURI + " error " + err);
}
_this.xslStyleSheet = res;
XSLT.trace("XSLT stylesheet " + _this.xslURI + " parsed");
return theCB();
};
if (errC > 0) {
console.warn("XSLT stylesheet failure: " + errT);
return theCB();
} else {
XSLT.trace("XSLT stylesheet " + _this.xslURI + " parsing");
return LibXSLT.parse(ssDoc, ssResCB);
}
};
})(this);
return Data.fetchText(this.xslURI, ssCB);
}
};
XSLT.setLogLevel = function(lev) {
return logLev = lev;
};
XSLT.trace = function(str) {
if (logLev >= 440) {
return console.log(str);
}
};
return XSLT;
})();
cwaenv.add(XSLT, "XSLT");
}).call(this);
//-------- js/HtoG.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, HMLBuilder, HNSSign, Ham4Parser, HamLexer, HtoG, Node, XSLT, cwaenv, logLev;
cwaenv = this.getCWAEnv();
Data = cwaenv.get("Data");
Node = cwaenv.get("Node");
HNSSign = cwaenv.get("HNSSign");
HamLexer = cwaenv.get("HamLexer");
Ham4Parser = cwaenv.get("Ham4Parser");
HMLBuilder = cwaenv.get("HMLBuilder");
XSLT = cwaenv.get("XSLT");
logLev = 0;
HtoG = (function() {
function HtoG(XSLTURI, hmlLog, logLev1) {
this.XSLTURI = XSLTURI;
this.hmlLog = hmlLog != null ? hmlLog : false;
this.logLev = logLev1 != null ? logLev1 : 0;
this.XSLTProc = new XSLT(this.XSLTURI);
this.trace("HtoG processor created for \"" + this.XSLTURI + "\"");
}
HtoG.prototype.treeString = function(el) {
var i, j, n, ref, res;
res = "";
if (el) {
res = "(" + el;
n = el.getChildCount();
for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
res += " " + this.treeString(el.getChild(i));
}
res += ")";
}
return res;
};
HtoG.prototype._sortAttrs = function(el) {
var attList, attr, j, k, l, len, len1, len2, nd, newList, ref, results;
if (el.hasChildNodes()) {
ref = el.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
nd = ref[j];
if (nd.nodeType === Node.ELEMENT_NODE || nd.nodeType === Node.DOCUMENT_NODE) {
this._sortAttrs(nd);
}
}
}
if (el.nodeType === Node.ELEMENT_NODE && el.hasAttributes() && el.attributes.length > 1) {
attList = (function() {
var k, len1, ref1, results;
ref1 = el.attributes;
results = [];
for (k = 0, len1 = ref1.length; k < len1; k++) {
attr = ref1[k];
results.push(attr);
}
return results;
})();
newList = attList.sort(function(a, b) {
return a.name > b.name;
});
for (k = 0, len1 = attList.length; k < len1; k++) {
attr = attList[k];
el.removeAttribute(attr.name);
}
results = [];
for (l = 0, len2 = newList.length; l < len2; l++) {
attr = newList[l];
results.push(el.setAttribute(attr.name, attr.value));
}
return results;
}
};
HtoG.prototype.sortDocAttrs = function(doc) {
this._sortAttrs(doc.documentElement);
return doc;
};
HtoG.prototype._parseHSign = function(sigDoc) {
var builder, errReport, hamString, hmlDoc, lexer, parser, root, sigtrans, sigtree, treewalker;
this.trace("SiGML: " + sigDoc + " " + (Data.ppDOM(sigDoc)));
hmlDoc = new HNSSign(sigDoc);
hamString = hmlDoc.man();
lexer = new HamLexer(hamString, Ham4Parser.tokenNames, 0);
lexer.setLogLevel(this.logLev);
parser = new Ham4Parser(lexer);
parser.setLogLevel(this.logLev);
root = (parser.hamsinglesign()).getTree();
errReport = parser.checkErrors();
if (errReport != null) {
this.trace("Parse errors: " + errReport.errCount + ": " + errReport.errText);
return errReport;
} else {
this.trace("After parsing: " + (this.treeString(root)));
treewalker = new Ham4HMLGen(new org.antlr.runtime.tree.CommonTreeNodeStream(root));
HMLBuilder.setLogLevel(this.logLev);
builder = new HMLBuilder;
try {
sigtree = treewalker.hamsignseq(builder);
builder.insertNonManual(sigtree.documentElement, hmlDoc.nonman());
builder.checkedSetAttr(sigtree.documentElement, "gloss", hmlDoc.gloss());
builder.checkedSetAttr(sigtree.documentElement, "duration", hmlDoc.duration());
builder.checkedSetAttr(sigtree.documentElement, "speed", hmlDoc.speed());
builder.checkedSetAttr(sigtree.documentElement, "timescale", hmlDoc.timeScale());
this.trace("After tree building:\n" + (Data.ppDOM(sigtree)));
if (this.hmlLog) {
console.warn("########  HML -- gloss: " + (hmlDoc.gloss()) + "  ########\n" + (Data.ppDOM(sigtree)) + "\n");
}
sigtrans = this.XSLTProc.applyXSLT(sigtree);
this.trace("After XSLT processing:\n" + (Data.ppDOM(sigtrans)));
return {
sigDoc: sigtrans
};
} catch (error) {
this.trace("Failed tree building or XSLT transformation");
return {
errCount: 1,
errText: "Failed tree building or XSLT transformation"
};
}
}
};
HtoG.prototype._cleanSiGML = function(parent) {
var cn, j, k, len, len1, nd, nds, ref;
nds = [];
ref = parent.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
cn = ref[j];
if (cn != null) {
nds.push(cn);
}
}
for (k = 0, len1 = nds.length; k < len1; k++) {
nd = nds[k];
switch (nd.nodeType) {
case Node.COMMENT_NODE:
case Node.TEXT_NODE:
parent.removeChild(nd);
break;
default:
if (nd.childNodes != null) {
this._cleanSiGML(nd);
}
}
}
return parent;
};
HtoG.prototype._parseSiGML = function(sigDoc) {
var errCount, errText, gloss, j, len, nd, nom, parseRes, ref, ref1, ref2, signIx, typ;
errCount = 0;
errText = "";
signIx = 0;
if (sigDoc.documentElement != null) {
this._cleanSiGML(sigDoc);
ref = sigDoc.documentElement.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
nd = ref[j];
nom = nd != null ? nd.nodeName : void 0;
typ = nd != null ? nd.nodeType : void 0;
this.trace("SiGML Element: " + typ + " " + nom);
if (nom === "hns_sign") {
signIx + (gloss = (ref1 = nd.attributes.getNamedItem("gloss")) != null ? ref1.value : void 0);
this.trace("Sign " + signIx + ": " + nom + " gloss: " + gloss);
parseRes = this._parseHSign(nd);
if (parseRes != null ? parseRes.errText : void 0) {
errCount++;
errText += parseRes.errText + " [Sign: " + signIx + " Gloss: \"" + gloss + "\"]";
sigDoc.documentElement.removeChild(nd);
} else if (parseRes != null ? parseRes.sigDoc : void 0) {
sigDoc.documentElement.replaceChild(parseRes.sigDoc, nd);
}
} else if (nom === "hamgestural_sign") {
signIx++;
this.trace("Sign " + signIx + ": " + nom + " gloss: " + ((ref2 = nd.attributes.getNamedItem("gloss")) != null ? ref2.value : void 0));
}
}
} else {
errCount++;
errText += "Invalid SiGML file";
sigDoc = null;
}
return {
sigDoc: sigDoc,
errCount: errCount,
errText: errText
};
};
HtoG.prototype.parseHtoGText = function(sigTxt, theCB) {
var errCount, errText, errXML, gotXSLT, res, sigDoc;
errCount = 0;
errText = "";
res = {};
errXML = (function(_this) {
return function(level, msg) {
errCount++;
return errText += "XML parse " + level + ": " + msg;
};
})(this);
sigDoc = Data.toDOM("" + sigTxt, errXML);
if (sigDoc != null) {
res.sigDoc = sigDoc;
}
if (errCount > 0) {
res.errCount = errCount;
res.errText = errText;
return theCB(res);
} else {
gotXSLT = (function(_this) {
return function() {
return theCB(_this._parseSiGML(res.sigDoc));
};
})(this);
return this.XSLTProc.syncXSLT(gotXSLT);
}
};
HtoG.prototype.parseHtoGURI = function(sigURI, theCB) {
var gotSiGML, res;
res = {};
gotSiGML = (function(_this) {
return function(sigDoc, errCount, msg) {
if (errCount > 0) {
res.errCount = errCount;
res.errText = "SiGML fetch: " + msg;
if (sigDoc != null) {
res.sigDoc = sigDoc;
}
return theCB(res);
} else if (sigDoc != null) {
return _this.parseHtoGText(sigDoc, theCB);
} else {
res.errCount = 1;
res.errText = "No SiGML data found";
return theCB(res);
}
};
})(this);
return Data.fetchText(sigURI, gotSiGML);
};
HtoG.prototype.setLogLevel = function(lev) {
return this.logLev = lev;
};
HtoG.prototype.setHMLLog = function(flag) {
return this.hmlLog = flag;
};
HtoG.prototype.trace = function(str) {
if (this.logLev >= 440) {
return console.log(str);
}
};
return HtoG;
})();
cwaenv.add(HtoG, "HtoG");
}).call(this);
//-------- js/HtoG.main.js --------
// Generated by CoffeeScript 1.12.2
(function() {
var Data, FS, HMLLog, HtoG, HtoGProc, Node, argv, argvLen, convertDir, cwaenv, hmlFlag, logLev, parseSiGML, resultCall, sigURI, stem, xmlPrologue;
cwaenv = this.getCWAEnv();
HtoG = cwaenv.get("HtoG");
Data = cwaenv.get("Data");
Node = cwaenv.get("Node");
FS = require("fs");
argv = process.argv;
argvLen = argv.length;
logLev = 0;
HMLLog = false;
if (logLev >= 440) {
console.log("Args [" + argv + "] Length " + argvLen);
}
stem = argv[1].substr(0, argv[1].lastIndexOf("/"));
if (stem.length > 0) {
stem += "/";
}
HtoGProc = new HtoG(stem + "h2s.xsl", HMLLog, logLev);
xmlPrologue = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
parseSiGML = function(sigURI, theCB, extraArg) {
var sigFilCB;
if (extraArg == null) {
extraArg = null;
}
if (logLev >= 440) {
console.log("parseSiGML called for " + sigURI);
}
sigFilCB = (function(_this) {
return function(sigText, errCount, errText) {
var check, dom, i, ix, len, nd, newCB, ref, res;
res = {};
if (errCount > 0) {
res.errCount = errCount;
res.errText = errText;
return theCB(res, extraArg);
} else if (sigText != null) {
dom = Data.toDOM(sigText);
check = dom != null;
if (check) {
ref = dom.childNodes;
for (ix = i = 0, len = ref.length; i < len; ix = ++i) {
nd = ref[ix];
if (nd.nodeType === Node.TEXT_NODE) {
check && (check = (nd.nodeValue.trim()).length === 0);
}
}
}
if (check) {
newCB = function(res) {
return theCB(res, extraArg);
};
return HtoGProc.parseHtoGText(sigText, newCB);
} else {
res.errCount = 1;
res.errText = "Bad or empty content in SiGML file";
return theCB(res, extraArg);
}
} else {
res.errCount = 1;
res.errText = "No SiGML data found";
return theCB(res, extraArg);
}
};
})(this);
return Data.fetchText(sigURI, sigFilCB);
};
convertDir = function(dir) {
var dirCB, dirnew;
while (dir.endsWith("/")) {
dir = dir.substr(0, dir.length - 1);
}
dirnew = dir + "-g";
console.log("Directory mode for " + dir + " to " + dirnew);
dirCB = (function(_this) {
return function(err, files) {
var newDirCB;
if (err) {
return console.log("Cannot list files for directory " + dir);
} else {
newDirCB = function(err) {
var fil, i, len, procFile, sigFiles, worker;
if (err) {
return console.log("Cannot create new directory " + dirnew);
} else {
procFile = function(fil, nextCB) {
var infil, newFilCB, outfil;
infil = dir + "/" + fil;
outfil = dirnew + "/" + fil;
console.log("Process " + infil + " to " + outfil);
newFilCB = function(theRes, newfil) {
var doneCB, theG, theGtxt;
if ((theRes != null ? theRes.errCount : void 0) > 0) {
console.warn("Errors: " + theRes.errCount + " Text:\n" + theRes.errText);
console.log("Errors processing file so " + newfil + " not written");
return nextCB();
} else if (theRes != null ? theRes.sigDoc : void 0) {
theG = theRes.sigDoc;
HtoGProc.sortDocAttrs(theG);
theGtxt = xmlPrologue + Data.ppDOM(theG.documentElement);
if (!theGtxt.endsWith("\n")) {
theGtxt += "\n";
}
doneCB = function(err) {
if (err) {
console.log("Could not write " + newfil);
} else {
console.log("Wrote " + newfil);
}
return nextCB();
};
return FS.writeFile(newfil, theGtxt, doneCB);
} else {
console.warn("Unexpected outcome for " + newfil);
return nextCB();
}
};
return parseSiGML(infil, newFilCB, outfil);
};
sigFiles = [];
for (i = 0, len = files.length; i < len; i++) {
fil = files[i];
if (fil.match(".sigml")) {
sigFiles.push(fil);
}
}
console.log("Worker: Queue has " + sigFiles.length + " entries");
worker = function() {
var workfil;
workfil = sigFiles.pop();
if (workfil != null) {
return procFile(workfil, worker);
} else {
return console.log("Worker: Queue completed");
}
};
return worker();
}
};
return FS.mkdir(dirnew, newDirCB);
}
};
})(this);
return FS.readdir(dir, dirCB);
};
resultCall = function(theRes) {
var theG, theGtxt;
if ((theRes != null ? theRes.errCount : void 0) > 0) {
console.warn("Errors: " + theRes.errCount + " Text:\n" + theRes.errText);
}
if (theRes != null ? theRes.sigDoc : void 0) {
theG = theRes.sigDoc;
HtoGProc.sortDocAttrs(theG);
theGtxt = xmlPrologue + Data.ppDOM(theG.documentElement);
return ((theRes != null ? theRes.errCount : void 0) > 0 ? console.warn : console.log)(theGtxt);
}
};
if (argvLen === 4 && argv[2] === "-d") {
convertDir(argv[3]);
} else {
if (argvLen === 3) {
sigURI = argv[2];
} else if (argvLen === 4) {
sigURI = argv[3];
hmlFlag = argv[2] === "-hml" ? (HMLLog = true, HtoGProc.setHMLLog(HMLLog)) : argv[2] === "-log" ? (logLev = 440, HtoGProc.setLogLevel(logLev)) : sigURI = null;
}
if (sigURI != null) {
if (logLev >= 440) {
console.log("File mode for: " + sigURI);
}
parseSiGML(sigURI, resultCall);
} else {
console.log("Usage: [-hml|-log] SiGMLFile | -d SIGMLDir");
}
}
}).call(this);
//--------  END  --------
